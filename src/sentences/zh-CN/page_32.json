[
    {
        "source": "Generates a std::cout for the intrinsics results that will match the rust debug output format for the return type.",
        "suggest": "为内部函数结果生成一个 std::cout，该结果将匹配 Rust 调试输出格式的返回类型。",
        "translate": ""
    },
    {
        "source": "Only perform the test for intrinsics that are enabled...",
        "suggest": "只对启用的内部函数进行测试...",
        "translate": ""
    },
    {
        "source": "Not sure how we would compare intrinsic that returns void.",
        "suggest": "不知道我们如何比较返回 void 的内部函数。",
        "translate": ""
    },
    {
        "source": "Skip pointers for now, we would probably need to look at the return type to work out how many elements we need to point to.",
        "suggest": "现在跳过指针，我们可能需要查看返回类型来计算我们需要指向多少个元素。",
        "translate": ""
    },
    {
        "source": "intrinsics with a lane parameter have constraints, deal with them later.",
        "suggest": "带有 lane 参数的内部函数有约束，以后再处理。",
        "translate": ""
    },
    {
        "source": "fails to compile this intrinsic due to an error.",
        "suggest": "由于错误，无法编译此内部函数。",
        "translate": ""
    },
    {
        "source": "fatal error: error in backend: Cannot select: 0x2b99c30: i64 = AArch64ISD::VSHL Constant:i64<1>, Constant:i32<1>",
        "suggest": "致命错误: 后端错误: 无法选择: 0x2b99c30: i64 = AArch64ISD::VSHL Constant:i64<1>, Constant:i32<1>",
        "translate": ""
    },
    {
        "source": "Gets the type part of a c typedef for a type that's in the form of {type}{size}_t.",
        "suggest": "获取 {type}{size}_t 形式的类型的 c typedef 的类型部分。",
        "translate": ""
    },
    {
        "source": "Gets the rust prefix for the type kind i.e. i, u, f.",
        "suggest": "获取类型 kind 的 Rust 前缀，即 i、u、f。",
        "translate": ""
    },
    {
        "source": "The bit length of this type (e.g. 32 for u32).",
        "suggest": "这个类型的位长度 (例如，u32 为 32)。",
        "translate": ""
    },
    {
        "source": "Length of the SIMD vector (i.e. 4 for uint32x4_t), A value of `None` means this is not a simd type.",
        "suggest": "SIMD vector 的长度 (即 4 表示 uint32x4_t)，`None` 值就意味着这不是 simd 类型。",
        "translate": ""
    },
    {
        "source": "A `None` can be assumed to be 1, although in some places a distinction is needed between `u64` and `uint64x1_t` this signals that.",
        "suggest": "可以假设 `None` 为 1，尽管在某些地方需要区分 `u64` 和 `uint64x1_t`，这表明了这一点。",
        "translate": ""
    },
    {
        "source": "The number of rows for SIMD matrices (i.e. 2 for uint8x8x2_t).",
        "suggest": "SIMD 矩阵的行数 (即 2 表示 uint8x8x2_t)。",
        "translate": ""
    },
    {
        "source": "A value of `None` represents a type that does not contain any rows encoded in the type (e.g.",
        "suggest": "`None` 的值表示不包含在该类型中编码的任何行的类型 (例如",
        "translate": ""
    },
    {
        "source": "A value of `None` can be assumed to be 1 though.",
        "suggest": "但是 `None` 的值可以假设为 1。",
        "translate": ""
    },
    {
        "source": "Get the TypeKind for this type, recursing into pointers.",
        "suggest": "获取此类型的 TypeKind，递归到指针中。",
        "translate": ""
    },
    {
        "source": "Get the size of a single element inside this type, recursing into pointers, i.e.",
        "suggest": "获取该类型内单个元素的大小，递归到指针中，即",
        "translate": ""
    },
    {
        "source": "a pointer to a u16 would be 16 rather than the size of a pointer.",
        "suggest": "指向 u16 的指针将是 16 而不是指针的大小。",
        "translate": ""
    },
    {
        "source": "Determine if the type is a simd type, this will treat a type such as `uint64x1` as simd.",
        "suggest": "确定类型是否为 simd 类型，这会将 `uint64x1` 等类型视为 simd。",
        "translate": ""
    },
    {
        "source": "Gets a string containing the typename for this type in C format.",
        "suggest": "以 C 格式获取包含此类型的类型名称的字符串。",
        "translate": ""
    },
    {
        "source": "Gets a cast for this type if needs promotion.",
        "suggest": "如果需要升级，则获取此类型的强制转换。",
        "translate": ""
    },
    {
        "source": "This is required for 8 bit types due to printing as the 8 bit types use a char and when using that in `std::cout` it will print as a character, which means value of 0 will be printed as a null byte.",
        "suggest": "由于 8 位类型使用字符，因此这对于 8 位类型是必需的，当在 `std::cout` 中使用它时，它将打印为字符，这意味着 0 值将打印为空字节。",
        "translate": ""
    },
    {
        "source": "Generates a comma list of values that can be used to initialize an argument for the intrinsic call.",
        "suggest": "生成一个逗号值列表，可用于初始化内部函数调用的参数。",
        "translate": ""
    },
    {
        "source": "This is determistic based on the pass number.",
        "suggest": "这是基于通过数来确定的。",
        "translate": ""
    },
    {
        "source": "The pass index, i.e. the iteration index for the call to an intrinsic",
        "suggest": "通过索引，即调用到内部函数的迭代索引",
        "translate": ""
    },
    {
        "source": "Returns a string such as",
        "suggest": "返回一个字符串，例如",
        "translate": ""
    },
    {
        "source": "if `language` is `Language::C`",
        "suggest": "如果 `language` 是 `Language::C`",
        "translate": ""
    },
    {
        "source": "if `language` is `Language::Rust`",
        "suggest": "如果 `language` 是 `Language::Rust`",
        "translate": ""
    },
    {
        "source": "Determines the load function for this type.",
        "suggest": "确定此类型的加载函数。",
        "translate": ""
    },
    {
        "source": "Determines the get lane function for this type.",
        "suggest": "确定此类型的获取通道函数。",
        "translate": ""
    },
    {
        "source": "Gets a hex constant value for a single lane in in a determistic way",
        "suggest": "以确定的方式获取单个通道的十六进制常量值",
        "translate": ""
    },
    {
        "source": "The number of bits for the type, only 8, 16, 32, 64 are valid values",
        "suggest": "类型的位数，只有 8、16、32、64 是有效值",
        "translate": ""
    },
    {
        "source": "The index of the simd lane we are generating for",
        "suggest": "我们正在生成的 simd 通道的索引",
        "translate": ""
    },
    {
        "source": "The index of the pass we are generating the values for",
        "suggest": "我们正在生成值的传递的索引",
        "translate": ""
    },
    {
        "source": "The smallest normal value.",
        "suggest": "最小的正常值。",
        "translate": ""
    },
    {
        "source": "The value just below 0.5.",
        "suggest": "值略低于 0.5。",
        "translate": ""
    },
    {
        "source": "The value just above 0.5.",
        "suggest": "值略高于 0.5。",
        "translate": ""
    },
    {
        "source": "The value just below 1.0.",
        "suggest": "值略低于 1.0。",
        "translate": ""
    },
    {
        "source": "The value just above 1.0.",
        "suggest": "值略高于 1.0。",
        "translate": ""
    },
    {
        "source": "The largest finite value.",
        "suggest": "最大的有限值。",
        "translate": ""
    },
    {
        "source": "Quiet NaNs",
        "suggest": "安静的 NaNs",
        "translate": ""
    },
    {
        "source": "Signalling NaNs",
        "suggest": "信令 NaNs",
        "translate": ""
    },
    {
        "source": "A recognisable bit pattern.",
        "suggest": "可识别的位模式。",
        "translate": ""
    },
    {
        "source": "The largest subnormal value.",
        "suggest": "最大的 subnormal 值。",
        "translate": ""
    },
    {
        "source": "The smallest subnormal value.",
        "suggest": "最小的 subnormal 值。",
        "translate": ""
    },
    {
        "source": "The same values again, but negated.",
        "suggest": "再次相同的值再次被否定了。",
        "translate": ""
    },
    {
        "source": "Simple values.",
        "suggest": "单个值。",
        "translate": ""
    },
    {
        "source": "Target features need to be enabled for LLVM objdump on Macos ARM64",
        "suggest": "需要为 Macos ARM64 上的 LLVM objdump 启用目标功能",
        "translate": ""
    },
    {
        "source": "Normalize [us]shll.* ..., #0 instructions to the preferred form: [us]xtl.* ...",
        "suggest": "将 `[us]shll.* ..., #0` 指令规范化为首选形式: `[us]xtl.*` ...",
        "translate": ""
    },
    {
        "source": "as LLVM objdump does not do that.",
        "suggest": "因为 LLVM objdump 不这样做。",
        "translate": ""
    },
    {
        "source": "for details.",
        "suggest": "详情。",
        "translate": ""
    },
    {
        "source": "strip trailing comma",
        "suggest": "去除尾随逗号",
        "translate": ""
    },
    {
        "source": "Look for subroutine call instructions in the disassembly to detect whether inlining failed: all intrinsics are `#[inline(always)]`, so calling one intrinsic from another should not generate subroutine call instructions.",
        "suggest": "在反汇编中查找子程序调用指令来检测是否内联失败: 所有内部函数都是 `#[inline(always)]`，所以从另一个调用一个内部函数不应生成子程序调用指令。",
        "translate": ""
    },
    {
        "source": "original logic but does not match comment",
        "suggest": "与注释不匹配的原始逻辑",
        "translate": ""
    },
    {
        "source": "Add detection for other archs",
        "suggest": "添加对其他 archs 的检测",
        "translate": ""
    },
    {
        "source": "A iterator for deduping the key of a sorted iterator.",
        "suggest": "一个迭代器，用于对排序后的迭代器的键进行去重。",
        "translate": ""
    },
    {
        "source": "When encountering the duplicated key, only the last key-value pair is yielded.",
        "suggest": "当遇到重复的键时，只产生最后一个键值对。",
        "translate": ""
    },
    {
        "source": "Used by [`BTreeMap::bulk_build_from_sorted_iter`].",
        "suggest": "由 [`BTreeMap::bulk_build_from_sorted_iter`] 使用。",
        "translate": ""
    },
    {
        "source": "Makes a `BTreeMap` from a sorted iterator.",
        "suggest": "从排序的迭代器生成一个 `BTreeMap`。",
        "translate": ""
    },
    {
        "source": "use stable sort to preserve the insertion order.",
        "suggest": "使用稳定排序来保留插入顺序。",
        "translate": ""
    },
    {
        "source": "Traversal isn't needed, it happens using the result of `borrow_mut`.",
        "suggest": "遍历是不需要的，无论发生什么都使用 `borrow_mut` 的结果。",
        "translate": ""
    },
    {
        "source": "Therefore, we move all the resizing and error-handling logic from grow_amortized and handle_reserve behind a call, while making sure that this function is likely to be inlined as just a comparison and a call if the comparison fails.",
        "suggest": "因此，我们将所有的调整大小和错误处理逻辑从 grow_amortized 和 handle_reserve 移到一个调用之后，同时确保如果比较失败，这个函数很可能被内联为一个比较和一个调用。",
        "translate": ""
    },
    {
        "source": "This way, you can avoid moving the original array if its elements are not [`Copy`].",
        "suggest": "这样，如果原始数组的元素不是 [`Copy`]，则可以避免移动原始数组。",
        "translate": ""
    },
    {
        "source": "Returns `Some(t)` if the `bool` is [`true`](../std/keyword.true.html), or `None` otherwise.",
        "suggest": "如果 `bool` 是 [`true`](../std/keyword.true.html)，则返回 `Some(t)`，否则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns `Some(f())` if the `bool` is [`true`](../std/keyword.true.html), or `None` otherwise.",
        "suggest": "如果 `bool` 是 [`true`](../std/keyword.true.html)，则返回 `Some(f())`，否则返回 `None`。",
        "translate": ""
    },
    {
        "source": "It can occur, for example, when giving ill-formed UTF-8 bytes to [`String::from_utf8_lossy`](../std/string/struct.String.html#method.from_utf8_lossy).",
        "suggest": "例如，当将格式错误的 UTF-8 字节提供给 [`String::from_utf8_lossy`](../std/string/struct.String.html#method.from_utf8_lossy) 时，就会发生这种情况。",
        "translate": ""
    },
    {
        "source": "Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):",
        "suggest": "使用 [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):",
        "translate": ""
    },
    {
        "source": "This will escape the characters similar to the [`Debug`](core::fmt::Debug) implementations of `str` or `char`.",
        "suggest": "这将转义类似于 `str` 或 `char` 的 [`Debug`](core::fmt::Debug) 实现的字符。",
        "translate": ""
    },
    {
        "source": "Equivalent to <code>[to_ascii_lowercase]\\(a) == [to_ascii_lowercase]\\(b)</code>.",
        "suggest": "相当于 <code>[to_ascii_lowercase]\\(a) == [to_ascii_lowercase]\\(b)</code>。",
        "translate": ""
    },
    {
        "source": "The reducing function is a closure with two arguments: an 'accumulator', and an element.",
        "suggest": "Reduce 函数是一个闭包，有两个参数: 一个 'accumulator' 和一个元素。",
        "translate": ""
    },
    {
        "source": "For iterators with at least one element, this is the same as [`fold()`] with the first element of the iterator as the initial accumulator value, folding every subsequent element into it.",
        "suggest": "对于具有至少一个元素的迭代器，这与 [`fold()`] 相同，将迭代器的第一个元素作为初始累加器值，将每个后续元素 fold 到其中。",
        "translate": ""
    },
    {
        "source": "Those implementations are:",
        "suggest": "这些实现是:",
        "translate": ""
    },
    {
        "source": "Arrays `[T; N]` implement `Unsize<[T]>`.",
        "suggest": "数组 `[T; N]` 实现 `Unsize<[T]>`。",
        "translate": ""
    },
    {
        "source": "Types implementing a trait `Trait` also implement `Unsize<dyn Trait>`.",
        "suggest": "实现 trait `Trait` 的类型也实现 `Unsize<dyn Trait>`。",
        "translate": ""
    },
    {
        "source": "Structs `Foo<..., T, ...>` implement `Unsize<Foo<..., U, ...>>` if all of these conditions are met:",
        "suggest": "如果满足所有这些条件，结构体 `Foo<..., T, ...>` 实现 `Unsize<Foo<..., U, ...>>`:",
        "translate": ""
    },
    {
        "source": "Only the last field of `Foo` has a type involving `T`.",
        "suggest": "只有 `Foo` 的最后一个字段具有涉及 `T` 的类型。",
        "translate": ""
    },
    {
        "source": "where `Bar<T>` stands for the actual type of that last field.",
        "suggest": "其中 `Bar<T>` 代表最后一个字段的实际类型。",
        "translate": ""
    },
    {
        "source": "Returns `None` is `rhs` is zero or the operation would result in overflow.",
        "suggest": "如果 `rhs` 为零，则返回 `None`，否则操作将导致溢出。",
        "translate": ""
    },
    {
        "source": "is guaranteed to have the same layout and ABI as `T`.",
        "suggest": "保证与 `T` 具有相同的布局和 ABI。",
        "translate": ""
    },
    {
        "source": "Inserts `value` into the option, then returns a mutable reference to it.",
        "suggest": "将 `value` 插入到选项，然后返回对它的可变引用。",
        "translate": ""
    },
    {
        "source": "Unzips an option containing a tuple of two options.",
        "suggest": "解压缩包含两个选项的元组的选项。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Some`] value or a default.",
        "suggest": "返回包含的 [`Some`] 值或默认值。",
        "translate": ""
    },
    {
        "source": "Leaves the original `Option` in-place, creating a new one containing a mutable reference to the inner type's [`Deref::Target`] type.",
        "suggest": "在这里保留原始的 `Option`，创建一个包含对内部类型的 [`Deref::Target`] 类型的可变引用的新的 `Option`。",
        "translate": ""
    },
    {
        "source": "Moves `val` into a new [`Some`].",
        "suggest": "将 `val` 移动到新的 [`Some`] 中。",
        "translate": ""
    },
    {
        "source": "Should no [`None`][Option::None] occur, a container of type `V` containing the values of each [`Option`] is returned.",
        "suggest": "如果没有出现 [`None`][Option::None]，则返回一个 `V` 类型的容器，其中包含每个 [`Option`] 的值。",
        "translate": ""
    },
    {
        "source": "Converts from `Option<Option<T>>` to `Option<T>`.",
        "suggest": "从 `Option<Option<T>>` 转换为 `Option<T>`。",
        "translate": ""
    },
    {
        "source": "should have the same contents.",
        "suggest": "应该有相同的内容。",
        "translate": ""
    },
    {
        "source": "These are different files so that relative links work properly without having to have `CARGO_PKG_NAME` set, but conceptually they should always be the same.",
        "suggest": "这些是不同的文件，因此相关链接无需设置 `CARGO_PKG_NAME` 即可正常工作，但从概念上讲，它们应该始终相同。",
        "translate": ""
    },
    {
        "source": "The `bool` represents a value, which could only be either [`true`] or [`false`].",
        "suggest": "`bool` 代表一个值，它只能是 [`true`] 或 [`false`]。",
        "translate": ""
    },
    {
        "source": "If you cast a `bool` into an integer, [`true`] will be 1 and [`false`] will be 0.",
        "suggest": "如果将 `bool` 转换为整数，则 [`true`] 表示为 1，[`false`] 表示为 0。",
        "translate": ""
    },
    {
        "source": "which is an important macro in testing, checks whether an expression is [`true`] and panics if it isn't.",
        "suggest": "测试中的一个重要宏，检查表达式是否为 [`true`]，如果不是则为 panics。",
        "translate": ""
    },
    {
        "source": "Prior to Rust 1.53, arrays did not implement [`IntoIterator`] by value, so the method call `array.into_iter()` auto-referenced into a [slice iterator](slice::iter).",
        "suggest": "在 Rust 1.53 之前，数组没有按值实现 [`IntoIterator`]，因此调用 `array.into_iter()` 方法自动引用到 [slice 迭代器](slice::iter)。",
        "translate": ""
    },
    {
        "source": "Right now, the old behavior is preserved in the 2015 and 2018 editions of Rust for compatibility, ignoring [`IntoIterator`] by value.",
        "suggest": "目前，为了兼容性，Rust 的 2015 和 2018 版本中保留了旧行为，忽略了 [`IntoIterator`] 的值。",
        "translate": ""
    },
    {
        "source": "For example, in [`PartialOrd`] and [`Ord`], the elements are compared sequentially until the first non-equal set is found.",
        "suggest": "例如，在 [`PartialOrd`] 和 [`Ord`] 中，元素按顺序进行比较，直到找到第一个不相等的集合。",
        "translate": ""
    },
    {
        "source": "You can get one by using the `&` or `&mut` operators on a value, or by using a [`ref`](../std/keyword.ref.html) or <code>[ref](../std/keyword.ref.html) [mut](../std/keyword.mut.html)</code> pattern.",
        "suggest": "您可以通过在值上使用 `&` 或 `&mut` 运算符，或者使用 [`ref`](../std/keyword.ref.html) 或 <code>[ref](../std/keyword.ref.html) [mut](../std/keyword.mut.html)</code> 模式。",
        "translate": ""
    },
    {
        "source": "For those familiar with pointers, a reference is just a pointer that is assumed to be aligned, not null, and pointing to memory containing a valid value of `T` - for example, <code>&[bool]</code> can only point to an allocation containing the integer values `1` ([`true`](../std/keyword.true.html)) or `0` ([`false`](../std/keyword.false.html)), but creating a <code>&[bool]</code> that points to an allocation containing the value `3` causes undefined behaviour.",
        "suggest": "对于那些熟悉指针的人来说，引用只是一个被认为是对齐的指针，而不是空的，并且指向包含有效值 `T` 的内存 -- 例如， <code>&[bool]</code> 只能指向包含整数值 `1` ([`true`](../std/keyword.true.html)) 或 `0` ([`false`](../std/keyword.false.html)) 的分配，但创建一个 <code>&[bool]</code> 指向包含值 `3` 的分配会导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "In fact, <code>[Option]\\<&T></code> has the same memory representation as a nullable but aligned pointer, and can be passed across FFI boundaries as such.",
        "suggest": "事实上，<code>[Option]\\<&T></code> 与可为空但已对齐的指针具有相同的内存表示，并且可以像这样跨 FFI 边界传递。",
        "translate": ""
    },
    {
        "source": "\\(note that `&T` references only get `Send` if <code>T: [Sync]</code>)",
        "suggest": "\\ (注意 `&T` 引用只在 <code>T: [Sync]</code> 得到 `Send` )",
        "translate": ""
    },
    {
        "source": "Like references, function pointers are, among other things, assumed to not be null, so if you want to pass a function pointer over FFI and be able to accommodate null pointers, make your type [`Option<fn()>`](core::option#options-and-pointers-nullable-pointers) with your required signature.",
        "suggest": "像引用一样，函数指针被假定为不为空，所以如果您想通过 FFI 传递函数指针并能够容纳空指针，请使用所需的签名来创建类型 [`Option<fn()>`](core::option#options-and-pointers-nullable-pointers)。",
        "translate": ""
    },
    {
        "source": "Lint rustdoc::broken_intra_doc_links is allowed as `slice::sort_by_key` is in crate `alloc`, and as such doesn't exists yet when building `core`:",
        "suggest": "Lint rustdoc::broken_intra_doc_links 是允许的，因为 `slice::sort_by_key` 在 `alloc` crate 中，因此在构建 `core` 时还不存在:",
        "translate": ""
    },
    {
        "source": "This breaks links when slice is displayed in core, but changing it to use relative links would break when the item is re-exported.",
        "suggest": "当切片显示在核心中时，这会断开链接，但将其更改为使用相对链接会在项目重新导出时断开。",
        "translate": ""
    },
    {
        "source": "So allow the core links to be broken for now.",
        "suggest": "所以现在允许核心链接被破坏。",
        "translate": ""
    },
    {
        "source": "Creates an empty span pointing to directly before this span.",
        "suggest": "创建一个直接指向此跨度之前的空跨度。",
        "translate": ""
    },
    {
        "source": "Creates an empty span pointing to directly after this span.",
        "suggest": "创建一个直接指向此跨度之后的空跨度。",
        "translate": ""
    },
    {
        "source": "Of particular interest to collections is the `rev` adapter, which reverses any iterator that supports this operation.",
        "suggest": "集合特别感兴趣的是 `rev` 适配器，它反转支持此操作的任何迭代器。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into an owned [`Cow`] without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`CString`] 转换为拥有所有权的 [`Cow`]。",
        "translate": ""
    },
    {
        "source": "Converts a [`CStr`] into a borrowed [`Cow`] without copying or allocating.",
        "suggest": "将 [`CStr`] 转换为借用的 [`Cow`]，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts a `&`[`CString`] into a borrowed [`Cow`] without copying or allocating.",
        "suggest": "将 `&`[`CString`] 转换为借用的 [`Cow`]，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "This method is primarily used to interface with the [`format_args!()`] macro, and it is rare that this should explicitly be called.",
        "suggest": "此方法主要用于与 [`format_args!()`] 宏接口，很少需要显式调用。",
        "translate": ""
    },
    {
        "source": "breaks from inner loop, lets outer loop continue.",
        "suggest": "从内循环中断，让外循环继续。",
        "translate": ""
    },
    {
        "source": "Compile-time constants, compile-time evaluable functions, and raw pointers.",
        "suggest": "编译时常量、编译时可评估函数和裸指针。",
        "translate": ""
    },
    {
        "source": "On certain platforms right now the \"main modules\" modules that are documented don't compile (missing things in `libc` which is empty), so just omit them with an empty module and add the \"unstable\" attribute.",
        "suggest": "现在在某些平台上，已记录的 \"main modules\" 模块无法编译 (`libc` 中缺少空的内容)，因此只需使用空模块省略它们并添加 \"unstable\" 属性即可。",
        "translate": ""
    },
    {
        "source": "linux, wasi and windows are handled a bit differently.",
        "suggest": "linux、wasi 和 windows 的处理方式略有不同。",
        "translate": ""
    },
    {
        "source": "Creates a new symlink to a non-directory file on the filesystem.",
        "suggest": "创建指向文件系统上非目录文件的新符号链接。",
        "translate": ""
    },
    {
        "source": "The `original` path should not be a directory or a symlink to a directory, otherwise the symlink will be broken.",
        "suggest": "`original` 路径不应是目录或指向目录的符号链接，否则符号链接将被破坏。",
        "translate": ""
    },
    {
        "source": "Use [`symlink_dir`] for directories.",
        "suggest": "对目录使用 [`symlink_dir`]。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to [`CreateSymbolicLinkW`][CreateSymbolicLinkW].",
        "suggest": "该函数目前对应 [`CreateSymbolicLinkW`][CreateSymbolicLinkW]。",
        "translate": ""
    },
    {
        "source": "Note that this [may change in the future][changes].",
        "suggest": "注意这个 [将来可能会发生变化][changes]。",
        "translate": ""
    },
    {
        "source": "Creates a new symlink to a directory on the filesystem.",
        "suggest": "创建一个指向文件系统目录的新符号链接。",
        "translate": ""
    },
    {
        "source": "The `original` path must be a directory or a symlink to a directory, otherwise the symlink will be broken.",
        "suggest": "`original` 路径必须是目录或指向目录的符号链接，否则符号链接将被破坏。",
        "translate": ""
    },
    {
        "source": "Use [`symlink_file`] for other files.",
        "suggest": "对其他文件使用 [`symlink_file`]。",
        "translate": ""
    },
    {
        "source": "Use `panic_str` instead of `panic_display::<&str>` for non_fmt_panic lint.",
        "suggest": "对于 non_fmt_panic lint，使用 `panic_str` 而不是 `panic_display::<&str>`。",
        "translate": ""
    },
    {
        "source": "Special-case the single-argument case for const_panic.",
        "suggest": "特殊情况下 const_panic 的单个参数情况。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`TcpListener::into_incoming`] method.",
        "suggest": "这个 `struct` 是由 [`TcpListener::into_incoming`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Turn this into an iterator over the connections being received on this listener.",
        "suggest": "在此侦听器上接收到的连接上将其转换为迭代器。",
        "translate": ""
    },
    {
        "source": "Change the owner and group of the specified path.",
        "suggest": "更改指定路径的所有者和组。",
        "translate": ""
    },
    {
        "source": "Specifying either the uid or gid as `None` will leave it unchanged.",
        "suggest": "将 uid 或 gid 指定为 `None` 将保持不变。",
        "translate": ""
    },
    {
        "source": "Changing the owner typically requires privileges, such as root or a specific capability.",
        "suggest": "更改所有者通常需要特权，例如 root 或特定功能。",
        "translate": ""
    },
    {
        "source": "Changing the group typically requires either being the owner and a member of the group, or having privileges.",
        "suggest": "更改组通常需要成为组的所有者和成员，或者具有特权。",
        "translate": ""
    },
    {
        "source": "If called on a symbolic link, this will change the owner and group of the link target.",
        "suggest": "如果在符号链接上调用，这将更改链接目标的所有者和组。",
        "translate": ""
    },
    {
        "source": "To change the owner and group of the link itself, see [`lchown`].",
        "suggest": "要更改链接本身的所有者和组，请参见 [`lchown`]。",
        "translate": ""
    },
    {
        "source": "Change the owner and group of the file referenced by the specified open file descriptor.",
        "suggest": "更改指定打开文件描述符引用的文件的所有者和组。",
        "translate": ""
    },
    {
        "source": "For semantics and required privileges, see [`chown`].",
        "suggest": "有关语义和所需权限，请参见 [`chown`]。",
        "translate": ""
    },
    {
        "source": "Change the owner and group of the specified path, without dereferencing symbolic links.",
        "suggest": "更改指定路径的所有者和组，无需解引用符号链接。",
        "translate": ""
    },
    {
        "source": "Identical to [`chown`], except that if called on a symbolic link, this will change the owner and group of the link itself rather than the owner and group of the link target.",
        "suggest": "与 [`chown`] 相同，除了如果在符号链接上调用，这将更改链接本身的所有者和组，而不是链接目标的所有者和组。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing four `poly64x1_t` vectors.",
        "suggest": "包含四个 `poly64x1_t` vectors 的 ARM 特定类型。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing four `poly64x2_t` vectors.",
        "suggest": "包含四个 `poly64x2_t` vectors 的 ARM 特定类型。",
        "translate": ""
    },
    {
        "source": "A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an *O*(*n* * log(*n*)) in-place heapsort.",
        "suggest": "二元堆也可以就地转换为已排序的 vector，允许它用于 *O*(*n* * log(*n*)) 就地堆排序。",
        "translate": ""
    },
    {
        "source": "It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the [`Ord`] trait, changes while it is in the heap.",
        "suggest": "项的修改方式是一个逻辑错误，即项相对于任何其他项的排序 (由 [`Ord`] trait 确定) 在它在堆中时发生变化。",
        "translate": ""
    },
    {
        "source": "Either [`core::cmp::Reverse`] or a custom [`Ord`] implementation can be used to make `BinaryHeap` a min-heap.",
        "suggest": "[`core::cmp::Reverse`] 或自定义 [`Ord`] 实现可用于使 `BinaryHeap` 成为最小堆。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`BinaryHeap::into_iter()`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 由 [`BinaryHeap::into_iter()`] 创建 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`BTreeMap`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 是通过 [`BTreeMap`] 上的 [`into_iter`] 方法创建的 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`BTreeSet`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 是通过 [`BTreeSet`] 上的 [`into_iter`] 方法创建的 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`LinkedList`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 是通过 [`LinkedList`] 上的 [`into_iter`] 方法创建的 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`VecDeque`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 是通过 [`VecDeque`] 上的 [`into_iter`] 方法创建的 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "Additionally, the return value of this function is [`fmt::Result`] which is a type alias of <code>[Result]<(), [std::fmt::Error]></code>.",
        "suggest": "此外，该函数的返回值是 [`fmt::Result`]，它是 <code>[Result]<(), [std::fmt::Error]></code> 的类型别名。",
        "translate": ""
    },
    {
        "source": "Result \"fmt::Result\"",
        "suggest": "结果 \"fmt::Result\"",
        "translate": ""
    },
    {
        "source": "Error \"fmt::Error\"",
        "suggest": "错误 \"fmt::Error\"",
        "translate": ""
    },
    {
        "source": "Arguments \"fmt::Arguments\"",
        "suggest": "参数 \"fmt::Arguments\"",
        "translate": ""
    },
    {
        "source": "To avoid a memory leak the pointer must be converted back to an `Rc` using [`Rc::from_raw`].",
        "suggest": "为避免内存泄漏，必须使用 [`Rc::from_raw`] 将指针转换回 `Rc`。",
        "translate": ""
    },
    {
        "source": "See [`mem::transmute`] for more information on what restrictions apply in this case.",
        "suggest": "有关在这种情况下适用哪些限制的更多信息，请参见 [`mem::transmute`]。",
        "translate": ""
    },
    {
        "source": "The allocation is accessed by calling [`upgrade`] on the `Weak` pointer, which returns an <code>[Option]<[Rc]\\<T>></code>.",
        "suggest": "通过在 `Weak` 指针上调用 [`upgrade`] 来访问分配，它返回一个 <code>[Option]<[Rc]\\<T>></code>。",
        "translate": ""
    },
    {
        "source": "You can create a `String` from [a literal string][`&str`] with [`String::from`]:",
        "suggest": "您可以使用 [`String::from`] 从一个 [字面量字符串][`&str`] 创建一个 `String`:",
        "translate": ""
    },
    {
        "source": "implements <code>[Deref]<Target = [str]></code>, and so inherits all of [`str`]'s methods.",
        "suggest": "实现 <code>[Deref]<Target = [str]></code>，因此继承了 [`str`] 的所有方法。",
        "translate": ""
    },
    {
        "source": "In this case we are dereferencing a `String` to a [`str`], then referencing the [`str`] back to [`&str`].",
        "suggest": "在这种情况下，我们将 `String` 解引用到 [`str`]，然后将 [`str`] 引用回 [`&str`]。",
        "translate": ""
    },
    {
        "source": "Converts this `String` into a <code>[Box]<[str]></code>.",
        "suggest": "将此 `String` 转换为 <code>[Box]<[str]></code>。",
        "translate": ""
    },
    {
        "source": "Consider <code>Arc<[RefCell\\<T>]></code>.",
        "suggest": "考虑 <code>Arc<[RefCell\\<T>]></code>。",
        "translate": ""
    },
    {
        "source": "isn't [`Sync`], and if `Arc<T>` was always [`Send`], <code>Arc<[RefCell\\<T>]></code> would be as well.",
        "suggest": "不是 [`Sync`]，如果 `Arc<T>` 总是 [`Send`]，则 <code>Arc<[RefCell\\<T>]></code> 也是。",
        "translate": ""
    },
    {
        "source": "The allocation is accessed by calling [`upgrade`] on the `Weak` pointer, which returns an <code>[Option]<[Arc]\\<T>></code>.",
        "suggest": "通过在 `Weak` 指针上调用 [`upgrade`] 来访问分配，它返回一个 <code>[Option]<[Arc]\\<T>></code>。",
        "translate": ""
    },
    {
        "source": "Vectors have *O*(1) indexing, amortized *O*(1) push (to the end) and *O*(1) pop (from the end).",
        "suggest": "Vectors 有 *O*(1) 索引，摊销 *O*(1) push (到最后) 和 *O*(1) pop (从最后)。",
        "translate": ""
    },
    {
        "source": "will allocate if and only if <code>[mem::size_of::\\<T>]\\() * [capacity]\\() > 0</code>.",
        "suggest": "仅当 <code>[mem::size_of::\\<T>]\\() * [capacity]\\() > 0</code> 时，才会分配。",
        "translate": ""
    },
    {
        "source": "In general, `Vec`'s allocation details are very subtle --- if you intend to allocate memory using a `Vec` and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using `from_raw_parts` to recover the `Vec` and then dropping it.",
        "suggest": "一般来说，`Vec` 的分配细节非常微妙 -- 如果您打算使用 `Vec` 分配内存并将其用于其他用途 (或者传递给不安全的代码，或者构建您自己的内存支持集合)，请务必使用 `from_raw_parts` 处理此内存以恢复 `Vec`，然后丢弃它来释放此内存。",
        "translate": ""
    },
    {
        "source": "If a `Vec` *has* allocated memory, then the memory it points to is on the heap (as defined by the allocator Rust is configured to use by default), and its pointer points to [`len`] initialized, contiguous elements in order (what you would see if you coerced it to a slice), followed by <code>[capacity] - [len]</code> logically uninitialized, contiguous elements.",
        "suggest": "如果一个 `Vec` 已分配了内存，那么它指向的内存在堆上（由分配器定义，Rust 被配置为默认使用），它的指针按顺序指向 [`len`] 个已初始化的连续元素（如果将其强制转换为切片，您会看到什么），然后是 <code>[capacity] - [len]</code> 逻辑上未初始化的连续元素。",
        "translate": ""
    },
    {
        "source": "[`push`] and [`insert`] *will* (re)allocate if <code>[len] == [capacity]</code>. That is, the reported capacity is completely accurate, and can be relied on.",
        "suggest": "[`push`] 和 [`insert`] 将在 <code>[len] == [capacity]</code> 时(重新)分配。也就是说，报告的容量是完全准确的，并且是可以依赖的。",
        "translate": ""
    },
    {
        "source": "If <code>[len] == [capacity]</code>, (as is the case for the [`vec!`] macro), then a `Vec<T>` can be converted to and from a [`Box<[T]>`][owned slice] without reallocating or moving the elements.",
        "suggest": "如果 <code>[len] == [capacity]</code>，(如 [`vec!`] 宏的情况)，则 `Vec<T>` 可以与 [`Box<[T]>`][owned slice] 相互转换，而无需重新分配或移动元素。",
        "translate": ""
    },
    {
        "source": "This struct represents the unsafety of constructing an `Arguments`.",
        "suggest": "这个结构体代表了构建 `Arguments` 的不安全性。",
        "translate": ""
    },
    {
        "source": "It exists, rather than an unsafe function, in order to simplify the expansion of `format_args!(..)` and reduce the scope of the `unsafe` block.",
        "suggest": "它的存在，而不是一个不安全的函数，是为了简化 `format_args!(..)` 的扩展，并缩小 `unsafe` 块的作用域。",
        "translate": ""
    },
    {
        "source": "See documentation where `UnsafeArg` is required to know when it is safe to create and use `UnsafeArg`.",
        "suggest": "请参见 `UnsafeArg` 的文档，需要知道何时可以安全地创建和使用 `UnsafeArg`。",
        "translate": ""
    },
    {
        "source": "An `UnsafeArg` is required because the following invariants must be held in order for this function to be safe:",
        "suggest": "`UnsafeArg` 是必需的，因为必须保持以下不可变变量才能使此函数安全:",
        "translate": ""
    },
    {
        "source": "The `pieces` slice must be at least as long as `fmt`.",
        "suggest": "`pieces` 必须至少与 `fmt` 一样长。",
        "translate": ""
    },
    {
        "source": "Every [`rt::v1::Argument::position`] value within `fmt` must be a valid index of `args`.",
        "suggest": "`fmt` 中的每个 [`rt::v1::Argument::position`] 值都必须是 `args` 的有效索引。",
        "translate": ""
    },
    {
        "source": "Every [`Count::Param`] within `fmt` must contain a valid index of `args`.",
        "suggest": "`fmt` 中的每个 [`Count::Param`] 都必须包含一个有效的 `args` 索引。",
        "translate": ""
    },
    {
        "source": "An iterator has a method, [`next`], which when called, returns an <code>[Option]\\<Item></code>.",
        "suggest": "迭代器有一个方法 [`next`]，当调用它时，返回一个 <code>[Option]\\<Item></code>.",
        "translate": ""
    },
    {
        "source": "Calling [`next`] will return [`Some(Item)`] as long as there are elements, and once they've all been exhausted, will return `None` to indicate that iteration is finished.",
        "suggest": "只要有元素，调用 [`next`] 就会返回 [`Some(Item)`]，一旦它们全部消费完，将返回 `None` 表示迭代完成。",
        "translate": ""
    },
    {
        "source": "The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.",
        "suggest": "返回的元组的后半部分是 <code>[Option]<[usize]></code>。",
        "translate": ""
    },
    {
        "source": "The default implementation returns <code>(0, [None])</code> which is correct for any iterator.",
        "suggest": "默认实现返回 <code>(0, [None])</code> 这对于任何迭代器都是正确的。",
        "translate": ""
    },
    {
        "source": "Time complexity: *O*(*n*)",
        "suggest": "时间复杂度: *O*(*n*)",
        "translate": ""
    },
    {
        "source": "Avoid inlining the initialization closure into the common path that fetches the already initialized value",
        "suggest": "避免将初始化闭包内联到获取已初始化值的公共路径中",
        "translate": ""
    },
    {
        "source": "Instead, Rust has *optional* pointers, like the optional owned box, <code>[Option]<[Box\\<T>]></code>.",
        "suggest": "相反，Rust 有 *optional* 指针，就像可选的拥有所有权的 box，<code>[Option]<[Box\\<T>]></code>。",
        "translate": ""
    },
    {
        "source": "converts from <code>[&][][Option]\\<T></code> to <code>[Option]<[&]T></code>",
        "suggest": "转换自 <code>[&][][Option]\\<T></code> to <code>[Option]<[&]T></code>",
        "translate": ""
    },
    {
        "source": "converts from <code>[&mut] [Option]\\<T></code> to <code>[Option]<[&mut] T></code>",
        "suggest": "转换自 <code>[&mut] [Option]\\<T></code> to <code>[Option]<[&mut] T></code>",
        "translate": ""
    },
    {
        "source": "converts from <code>[&][][Option]\\<T></code> to <code>[Option]<[&]T::[Target]></code>",
        "suggest": "转换自 <code>[&][][Option]\\<T></code> to <code>[Option]<[&]T::[Target]></code>",
        "translate": ""
    },
    {
        "source": "converts from <code>[&mut] [Option]\\<T></code> to <code>[Option]<[&mut] T::[Target]></code>",
        "suggest": "转换自 <code>[&mut] [Option]\\<T></code> to <code>[Option]<[&mut] T::[Target]></code>",
        "translate": ""
    },
    {
        "source": "converts from <code>[Pin]<[&][][Option]\\<T>></code> to <code>[Option]<[Pin]<[&]T>></code>",
        "suggest": "转换自 <code>[Pin]<[&][][Option]\\<T>></code> to <code>[Option]<[Pin]<[&]T>></code>",
        "translate": ""
    },
    {
        "source": "converts from <code>[Pin]<[&mut] [Option]\\<T>></code> to <code>[Option]<[Pin]<[&mut] T>></code>",
        "suggest": "从 <code>[Pin]<[&mut] [Option]\\<T>></code> to <code>[Option]<[Pin]<[&mut] T>></code>",
        "translate": ""
    },
    {
        "source": "reference \"shared reference\"",
        "suggest": "参考 \"共享引用\"",
        "translate": ""
    },
    {
        "source": "reference \"mutable reference\"",
        "suggest": "参考 \"可变引用\"",
        "translate": ""
    },
    {
        "source": "Converts an <code>Option<[String]></code> into an <code>Option<[usize]></code>, preserving the original.",
        "suggest": "将 <code>Option<[String]></code> 转换为 <code>Option<[usize]></code>，保留原始值。",
        "translate": ""
    },
    {
        "source": "Converts from <code>[Pin]<[&]Option\\<T>></code> to <code>Option<[Pin]<[&]T>></code>.",
        "suggest": "从 <code>[Pin]<[&]Option\\<T>></code> 到 <code>Option<[Pin]<[&]T>></code>。",
        "translate": ""
    },
    {
        "source": "Converts from <code>[Pin]<[&mut] Option\\<T>></code> to <code>Option<[Pin]<[&mut] T>></code>.",
        "suggest": "转换自 <code>[Pin]<[&mut] Option\\<T>></code> 到 <code>Option<[Pin]<[&mut] T>></code>。",
        "translate": ""
    },
    {
        "source": "Converts an <code>Option<[String]></code> into an <code>Option<[usize]></code>, consuming the original:",
        "suggest": "将 <code>Option<[String]></code> 转换为 <code>Option<[usize]></code>，使用原始值:",
        "translate": ""
    },
    {
        "source": "will be mapped to <code>[Ok]\\([None])</code>.",
        "suggest": "将被映射到 <code>[Ok]\\([None])</code>。",
        "translate": ""
    },
    {
        "source": "<code>[Some]\\([Ok]\\(\\_))</code> and <code>[Some]\\([Err]\\(\\_))</code> will be mapped to <code>[Ok]\\([Some]\\(\\_))</code> and <code>[Err]\\(\\_)</code>.",
        "suggest": "<code>[Some]\\([Ok]\\(\\_))</code> 和 <code>[Some]\\([Err]\\(\\_))</code> 将映射到 <code>[Ok]\\([Some]\\(\\_))</code> 和 <code>[Err]\\(\\_)</code>。",
        "translate": ""
    },
    {
        "source": "Converts an <code>[Option]<[String]></code> into an <code>[Option]<[usize]></code>, preserving the original.",
        "suggest": "将 <code>[Option]<[String]></code> 转换为 <code>[Option]<[usize]></code>，保留原始值。",
        "translate": ""
    },
    {
        "source": "The [`map`] method takes the `self` argument by value, consuming the original, so this technique uses `from` to first take an [`Option`] to a reference to the value inside the original.",
        "suggest": "[`map`] 方法按值取 `self` 参数，消耗原始值，因此该技术使用 `from` 首先将 [`Option`] 用于对原始值内部值的引用。",
        "translate": ""
    },
    {
        "source": "The actual definition of [`Write`] uses [`io::Result`], which is just a synonym for <code>[Result]<T, [io::Error]></code>.",
        "suggest": "[`Write`] 的实际定义使用了 [`io::Result`]，它只是 <code>[Result]<T, [io::Error]></code> 的同义词。",
        "translate": ""
    },
    {
        "source": "The default implementation returns <code>(0, [None])</code> which is correct for any stream.",
        "suggest": "默认实现返回了 <code>(0, [None])</code>，这对于任何流都是正确的。",
        "translate": ""
    },
    {
        "source": "Converts a <code>Poll<[String]></code> into a <code>Poll<[usize]></code>, consuming the original:",
        "suggest": "将 <code>Poll<[String]></code> 转换为 <code>Poll<[usize]></code>，消耗原始值:",
        "translate": ""
    },
    {
        "source": "A prefix and postfix may be added.",
        "suggest": "可以添加前缀和后缀。",
        "translate": ""
    },
    {
        "source": "The whole thing is padded to the formatter's `width`, if specified.",
        "suggest": "如果指定，整个内容都填充到格式化程序的 `width` 中。",
        "translate": ""
    },
    {
        "source": "This closure emits the formatted duration without emitting any padding (padding is calculated below).",
        "suggest": "这个闭包发出格式化的持续时间而不发出任何填充 (填充计算如下)。",
        "translate": ""
    },
    {
        "source": "Write the decimal point and the fractional part (if any).",
        "suggest": "写出小数点和小数部分 (如果有)。",
        "translate": ""
    },
    {
        "source": "No `width` specified.",
        "suggest": "未指定 `width`。",
        "translate": ""
    },
    {
        "source": "There's no need to calculate the length of the output in this case, just emit it.",
        "suggest": "在这种情况下，不需要计算输出的长度，只需发出它。",
        "translate": ""
    },
    {
        "source": "A `width` was specified.",
        "suggest": "指定了 `width`。",
        "translate": ""
    },
    {
        "source": "Calculate the actual width of the output in order to calculate the required padding.",
        "suggest": "计算输出的实际宽度，以便计算所需的填充。",
        "translate": ""
    },
    {
        "source": "It consists of 4 parts:",
        "suggest": "它由 4 个部分组成:",
        "translate": ""
    },
    {
        "source": "The prefix: is either \"+\" or \"\", so we can just use len().",
        "suggest": "前缀: 是 \"+\" 或 \"\"，所以我们可以只使用 len()。",
        "translate": ""
    },
    {
        "source": "The postfix: can be \"µs\" so we have to count UTF8 characters.",
        "suggest": "后缀: 可以是 \"µs\" 所以我们必须计算 UTF8 字符。",
        "translate": ""
    },
    {
        "source": "The integer part:",
        "suggest": "整数部分:",
        "translate": ""
    },
    {
        "source": "integer_part is > 0, so has length log10(x)+1",
        "suggest": "integer_part 是 > 0 的，所以长度是 log10(x)+1",
        "translate": ""
    },
    {
        "source": "integer_part is 0, so has length 1.",
        "suggest": "integer_part 为 0，因此长度为 1。",
        "translate": ""
    },
    {
        "source": "The fractional part (if any):",
        "suggest": "小数部分 (如果有) :",
        "translate": ""
    },
    {
        "source": "Output is already longer than `width`, so don't pad.",
        "suggest": "输出已经比 `width` 长，所以不要填充。",
        "translate": ""
    },
    {
        "source": "We need to add padding.",
        "suggest": "我们需要添加填充。",
        "translate": ""
    },
    {
        "source": "Use the `Formatter::padding` helper function.",
        "suggest": "使用 `Formatter::padding` 帮助函数。",
        "translate": ""
    },
    {
        "source": "default alignment is left:",
        "suggest": "默认对齐方式为左对齐:",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`HashMap`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 是通过 [`HashMap`] 上的 [`into_iter`] 方法创建的 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`HashSet`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 是通过 [`HashSet`] 上的 [`into_iter`] 方法创建的 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "automatically calls `into_iter`, and takes any <code>T: [IntoIterator]</code>.",
        "suggest": "自动调用 `into_iter`，并接受任何 <code>T: [IntoIterator]</code>。",
        "translate": ""
    },
    {
        "source": "is to <code>&[CStr]</code> as [`String`] is to <code>&[str]</code>: the former in each pair are owned strings;",
        "suggest": "对 <code>&[CStr]</code> 就像 [`String`] 对 <code>&[str]</code> 一样: 每对中的前者是拥有所有权的字符串;",
        "translate": ""
    },
    {
        "source": "A `CString` is created from either a byte slice or a byte vector, or anything that implements <code>[Into]<[Vec]<[u8]>></code> (for example, you can build a `CString` straight out of a [`String`] or a <code>&[str]</code>, since both implement that trait).",
        "suggest": "`CString` 是从字节切片、字节 vector 或任何实现 <code>[Into]<[Vec]<[u8]>></code> 创建的 (例如，您可以直接从 [`String`] 或 <code>&[str]</code>，因为两者都实现了该 trait)。",
        "translate": ""
    },
    {
        "source": "The [`CString::new`] method will actually check that the provided <code>&[[u8]]</code> does not have 0 bytes in the middle, and return an error if it finds one.",
        "suggest": "[`CString::new`] 方法实际上会检查提供的 <code>&[[u8]]</code> 中是否没有 0 个字节，如果找到一个，将返回一个错误。",
        "translate": ""
    },
    {
        "source": "Alternatively, you can obtain a <code>&[[u8]]</code> slice from a `CString` with the [`CString::as_bytes`] method.",
        "suggest": "或者，您可以使用 [`CString::as_bytes`] 方法从 `CString` 获取 <code>&[[u8]]</code> 切片。",
        "translate": ""
    },
    {
        "source": "If you need a <code>&[[u8]]</code> slice *with* the nul terminator, you can use [`CString::as_bytes_with_nul`] instead.",
        "suggest": "如果您需要一个带 nul 终止符的 <code>&[[u8]]</code> 切片，您可以使用 [`CString::as_bytes_with_nul`] 代替。",
        "translate": ""
    },
    {
        "source": "It can be constructed safely from a <code>&[[u8]]</code> slice, or unsafely from a raw `*const c_char`.",
        "suggest": "它可以从一个 <code>&[[u8]]</code> 切片安全地构建，或者从原始 `*const c_char` 不安全地构建。",
        "translate": ""
    },
    {
        "source": "It can then be converted to a Rust <code>&[str]</code> by performing UTF-8 validation, or into an owned [`CString`].",
        "suggest": "然后可以通过执行 UTF-8 验证将其转换为 Rust <code>&[str]</code>，或转换为拥有所有权的 [`CString`]。",
        "translate": ""
    },
    {
        "source": "is to [`CString`] as <code>&[str]</code> is to [`String`]: the former in each pair are borrowed references;",
        "suggest": "对 [`CString`] 就像 <code>&[str]</code> 对 [`String`] 一样: 每对中的前者都是借用的引用;",
        "translate": ""
    },
    {
        "source": "Converts a <code>[Vec]<[u8]></code> to a [`CString`] without checking the invariants on the given [`Vec`].",
        "suggest": "将 <code>[Vec]<[u8]></code> 转换为 [`CString`]，而不检查给定的 [`Vec`] 上的不可变变量。",
        "translate": ""
    },
    {
        "source": "Attempts to converts a <code>[Vec]<[u8]></code> to a [`CString`].",
        "suggest": "尝试将 <code>[Vec]<[u8]></code> 转换为 [`CString`]。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into a <code>[Vec]<[u8]></code>.",
        "suggest": "将 [`CString`] 转换为 <code>[Vec]<[u8]></code>。",
        "translate": ""
    },
    {
        "source": "Converts a <code>[Box]<[CStr]></code> into a [`CString`] without copying or allocating.",
        "suggest": "将 <code>[Box]<[CStr]></code> 转换为 [`CString`]，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts a <code>[Vec]<[NonZeroU8]></code> into a [`CString`] without copying nor checking for inner null bytes.",
        "suggest": "将 <code>[Vec]<[NonZeroU8]></code> 转换为 [`CString`]，无需复制或检查内部空字节。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into a <code>[Box]<[CStr]></code> without copying or allocating.",
        "suggest": "将 [`CString`] 转换为 <code>[Box]<[CStr]></code>，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into an <code>[Arc]<[CStr]></code> without copying or allocating.",
        "suggest": "将 [`CString`] 转换为 <code>[Arc]<[CStr]></code>，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into an <code>[Rc]<[CStr]></code> without copying or allocating.",
        "suggest": "将 [`CString`] 转换为 <code>[Rc]<[CStr]></code>，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Yields a <code>&[str]</code> slice if the `CStr` contains valid UTF-8.",
        "suggest": "如果 `CStr` 包含有效的 UTF-8，则产生 <code>&[str]</code> 切片。",
        "translate": ""
    },
    {
        "source": "If the contents of the `CStr` are valid UTF-8 data, this function will return the corresponding <code>&[str]</code> slice.",
        "suggest": "如果 `CStr` 的内容是有效的 UTF-8 数据，该函数将返回相应的 <code>&[str]</code> 切片。",
        "translate": ""
    },
    {
        "source": "Converts a `CStr` into a <code>[Cow]<[str]></code>.",
        "suggest": "将 `CStr` 转换为 <code>[Cow]<[str]></code>。",
        "translate": ""
    },
    {
        "source": "If the contents of the `CStr` are valid UTF-8 data, this function will return a <code>[Cow]::[Borrowed]\\(&[str])</code> with the corresponding <code>&[str]</code> slice.",
        "suggest": "如果 `CStr` 的内容是有效的 UTF-8 数据，该函数将返回一个 <code>[Cow]::[Borrowed]\\(&[str])</code> 和相应的 <code>&[str]</code> 切片。",
        "translate": ""
    },
    {
        "source": "Otherwise, it will replace any invalid UTF-8 sequences with [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a <code>[Cow]::[Owned]\\(&[str])</code> with the result.",
        "suggest": "否则，它将用 [`U+FFFD 替换字符`][U+FFFD] 替换任何无效的 UTF-8 序列，并返回 <code>[Cow]::[Owned]\\(&[str])</code> 作为结果。",
        "translate": ""
    },
    {
        "source": "While in Rust accessing a string's length is an *O*(1) operation (because the length is stored);",
        "suggest": "而在 Rust 中，访问字符串的长度是一个 *O*(1) 操作 (因为长度是被存储的) ;",
        "translate": ""
    },
    {
        "source": "in C it is an *O*(*n*) operation because the length needs to be computed by scanning the string for the nul terminator.",
        "suggest": "在 C 中，它是一个 *O*(*n*) 操作，因为需要通过扫描字符串中的 nul 终止符来计算长度。",
        "translate": ""
    },
    {
        "source": "Rust code can create a [`CString`] out of a normal string (provided that the string doesn't have nul characters in the middle), and then use a variety of methods to obtain a raw <code>\\*mut [u8]</code> that can then be passed as an argument to functions which use the C conventions for strings.",
        "suggest": "Rust 代码可以从一个普通字符串中创建一个 [`CString`] (前提是该字符串中间没有 nul 字符)，然后使用多种方法获得一个原始的 <code>\\*mut [u8]</code>，然后可以作为参数传递给使用字符串的 C 约定的函数。",
        "translate": ""
    },
    {
        "source": "it is what you would use to wrap a raw <code>\\*const [u8]</code> that you got from a C function.",
        "suggest": "它是您用来包装从 C 函数获得的原始 <code>\\*const [u8]</code> 的内容。",
        "translate": ""
    },
    {
        "source": "Once you have a [`CStr`], you can convert it to a Rust <code>&[str]</code> if it's valid UTF-8, or lossily convert it by adding replacement characters.",
        "suggest": "一旦您有了 [`CStr`]，您可以将它转换为 Rust <code>&[str]</code>，如果它是有效的 UTF-8，或者通过添加替换字符来有损地转换它。",
        "translate": ""
    },
    {
        "source": "it returns an <code>[Option]<[OsString]></code>. If the environment variable exists you will get a <code>[Some]\\(os_string)</code>, which you can *then* try to convert to a Rust string.",
        "suggest": "它返回一个 <code>[Option]<[OsString]></code>。如果环境变量存在，您将得到一个 <code>[Some]\\(os_string)</code>，您可以在那时尝试将其转换为 Rust 字符串。",
        "translate": ""
    },
    {
        "source": "On Unix, [`OsStr`] implements the <code>std::os::unix::ffi::[OsStrExt][unix.OsStrExt]</code> trait, which augments it with two methods, [`from_bytes`] and [`as_bytes`].",
        "suggest": "在 Unix 上，[`OsStr`] 实现了 <code>std::os::unix::ffi::[OsStrExt][unix.OsStrExt]</code> trait，它增加了两个方法，[`from_bytes`] 和 [`as_bytes`]。",
        "translate": ""
    },
    {
        "source": "Additionally, on Unix [`OsString`] implements the <code>std::os::unix::ffi::[OsStringExt][unix.OsStringExt]</code> trait, which provides [`from_vec`] and [`into_vec`] methods that consume their arguments, and take or produce vectors of [`u8`].",
        "suggest": "此外，在 Unix 上，[`OsString`] 实现了 <code>std::os::unix::ffi::[OsStringExt][unix.OsStringExt]</code> trait，它提供了 [`from_vec`] 和 [`into_vec`] 方法，这些方法使用它们的参数，并获取或生成 [`u8`] 的 vectors。",
        "translate": ""
    },
    {
        "source": "On Windows, [`OsStr`] implements the <code>std::os::windows::ffi::[OsStrExt][windows.OsStrExt]</code> trait, which provides an [`encode_wide`] method.",
        "suggest": "在 Windows 上，[`OsStr`] 实现了 <code>std::os::windows::ffi::[OsStrExt][windows.OsStrExt]</code> trait，它提供了一个 [`encode_wide`] 方法。",
        "translate": ""
    },
    {
        "source": "Additionally, on Windows [`OsString`] implements the <code>std::os::windows:ffi::[OsStringExt][windows.OsStringExt]</code> trait, which provides a [`from_wide`] method.",
        "suggest": "此外，在 Windows 上 [`OsString`] 实现了 <code>std::os::windows:ffi::[OsStringExt][windows.OsStringExt]</code> trait，它提供了一个 [`from_wide`] 方法。",
        "translate": ""
    },
    {
        "source": "is to <code>&[OsStr]</code> as [`String`] is to <code>&[str]</code>: the former in each pair are owned strings;",
        "suggest": "对 <code>&[OsStr]</code> 就像 [`String`] 对 <code>&[str]</code> 一样: 每对中的前者是拥有所有权的字符串;",
        "translate": ""
    },
    {
        "source": "**From a Rust string**: `OsString` implements <code>[From]<[String]></code>, so you can use <code>my_string.[into]\\()</code> to create an `OsString` from a normal Rust string.",
        "suggest": "**来自 Rust 字符串**: `OsString` 实现了 <code>[From]<[String]></code>，因此您可以使用 <code>my_string.[into]\\()</code> 从普通 Rust 字符串创建 `OsString`。",
        "translate": ""
    },
    {
        "source": "**From slices:** Just like you can start with an empty Rust [`String`] and then [`String::push_str`] some <code>&[str]</code> sub-string slices into it, you can create an empty `OsString` with the [`OsString::new`] method and then push string slices into it with the [`OsString::push`] method.",
        "suggest": "**从切片: **就像您可以从一个空的 Rust [`String`] 开始，然后用 [`String::push_str`] 将一些 <code>&[str]</code> 子字符串切片放入其中一样，您也可以使用 [`OsString::new`] 方法创建一个空的 `OsString`，然后使用 [`OsString::push`] 方法将字符串切片推入其中。",
        "translate": ""
    },
    {
        "source": "You can use the [`OsString::as_os_str`] method to get an <code>&[OsStr]</code> from an `OsString`;",
        "suggest": "您可以使用 [`OsString::as_os_str`] 方法从 `OsString` 获取 <code>&[OsStr]</code> ;",
        "translate": ""
    },
    {
        "source": "is to [`OsString`] as <code>&[str]</code> is to [`String`]: the former in each pair are borrowed references;",
        "suggest": "对 [`OsString`] 就像 <code>&[str]</code> 对 [`String`] 一样: 每对中的前者都是借用的引用;",
        "translate": ""
    },
    {
        "source": "Extends the string with the given <code>&[OsStr]</code> slice.",
        "suggest": "用给定的 <code>&[OsStr]</code> 切片扩展字符串。",
        "translate": ""
    },
    {
        "source": "Yields a <code>&[str]</code> slice if the `OsStr` is valid Unicode.",
        "suggest": "如果 `OsStr` 是有效的 Unicode，则产生 <code>&[str]</code>。",
        "translate": ""
    },
    {
        "source": "Converts an `OsStr` to a <code>[Cow]<[str]></code>.",
        "suggest": "将 `OsStr` 转换为 <code>[Cow]<[str]></code>。",
        "translate": ""
    },
    {
        "source": "Converts a <code>[Box]<[OsStr]></code> into an [`OsString`] without copying or allocating.",
        "suggest": "将 <code>[Box]<[OsStr]></code> 转换为 [`OsString`]，而无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts an [`OsString`] into a <code>[Box]<[OsStr]></code> without copying or allocating.",
        "suggest": "将 [`OsString`] 转换为 <code>[Box]<[OsStr]></code>，而无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts an [`OsString`] into an <code>[Arc]<[OsStr]></code> without copying or allocating.",
        "suggest": "将 [`OsString`] 转换为 <code>[Arc]<[OsStr]></code>，而无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts an [`OsString`] into an <code>[Rc]<[OsStr]></code> without copying or allocating.",
        "suggest": "将 [`OsString`] 转换为 <code>[Rc]<[OsStr]></code>，而无需复制或分配。",
        "translate": ""
    },
    {
        "source": "This iterator is returned from the [`read_dir`] function of this module and will yield instances of <code>[io::Result]<[DirEntry]></code>.",
        "suggest": "该迭代器从该模块的 [`read_dir`] 函数返回，将产生一个 <code>[io::Result]<[DirEntry]></code> 实例。",
        "translate": ""
    },
    {
        "source": "So, before writing, save the current position (using <code>[seek]\\([SeekFrom]::[Current]\\(0))</code>), and restore it before the next read.",
        "suggest": "所以，在写入之前，保存当前位置 (使用 <code>[seek]\\([SeekFrom]::[Current]\\(0))</code>)，并在下次读取之前恢复它。",
        "translate": ""
    },
    {
        "source": "The iterator will yield instances of <code>[io::Result]<[DirEntry]></code>.",
        "suggest": "迭代器将产生 <code>[io::Result]<[DirEntry]></code> 实例。",
        "translate": ""
    },
    {
        "source": "It also provides no advantage when reading from a source that is already in memory, like a <code>[Vec]\\<u8></code>.",
        "suggest": "从已经在内存中的源读取时，它也没有任何优势，例如 <code>[Vec]\\<u8></code>.",
        "translate": ""
    },
    {
        "source": "The position used for seeking with <code>[SeekFrom::Current]\\(_)</code> is the position the underlying reader would be at if the `BufReader<R>` had no internal buffer.",
        "suggest": "用于使用 <code>[SeekFrom::Current]\\(_)</code> 查找的位置是底层 reader 所在的位置，如果 `BufReader<R>` 没有内部缓冲区。",
        "translate": ""
    },
    {
        "source": "In the edge case where you're seeking with <code>[SeekFrom::Current]\\(n)</code> where `n` minus the internal buffer length overflows an `i64`, two seeks will be performed instead of one.",
        "suggest": "在 edge 情况下，您使用 <code>[SeekFrom::Current]\\(n)</code> 进行查找，其中 `n` 减去内部缓冲区长度会溢出 `i64`，将执行两次查找而不是一次查找。",
        "translate": ""
    },
    {
        "source": "If the second seek returns [`Err`], the underlying reader will be left at the same position it would have if you called `seek` with <code>[SeekFrom::Current]\\(0)</code>.",
        "suggest": "如果第二个 seek 返回 [`Err`]，则底层 reader 将保留在与使用 <code>[SeekFrom::Current]\\(0)</code> 调用 `seek` 时相同的位置。",
        "translate": ""
    },
    {
        "source": "It also provides no advantage when writing to a destination that is in memory, like a <code>[Vec]\\<u8></code>.",
        "suggest": "在写入内存中的目标时，它也没有提供任何优势，例如 <code>[Vec]\\<u8></code>.",
        "translate": ""
    },
    {
        "source": "`Cursor`s are used with in-memory buffers, anything implementing <code>[AsRef]<\\[u8]></code>, to allow them to implement [`Read`] and/or [`Write`], allowing these buffers to be used anywhere you might use a reader or writer that does actual I/O.",
        "suggest": "`Cursor`s 与内存缓冲区一起使用，任何实现 <code>[AsRef]<\\[u8]></code>，以允许它们实现 [`Read`] 或者 [`Write`]，从而允许这些缓冲区在您可能使用进行实际 I/O 的读取器或写入器的任何地方使用。",
        "translate": ""
    },
    {
        "source": "The standard library implements some I/O traits on various types which are commonly used as a buffer, like <code>Cursor<[Vec]\\<u8>></code> and <code>Cursor<[&\\[u8\\]][bytes]></code>.",
        "suggest": "标准库在通常用作缓冲区的各种类型上实现了一些 I/O traits，例如 <code>Cursor<[Vec]\\<u8>></code> and <code>Cursor<[&\\[u8\\]][bytes]></code>。",
        "translate": ""
    },
    {
        "source": "The returned type implements [`Iterator`] where the [`Item`] is <code>[Result]<[u8], [io::Error]></code>.",
        "suggest": "返回的类型实现 [`Iterator`]，其中 [`Item`] 是 <code>[Result]<[u8], [io::Error]></code>。",
        "translate": ""
    },
    {
        "source": "The iterator returned from this function will return instances of <code>[io::Result]<[Vec]\\<u8>></code>.",
        "suggest": "这个函数返回的迭代器将返回 <code>[io::Result]<[Vec]\\<u8>></code> 的实例。",
        "translate": ""
    },
    {
        "source": "The iterator returned from this function will yield instances of <code>[io::Result]<[String]></code>.",
        "suggest": "从这个函数返回的迭代器将产生 <code>[io::Result]<[String]></code> 的实例。",
        "translate": ""
    },
    {
        "source": "All reads from the returned reader will return <code>[Ok]\\(0)</code>.",
        "suggest": "从返回的读取器中读取的所有内容都将返回 <code>[Ok]\\(0)</code>。",
        "translate": ""
    },
    {
        "source": "<code>(&[str], [u16])</code>: <code>&[str]</code> should be either a string representation of an [`IpAddr`] address as expected by [`FromStr`] implementation or a host name.",
        "suggest": "<code>(&[str], [u16])</code>: <code>&[str]</code> 应该是 [`FromStr`] 实现所期望的 [`IpAddr`] 地址的字符串表示或主机名。",
        "translate": ""
    },
    {
        "source": "[`u16`] is the port number.",
        "suggest": "[`u16`] 是端口号。",
        "translate": ""
    },
    {
        "source": "<code>&[str]</code>: the string should be either a string representation of a [`SocketAddr`] as expected by its [`FromStr`] implementation or a string like `<host_name>:<port>` pair where `<port>` is a [`u16`] value.",
        "suggest": "<code>&[str]</code>: 该字符串应该是 [`SocketAddr`] 的字符串表示形式，正如其 [`FromStr`] 实现所期望的那样，或者是像 `<host_name>:<port>` 这样的字符串，其中 `<port>` 是一个 [`u16`] 值。",
        "translate": ""
    },
    {
        "source": "Converts this object to an iterator of resolved [`SocketAddr`]s.",
        "suggest": "将此对象转换为已解析的 [`SocketAddr`] 的迭代器。",
        "translate": ""
    },
    {
        "source": "All currently blocked and future [reads] will return <code>[Ok]\\(0)</code>.",
        "suggest": "所有当前被阻止的和未来的 [reads] 将返回 <code>[Ok]\\(0)</code>。",
        "translate": ""
    },
    {
        "source": "Linux-specific extensions to primitives in the [`std::fs`] module.",
        "suggest": "[`std::fs`] 模块中原语的 Linux 特定扩展。",
        "translate": ""
    },
    {
        "source": "Linux-specific extensions to primitives in the [`std::process`] module.",
        "suggest": "[`std::process`] 模块中原语的 Linux 特定扩展。",
        "translate": ""
    },
    {
        "source": "On modern architectures this type will always be either [`i8`] or [`u8`], as they use byte-addresses memory with 8-bit bytes.",
        "suggest": "在现代体系结构中，这种类型将始终是 [`i8`] 或 [`u8`]，因为它们使用具有 8 位字节的字节地址内存。",
        "translate": ""
    },
    {
        "source": "Unix-specific extensions to primitives in the [`std::ffi`] module.",
        "suggest": "[`std::ffi`] 模块中原语的 Unix 特定扩展。",
        "translate": ""
    },
    {
        "source": "Unix-specific extensions to primitives in the [`std::fs`] module.",
        "suggest": "[`std::fs`] 模块中原语的 Unix 特定扩展。",
        "translate": ""
    },
    {
        "source": "It exposes more ways to deal with platform-specific strings ([`OsStr`], [`OsString`]), allows to set permissions more granularly, extract low-level file descriptors from files and sockets, and has platform-specific helpers for spawning processes.",
        "suggest": "它公开了更多处理特定平台字符串的方法 ([`OsStr`]，[`OsString`])，允许更精细地设置权限，从文件和套接字中提取低级文件描述符，并具有特定于平台的帮助程序来生成进程。",
        "translate": ""
    },
    {
        "source": "Unix-specific networking functionality.",
        "suggest": "Unix 特定的网络功能。",
        "translate": ""
    },
    {
        "source": "Unix-specific extensions to primitives in the [`std::process`] module.",
        "suggest": "[`std::process`] 模块中原语的 Unix 特定扩展。",
        "translate": ""
    },
    {
        "source": "Unix-specific extensions to primitives in the [`std::thread`] module.",
        "suggest": "[`std::thread`] 模块中原语的 Unix 特定扩展。",
        "translate": ""
    },
    {
        "source": "WASI-specific extensions to primitives in the [`std::ffi`] module",
        "suggest": "[`std::ffi`] 模块中原语的 WASI 特定扩展",
        "translate": ""
    },
    {
        "source": "WASI-specific extensions to primitives in the [`std::fs`] module.",
        "suggest": "[`std::fs`] 模块中原语的 WASI 特定扩展。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to primitives in the [`std::ffi`] module.",
        "suggest": "[`std::ffi`] 模块中原语的 Windows 特定扩展。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to primitives in the [`std::fs`] module.",
        "suggest": "[`std::fs`] 模块中原语的 Windows 特定扩展。",
        "translate": ""
    },
    {
        "source": "use handle with native windows bindings",
        "suggest": "将句柄与本地 windows 绑定一起使用",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to primitives in the [`std::process`] module.",
        "suggest": "[`std::process`] 模块中原语的 Windows 特定扩展。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to primitives in the [`std::thread`] module.",
        "suggest": "[`std::thread`] 模块中原语的 Windows 特定扩展。",
        "translate": ""
    },
    {
        "source": "The iterator will yield instances of <code>[io::Result]<[fs::DirEntry]></code>.",
        "suggest": "迭代器将产生一个 <code>[io::Result]<[fs::DirEntry]></code> 的实例。",
        "translate": ""
    },
    {
        "source": "The handle returned from `get_handle` must be valid and non-null.",
        "suggest": "从 `get_handle` 返回的句柄必须有效且非空。",
        "translate": ""
    },
    {
        "source": "If successful, <code>[Ok]\\([Duration])</code> is returned where the duration represents the amount of time elapsed from the specified measurement to this one.",
        "suggest": "如果成功，则返回 <code>[Ok]\\([Duration])</code>，其中持续时间表示从指定测量到此测量所经过的时间。",
        "translate": ""
    },
    {
        "source": "If successful, <code>[Ok]\\([Duration])</code> is returned where the duration represents the amount of time elapsed from this time measurement to the current time.",
        "suggest": "如果成功，则返回 <code>[Ok]\\([Duration])</code>，其中持续时间表示从这次时间测量到当前时间所经过的时间。",
        "translate": ""
    },
    {
        "source": "Even if you drop a `Vec`, its buffer may simply be reused by another allocation.",
        "suggest": "即使您丢弃了一个 `Vec`，它的缓冲区也可能会被另一个分配重用。",
        "translate": ""
    },
    {
        "source": "converts from <code>[&][][Option]\\<T></code> to",
        "suggest": "从 <code>[&][][Option]\\<T></code> 转换为",
        "translate": ""
    },
    {
        "source": "converts from <code>[&mut] [Option]\\<T></code> to",
        "suggest": "从 <code>[&mut] [Option]\\<T></code> 转换为",
        "translate": ""
    },
    {
        "source": "converts from <code>[Pin]<[&][][Option]\\<T>></code> to",
        "suggest": "从 <code>[Pin]<[&][][Option]\\<T>></code> 转换为",
        "translate": ""
    },
    {
        "source": "converts from <code>[Pin]<[&mut] [Option]\\<T>></code> to",
        "suggest": "从 <code>[Pin]<[&mut] [Option]\\<T>></code> 转换为",
        "translate": ""
    },
    {
        "source": "and <code>[Some]\\([Err]\\(\\_))</code> will be mapped to <code>[Ok]\\([Some]\\(\\_))</code> and <code>[Err]\\(\\_)</code>.",
        "suggest": "和 <code>[Some]\\([Err]\\(\\_))</code> 将映射到 <code>[Ok]\\([Some]\\(\\_))</code> 和 <code>[Err]\\(\\_)</code>。",
        "translate": ""
    },
    {
        "source": "There were the same number of elements to switch on both blocks during the last iteration, so there are no remaining elements on either block.",
        "suggest": "在上次迭代期间要在两个块上切换的元素数量相同，因此任何一个块上都没有剩余的元素。",
        "translate": ""
    },
    {
        "source": "Cover the remaining items with roughly equally-sized blocks.",
        "suggest": "用大致相同大小的块覆盖剩余的项。",
        "translate": ""
    },
    {
        "source": "while the loop condition holds there are still elements in `offsets_l`, so it is safe to point `end_l` to the previous element.",
        "suggest": "当循环条件成立时 `offsets_l` 中仍有元素，因此将 `end_l` 指向前一个元素是安全的。",
        "translate": ""
    },
    {
        "source": "The `ptr::swap` is safe if both its arguments are valid for reads and writes:",
        "suggest": "如果 `ptr::swap` 的参数对读和写都有效，则它是安全的:",
        "translate": ""
    },
    {
        "source": "Per the debug assert above, the distance between `l` and `r` is `block_l` elements, so there can be at most `block_l` remaining offsets between `start_l` and `end_l`.",
        "suggest": "根据上面的调试断言，`l` 和 `r` 之间的距离是 `block_l` 元素，因此 `start_l` 和 `end_l` 之间最多可以有 `block_l` 剩余偏移量。",
        "translate": ""
    },
    {
        "source": "This means `r` will be moved at most `block_l` steps back, which makes the `r.offset` calls valid (at that point `l == r`).",
        "suggest": "这意味着 `r` 最多将向后移动 `block_l` 步，这使得 `r.offset` 调用有效 (在那个时候 `l == r`)。",
        "translate": ""
    },
    {
        "source": "contains valid offsets into `v` collected during the partitioning of the last block, so the `l.offset` calls are valid.",
        "suggest": "包含在最后一个块的分区过程中收集到的 `v` 的有效偏移量，因此 `l.offset` 调用是有效的。",
        "translate": ""
    },
    {
        "source": "See the reasoning in [remaining-elements-safety].",
        "suggest": "请参见 [剩余元素安全][remaining-elements-safety] 中的推理。",
        "translate": ""
    },
    {
        "source": "`pivot` is a reference to the first element of `v`, so `ptr::read` is safe.",
        "suggest": "`pivot` 是对 `v` 第一个元素的引用，所以 `ptr::read` 是安全的。",
        "translate": ""
    },
    {
        "source": "`len >= 8` so there are at least two elements in the neighborhoods of `a`, `b` and `c`.",
        "suggest": "`len >= 8` 所以在 `a`、`b` 和 `c` 的邻域中至少有两个元素。",
        "translate": ""
    },
    {
        "source": "This means the three calls to `sort_adjacent` result in corresponding calls to `sort3` with valid 3-item neighborhoods around each pointer, which in turn means the calls to `sort2` are done with valid references.",
        "suggest": "这意味着对 `sort_adjacent` 的三个调用导致对 `sort3` 的相应调用以及每个指针周围的有效 3 项邻域，这反过来意味着对 `sort2` 的调用是通过有效的引用完成的。",
        "translate": ""
    },
    {
        "source": "Thus the `v.get_unchecked` calls are safe, as is the `ptr::swap` call.",
        "suggest": "因此 `v.get_unchecked` 调用是安全的，`ptr::swap` 调用也是安全的。",
        "translate": ""
    },
    {
        "source": "Trailing 0 byte will be appended by this function.",
        "suggest": "该函数将追加尾随的 0 字节。",
        "translate": ""
    },
    {
        "source": "Additionally, on Windows [`OsString`] implements the",
        "suggest": "此外，在 Windows 上 [`OsString`] 实现了",
        "translate": ""
    },
    {
        "source": "trait, which provides a [`from_wide`] method.",
        "suggest": "trait，它提供了一个 [`from_wide`] 方法。",
        "translate": ""
    },
    {
        "source": "<code>&[str]</code> should be either a string representation of an [`IpAddr`] address as expected by [`FromStr`] implementation or a host name.",
        "suggest": "<code>&[str]</code> 应该是 [`FromStr`] 实现所期望的 [`IpAddr`] 地址的字符串表示形式或主机名。",
        "translate": ""
    },
    {
        "source": "SOLID-specific extension to the primitives in the `std::ffi` module",
        "suggest": "`std::ffi` 模块中原语的 SOLID 特定扩展",
        "translate": ""
    },
    {
        "source": "SOLID-specific extensions to general I/O primitives",
        "suggest": "对通用 I/O 原语的 SOLID 特定扩展",
        "translate": ""
    },
    {
        "source": "A trait to extract the raw SOLID Sockets file descriptor from an underlying object.",
        "suggest": "从底层对象中提取原始 SOLID 套接字文件描述符的 trait。",
        "translate": ""
    },
    {
        "source": "various operations for both destructors and overloading `()`.",
        "suggest": "析构函数和重载 `()` 的各种操作。",
        "translate": ""
    },
    {
        "source": "the ubiquitous trait that defines [`clone`][Clone::clone], the method for producing a copy of a value.",
        "suggest": "定义 [`clone`][Clone::clone] 的无处不在的 trait ，即生成一个值副本的方法。",
        "translate": ""
    },
    {
        "source": "the comparison traits, which implement the comparison operators and are often seen in trait bounds.",
        "suggest": "比较 traits，它实现了比较相等，经常在 trait bounds 中看到。",
        "translate": ""
    },
    {
        "source": "generic conversions, used by savvy API authors to create overloaded methods.",
        "suggest": "泛型转换，由精明的 API 作者用来创建重载方法。",
        "translate": ""
    },
    {
        "source": "iterators of various kinds.",
        "suggest": "各种迭代器。",
        "translate": ""
    },
    {
        "source": "a type which expresses the presence or absence of a value.",
        "suggest": "表示值存在或不存在的类型。",
        "translate": ""
    },
    {
        "source": "a type for functions that may succeed or fail.",
        "suggest": "一种可能成功也可能失败的函数类型。",
        "translate": ""
    },
    {
        "source": "heap-allocated strings.",
        "suggest": "堆分配的字符串。",
        "translate": ""
    },
    {
        "source": "ABI for μITRON derivatives",
        "suggest": "μITRON 衍生的 ABI",
        "translate": ""
    },
    {
        "source": "Kernel object ID",
        "suggest": "内核对象 ID",
        "translate": ""
    },
    {
        "source": "The current task.",
        "suggest": "当前任务。",
        "translate": ""
    },
    {
        "source": "Relative time",
        "suggest": "相对时间",
        "translate": ""
    },
    {
        "source": "Timeout (a valid `RELTIM` value or `TMO_FEVR`)",
        "suggest": "超时 (有效的 `RELTIM` 值或 `TMO_FEVR`)",
        "translate": ""
    },
    {
        "source": "The infinite timeout value",
        "suggest": "无限超时的值",
        "translate": ""
    },
    {
        "source": "The maximum valid value of `RELTIM`",
        "suggest": "`RELTIM` 的最大有效值",
        "translate": ""
    },
    {
        "source": "System time",
        "suggest": "系统时间",
        "translate": ""
    },
    {
        "source": "Error code type",
        "suggest": "错误代码类型",
        "translate": ""
    },
    {
        "source": "Error code type, `ID` on success",
        "suggest": "错误代码类型，成功时的 `ID`",
        "translate": ""
    },
    {
        "source": "Task or interrupt priority",
        "suggest": "任务或中断优先级",
        "translate": ""
    },
    {
        "source": "The special value of `PRI` representing the current task's priority.",
        "suggest": "`PRI` 的特殊值，表示当前任务的优先级。",
        "translate": ""
    },
    {
        "source": "Use the priority inheritance protocol",
        "suggest": "使用优先继承协议",
        "translate": ""
    },
    {
        "source": "Activate the task on creation",
        "suggest": "在创建时激活任务",
        "translate": ""
    },
    {
        "source": "The maximum count of a semaphore",
        "suggest": "信号量的最大计数",
        "translate": ""
    },
    {
        "source": "Callback parameter",
        "suggest": "回调参数",
        "translate": ""
    },
    {
        "source": "Task entrypoint",
        "suggest": "任务入口点",
        "translate": ""
    },
    {
        "source": "Error codes",
        "suggest": "错误代码",
        "translate": ""
    },
    {
        "source": "conditional variable implementation based on user-space wait queues.",
        "suggest": "基于用户空间等待队列的条件变量实现。",
        "translate": ""
    },
    {
        "source": "The implementation is inspired by the queue-based implementation shown in Andrew D.",
        "suggest": "该实现受到了 Andrew D. 中所示的基于队列的实现的启发",
        "translate": ""
    },
    {
        "source": "Birrell's paper \"Implementing Condition Variables with Semaphores\"",
        "suggest": "Birrell 的论文 \"用信号量实现条件变量\"",
        "translate": ""
    },
    {
        "source": "Unpark the task",
        "suggest": "Unpark 任务",
        "translate": ""
    },
    {
        "source": "The task already has a token.",
        "suggest": "任务已经有一个 token。",
        "translate": ""
    },
    {
        "source": "Can't undo the effect;",
        "suggest": "无法撤消效果;",
        "translate": ""
    },
    {
        "source": "abort the program on failure",
        "suggest": "失败时中止程序",
        "translate": ""
    },
    {
        "source": "Construct `Waiter`.",
        "suggest": "构建 `Waiter`。",
        "translate": ""
    },
    {
        "source": "Wait until `waiter` is removed from the queue",
        "suggest": "等待 `waiter` 从队列中移除",
        "translate": ""
    },
    {
        "source": "Park the current task",
        "suggest": "Park 当前任务",
        "translate": ""
    },
    {
        "source": "Construct and pin `Waiter`",
        "suggest": "构建和固定 `Waiter`",
        "translate": ""
    },
    {
        "source": "Park the current task and do not wake up until the timeout elapses or the task gets woken up by `notify_*`",
        "suggest": "Park 当前任务，直到超时或任务被 `notify_*` 唤醒后才唤醒",
        "translate": ""
    },
    {
        "source": "We were unparked.",
        "suggest": "我们没有 unpark。",
        "translate": ""
    },
    {
        "source": "Are we really dequeued?",
        "suggest": "我们真的出队了吗?",
        "translate": ""
    },
    {
        "source": "No we are not.",
        "suggest": "不，我们没有。",
        "translate": ""
    },
    {
        "source": "Continue waiting.",
        "suggest": "继续等待。",
        "translate": ""
    },
    {
        "source": "Remove `waiter` from `self.waiters`.",
        "suggest": "从 `self.waiters` 上移除 `waiter`。",
        "translate": ""
    },
    {
        "source": "If `waiter` is still in `waiters`, it means we woke up because of a timeout.",
        "suggest": "如果 `waiter` 还在 `waiters` 中，则表示我们因为超时而醒来。",
        "translate": ""
    },
    {
        "source": "Otherwise, we woke up because of `notify_*`.",
        "suggest": "否则，我们会因为 `notify_*` 而醒来。",
        "translate": ""
    },
    {
        "source": "These fields are only accessed through `&[mut] WaiterQueue`.",
        "suggest": "这些字段只能通过 `&[mut] WaiterQueue` 访问。",
        "translate": ""
    },
    {
        "source": "The waiting task's ID.",
        "suggest": "等待任务的 ID。",
        "translate": ""
    },
    {
        "source": "Will be zeroed when the task is woken up and removed from a queue.",
        "suggest": "当任务被唤醒并从队列中移除时将被清零。",
        "translate": ""
    },
    {
        "source": "Zeroness of `Waiter::task` indicates whether the `Waiter` is linked to a queue or not.",
        "suggest": "`Waiter::task` 为零表示 `Waiter` 是否链接到队列。",
        "translate": ""
    },
    {
        "source": "This invariant is important for the correctness.",
        "suggest": "这个不可变变量对于正确性很重要。",
        "translate": ""
    },
    {
        "source": "The caller must own `*waiter_ptr`.",
        "suggest": "调用者必须拥有 `*waiter_ptr`。",
        "translate": ""
    },
    {
        "source": "The caller will lose the ownership until `*waiter_ptr` is removed from `self`.",
        "suggest": "调用者将失去所有权，直到 `*waiter_ptr` 从 `self` 中删除。",
        "translate": ""
    },
    {
        "source": "must be valid until it's removed from the queue.",
        "suggest": "在从队列中删除之前必须有效的。",
        "translate": ""
    },
    {
        "source": "must not have been previously inserted to a `WaiterQueue`.",
        "suggest": "之前不能插入到 `WaiterQueue` 中。",
        "translate": ""
    },
    {
        "source": "Find the insertion position and insert `waiter`",
        "suggest": "找到插入位置并插入 `waiter`",
        "translate": ""
    },
    {
        "source": "and all previous waiters have the same or higher priority than `current_task_priority`.",
        "suggest": "并且所有前面的 waiter 都具有与 `current_task_priority` 相同或更高的优先级。",
        "translate": ""
    },
    {
        "source": "Insert the new waiter right after `cursor`.",
        "suggest": "在 `cursor` 之后立即插入新的 waiter。",
        "translate": ""
    },
    {
        "source": "Insert `waiter` after `insert_after`",
        "suggest": "在 `insert_after` 之后插入 `waiter`",
        "translate": ""
    },
    {
        "source": "Insert `waiter` to the front",
        "suggest": "在前面插入 `waiter`",
        "translate": ""
    },
    {
        "source": "is the only element",
        "suggest": "是唯一的元素",
        "translate": ""
    },
    {
        "source": "Given a `Waiter` that was previously inserted to `self`, remove it from `self` if it's still there.",
        "suggest": "给定一个之前插入到 `self` 的 `Waiter`，如果它仍然存在，请将其从 `self` 中删除。",
        "translate": ""
    },
    {
        "source": "Given a `Waiter` that was previously inserted to `self`, return a flag indicating whether it's still in `self`.",
        "suggest": "给定一个先前插入到 `self` 的 `Waiter`，返回一个标志，指示它是否仍在 `self` 中。",
        "translate": ""
    },
    {
        "source": "Get the ID",
        "suggest": "获取 ID",
        "translate": ""
    },
    {
        "source": "Unlink the waiter",
        "suggest": "断开 waiter 的连接",
        "translate": ""
    },
    {
        "source": "Wraps a μITRON error code.",
        "suggest": "包装一个 μITRON 错误代码。",
        "translate": ""
    },
    {
        "source": "Construct `ItronError` from the specified error code.",
        "suggest": "根据指定的错误代码构造 `ItronError`。",
        "translate": ""
    },
    {
        "source": "Returns `None` if the error code does not represent a failure or warning.",
        "suggest": "如果错误代码不代表失败或警告，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns `Ok(er)` if `er` represents a success or `Err(_)` otherwise.",
        "suggest": "如果 `er` 表示成功，则返回 `Ok(er)`，否则返回 `Err(_)`。",
        "translate": ""
    },
    {
        "source": "Get the raw error code.",
        "suggest": "获取原始错误代码。",
        "translate": ""
    },
    {
        "source": "Allow the platforms to extend `error_name`",
        "suggest": "允许平台扩展 `error_name`",
        "translate": ""
    },
    {
        "source": "Describe the specified μITRON error code.",
        "suggest": "描述指定的 μITRON 错误代码。",
        "translate": ""
    },
    {
        "source": "Returns `None` if it's an undefined error code.",
        "suggest": "如果是未定义的错误代码，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "The TOPPERS third generation kernels",
        "suggest": "TOPPERS 第三代内核",
        "translate": ""
    },
    {
        "source": "Similar to `ItronError::err_if_negative(er).expect()` except that, while panicking, it prints the message to `panic_output` and aborts the program instead.",
        "suggest": "与 `ItronError::err_if_negative(er).expect()` 类似，不同之处在于，当 panic 时，它将消息打印到 `panic_output` 并中止程序。",
        "translate": ""
    },
    {
        "source": "This ensures the error message is not obscured by double panicking.",
        "suggest": "这确保错误消息不会被双重 panic 所掩盖。",
        "translate": ""
    },
    {
        "source": "This is useful for diagnosing creation failures of synchronization primitives that are used by `std`'s internal mechanisms.",
        "suggest": "这对于诊断 `std` 内部机制使用的同步原语的创建失败非常有用。",
        "translate": ""
    },
    {
        "source": "Such failures are common when the system is mis-configured to provide a too-small pool for kernel objects.",
        "suggest": "当系统被错误配置为为内核对象提供一个太小的池时，这种故障很常见。",
        "translate": ""
    },
    {
        "source": "Similar to `ItronError::err_if_negative(er).expect()` but aborts instead.",
        "suggest": "与 `ItronError::err_if_negative(er).expect()` 类似，但改为中止。",
        "translate": ""
    },
    {
        "source": "Use this where panicking is not allowed or the effect of the failure would be persistent.",
        "suggest": "在不允许 panic 或失败的影响将持续存在的情况下使用此选项。",
        "translate": ""
    },
    {
        "source": "Mutex implementation backed by μITRON mutexes.",
        "suggest": "μITRON 互斥体支持互斥锁实现。",
        "translate": ""
    },
    {
        "source": "Assumes `acre_mtx` and `TA_INHERIT` are available.",
        "suggest": "假设 `acre_mtx` 和 `TA_INHERIT` 可用。",
        "translate": ""
    },
    {
        "source": "The ID of the underlying mutex object",
        "suggest": "底层 mutex 对象的 ID",
        "translate": ""
    },
    {
        "source": "Create a mutex object.",
        "suggest": "创建一个 mutex 对象。",
        "translate": ""
    },
    {
        "source": "This function never panics.",
        "suggest": "这个函数永远不会 panic。",
        "translate": ""
    },
    {
        "source": "Priority inheritance mutex",
        "suggest": "优先继承 mutex",
        "translate": ""
    },
    {
        "source": "Initialize `self.mtx` eagerly",
        "suggest": "急切地初始化 `self.mtx`",
        "translate": ""
    },
    {
        "source": "Get the inner mutex's ID, which is lazily created.",
        "suggest": "获取延迟创建的内部 mutex 的 ID。",
        "translate": ""
    },
    {
        "source": "The lock count.",
        "suggest": "锁计数。",
        "translate": ""
    },
    {
        "source": "Recursive lock",
        "suggest": "递归锁",
        "translate": ""
    },
    {
        "source": "counter overflow",
        "suggest": "计数器溢出",
        "translate": ""
    },
    {
        "source": "Locked by another thread",
        "suggest": "被另一个线程锁定",
        "translate": ""
    },
    {
        "source": "Top-level lock by the current thread",
        "suggest": "当前线程的顶级锁",
        "translate": ""
    },
    {
        "source": "A mutex implemented by `dis_dsp` (for intra-core synchronization) and a spinlock (for inter-core synchronization).",
        "suggest": "由 `dis_dsp` (用于内核内同步) 和自旋锁 (用于内核间同步) 实现的互斥锁。",
        "translate": ""
    },
    {
        "source": "Acquire a lock.",
        "suggest": "获得一个锁。",
        "translate": ""
    },
    {
        "source": "Wait until the current processor acquires a lock.",
        "suggest": "等待直到当前处理器获得锁。",
        "translate": ""
    },
    {
        "source": "implemented by `dis_dsp` (for intra-core synchronization) and a spinlock (for inter-core synchronization).",
        "suggest": "由 `dis_dsp` (用于内核内同步) 和自旋锁 (用于内核间同步) 实现。",
        "translate": ""
    },
    {
        "source": "It's assumed that `0` is not a valid ID, and all kernel object IDs fall into range `1..=usize::MAX`.",
        "suggest": "假设 `0` 不是有效 ID，并且所有内核对象 ID 都在 `1..=usize::MAX` 范围内。",
        "translate": ""
    },
    {
        "source": "Assign the content without checking if it's already initialized or being initialized.",
        "suggest": "分配内容而不检查它是否已经初始化或正在初始化。",
        "translate": ""
    },
    {
        "source": "Assumption: A positive `abi::ID` fits in `usize`.",
        "suggest": "假设: 正的 `abi::ID` 适合 `usize`。",
        "translate": ""
    },
    {
        "source": "Warning: `f` must not perform a blocking operation, which includes panicking.",
        "suggest": "警告: `f` 不得执行阻塞操作，包括 panic。",
        "translate": ""
    },
    {
        "source": "Fast path",
        "suggest": "快速路径",
        "translate": ""
    },
    {
        "source": "Safety: The inner value has been initialized",
        "suggest": "安全: 内部值已经初始化",
        "translate": ""
    },
    {
        "source": "Store the initialized contents.",
        "suggest": "存储初始化的内容。",
        "translate": ""
    },
    {
        "source": "Use the release ordering to make sure the write is visible to the callers of `get`.",
        "suggest": "使用发布顺序确保写入对 `get` 的调用者可见。",
        "translate": ""
    },
    {
        "source": "Get the ID of the task in Running state.",
        "suggest": "获取处于运行状态的任务的 ID。",
        "translate": ""
    },
    {
        "source": "Panics on failure.",
        "suggest": "Panics 失败。",
        "translate": ""
    },
    {
        "source": "Aborts on failure.",
        "suggest": "失败时中止。",
        "translate": ""
    },
    {
        "source": "Get the specified task's priority.",
        "suggest": "获取指定任务的优先级。",
        "translate": ""
    },
    {
        "source": "Thread implementation backed by μITRON tasks.",
        "suggest": "由 μITRON 任务支持的线程实现。",
        "translate": ""
    },
    {
        "source": "Assumes `acre_tsk` and `exd_tsk` are available.",
        "suggest": "假设 `acre_tsk` 和 `exd_tsk` 可用。",
        "translate": ""
    },
    {
        "source": "The ID of the underlying task.",
        "suggest": "基础任务的 ID。",
        "translate": ""
    },
    {
        "source": "State data shared between a parent thread and child thread.",
        "suggest": "父线程和子线程之间共享的状态数据。",
        "translate": ""
    },
    {
        "source": "It's dropped on a transition to one of the final states.",
        "suggest": "它是在过渡到最终状态之一时被丢弃的。",
        "translate": ""
    },
    {
        "source": "This field is used on thread creation to pass a closure from `Thread::new` to the created task.",
        "suggest": "该字段用于线程创建以将来自 `Thread::new` 的闭包传递给创建的任务。",
        "translate": ""
    },
    {
        "source": "A state machine.",
        "suggest": "状态机。",
        "translate": ""
    },
    {
        "source": "Each transition is annotated with `[...]` in the source code.",
        "suggest": "每个转换都在源代码中用 `[...]` 注解。",
        "translate": ""
    },
    {
        "source": "Safety: The only `!Sync` field, `ThreadInner::start`, is only touched by the task represented by `ThreadInner`.",
        "suggest": "安全性: 唯一的 `!Sync` 字段，`ThreadInner::start`，仅被 `ThreadInner` 所代表的任务触及。",
        "translate": ""
    },
    {
        "source": "there's no single value for `JOINING`",
        "suggest": "`JOINING` 没有单一的值",
        "translate": ""
    },
    {
        "source": "See `thread::Builder::spawn_unchecked` for safety requirements.",
        "suggest": "有关安全要求，请参见 `thread::Builder::spawn_unchecked`。",
        "translate": ""
    },
    {
        "source": "Inherit the current task's priority",
        "suggest": "继承当前任务的优先级",
        "translate": ""
    },
    {
        "source": "Safety: `ThreadInner` is alive at this point",
        "suggest": "安全性: 此时 `ThreadInner` 此时处于活动状态",
        "translate": ""
    },
    {
        "source": "Safety: Since `trampoline` is called only once for each `ThreadInner` and only `trampoline` touches `start`, `start` contains contents and is safe to mutably borrow.",
        "suggest": "安全性: 由于每个 `ThreadInner` 只调用一次 `trampoline`，并且只有 `trampoline` 接触 `start`，因此 `start` 包含内容，可以安全地可变借用。",
        "translate": ""
    },
    {
        "source": "Fix the current thread's state just in case, so that the destructors won't abort Safety: Not really unsafe",
        "suggest": "修复当前线程的状态以防万一，以便析构函数不会终止安全: 并不是真的不安全",
        "translate": ""
    },
    {
        "source": "Run TLS destructors now because they are not called automatically for terminated tasks.",
        "suggest": "现在运行 TLS 析构函数，因为终止的任务不会自动调用它们。",
        "translate": ""
    },
    {
        "source": "No one will ever join, so we'll ask the collector task to delete the task.",
        "suggest": "没有人会加入，因此我们将要求收集器任务删除该任务。",
        "translate": ""
    },
    {
        "source": "In this case, `inner`'s ownership has been moved to us, And we are responsible for dropping it.",
        "suggest": "在这种情况下，`inner` 的所有权已经转移给我们，我们负责丢弃它。",
        "translate": ""
    },
    {
        "source": "The acquire ordering is not necessary because the parent thread made no memory acccess needing synchronization since the call to `acre_tsk`.",
        "suggest": "获取顺序不是必需的，因为当调用 `acre_tsk` 后，父线程没有进行需要同步的内存访问。",
        "translate": ""
    },
    {
        "source": "Safety: See above.",
        "suggest": "安全: 见上文。",
        "translate": ""
    },
    {
        "source": "Safety: There are no pinned references to the stack",
        "suggest": "安全性: 没有对栈的固定引用",
        "translate": ""
    },
    {
        "source": "The parent hasn't decided whether to join or detach this thread yet.",
        "suggest": "父任务还没有决定是加入还是分离这个线程。",
        "translate": ""
    },
    {
        "source": "Whichever option the parent chooses, it'll have to delete this task.",
        "suggest": "无论父任务选择哪个选项，它都必须删除此任务。",
        "translate": ""
    },
    {
        "source": "Since the parent might drop `*inner` as soon as it sees `FINISHED`, the release ordering must be used in the above `swap` call.",
        "suggest": "由于父任务可能会在看到 `FINISHED` 时立即丢弃 `*inner`，因此必须在上述 `swap` 调用中使用发布顺序。",
        "translate": ""
    },
    {
        "source": "Since the parent might drop `*inner` and terminate us as soon as it sees `JOIN_FINALIZE`, the release ordering must be used in the above `swap` call.",
        "suggest": "由于父任务可能会丢弃 `*inner` 并在它看到 `JOIN_FINALIZE` 后立即终止我们，因此必须在上述 `swap` 调用中使用发布顺序。",
        "translate": ""
    },
    {
        "source": "Wake up the parent task.",
        "suggest": "唤醒父任务。",
        "translate": ""
    },
    {
        "source": "indicates there's already a parking token",
        "suggest": "表示已经 parking token",
        "translate": ""
    },
    {
        "source": "Activate this task immediately",
        "suggest": "立即激活此任务",
        "translate": ""
    },
    {
        "source": "The entry point",
        "suggest": "入口点",
        "translate": ""
    },
    {
        "source": "Let the kernel allocate the stack,",
        "suggest": "让内核分配栈，",
        "translate": ""
    },
    {
        "source": "Get the current task ID.",
        "suggest": "获取当前任务的 ID。",
        "translate": ""
    },
    {
        "source": "Panicking here would cause a resource leak, so just abort on failure.",
        "suggest": "在这里 panic 会导致资源泄漏，所以只要在失败时中止即可。",
        "translate": ""
    },
    {
        "source": "The child task will transition the state to `JOIN_FINALIZE` and wake us up.",
        "suggest": "子任务将状态转换为 `JOIN_FINALIZE` 并唤醒我们。",
        "translate": ""
    },
    {
        "source": "To synchronize with the child task's memory accesses to `inner` up to the point of the assignment of `JOIN_FINALIZE`, `Ordering::Acquire` must be used for the `load`.",
        "suggest": "为了与子任务对 `inner` 的内存访问同步到 `JOIN_FINALIZE` 的分配点，`Ordering::Acquire` 必须用于 `load`。",
        "translate": ""
    },
    {
        "source": "To synchronize with the child task's memory accesses to `inner` up to the point of the assignment of `FINISHED`, `Ordering::Acquire` must be used for the above `swap` call`.",
        "suggest": "为了与子任务对 `inner` 的内存访问同步到 `FINISHED` 的分配点，`Ordering::Acquire` 必须用于上述 `swap` 调用 `。",
        "translate": ""
    },
    {
        "source": "Terminate and delete the task Safety: `self.task` still represents a task we own (because this method or `detach_inner` is called only once for each `Thread`).",
        "suggest": "终止并删除任务 Safety: `self.task` 仍然代表我们拥有所有权的任务 (因为这个方法或 `detach_inner` 对于每个 `Thread` 只调用一次)。",
        "translate": ""
    },
    {
        "source": "The task indicated that it's safe to delete by entering the `FINISHED` or `JOIN_FINALIZE` state.",
        "suggest": "该任务表明可以通过进入 `FINISHED` 或 `JOIN_FINALIZE` 状态进行安全删除。",
        "translate": ""
    },
    {
        "source": "In either case, we are responsible for dropping `inner`.",
        "suggest": "在任何一种情况下，我们都应对丢弃 `inner` 负责。",
        "translate": ""
    },
    {
        "source": "Safety: The contents of `self.inner` will not be accessed hereafter",
        "suggest": "安全: `self.inner` 的内容以后将不会被访问",
        "translate": ""
    },
    {
        "source": "Skip the destructor (because it would attempt to detach the thread)",
        "suggest": "跳过析构函数 (因为它会尝试分离线程)",
        "translate": ""
    },
    {
        "source": "Detach the thread.",
        "suggest": "分离线程。",
        "translate": ""
    },
    {
        "source": "When the time comes, the child will figure out that no one will ever join it.",
        "suggest": "当时机成熟时，子节点会发现没有人会加入。",
        "translate": ""
    },
    {
        "source": "The ownership of `self.inner` is moved to the child thread.",
        "suggest": "`self.inner` 的所有权转移到子线程。",
        "translate": ""
    },
    {
        "source": "However, the release ordering is not necessary because we made no memory acccess needing synchronization since the call to `acre_tsk`.",
        "suggest": "但是，释放顺序不是必需的，因为自从调用 `acre_tsk` 之后，我们没有进行需要同步的内存访问。",
        "translate": ""
    },
    {
        "source": "The task has already decided that we should delete the task.",
        "suggest": "任务已经决定我们应该删除任务。",
        "translate": ""
    },
    {
        "source": "To synchronize with the child task's memory accesses to `inner` up to the point of the assignment of `FINISHED`, the acquire ordering is required for the above `swap` call.",
        "suggest": "为了与子任务对 `inner` 的内存访问同步到 `FINISHED` 的分配点，上述 `swap` 调用需要获取排序。",
        "translate": ""
    },
    {
        "source": "Terminate and delete the task Safety: `self.task` still represents a task we own (because this method or `join_inner` is called only once for each `Thread`).",
        "suggest": "终止并删除任务安全: `self.task` 仍然代表我们拥有的任务 (因为这个方法或 `join_inner` 对于每个 `Thread` 只调用一次)。",
        "translate": ""
    },
    {
        "source": "The task  indicated that it's safe to delete by entering the `FINISHED` state.",
        "suggest": "任务表明可以通过进入 `FINISHED` 状态进行安全删除。",
        "translate": ""
    },
    {
        "source": "Wwe are responsible for dropping `inner`.",
        "suggest": "Wwe 负责丢弃 `inner`。",
        "translate": ""
    },
    {
        "source": "Terminate and delete the specified task.",
        "suggest": "终止并删除指定的任务。",
        "translate": ""
    },
    {
        "source": "This function will abort if `deleted_task` refers to the calling task.",
        "suggest": "如果 `deleted_task` 指的是调用任务，则这个函数将终止。",
        "translate": ""
    },
    {
        "source": "It is assumed that the specified task is solely managed by the caller - i.e., other threads must not \"resuscitate\" the specified task or delete it prematurely while this function is still in progress.",
        "suggest": "假设指定的任务是由调用者单独管理的 -- 即，在此函数仍在进行中时，其他线程不得对指定的任务进行 \"resuscitate\" 或过早删除。",
        "translate": ""
    },
    {
        "source": "It is allowed for the specified task to exit by its own.",
        "suggest": "允许指定的任务自行退出。",
        "translate": ""
    },
    {
        "source": "The task must be safe to terminate.",
        "suggest": "任务必须可以安全终止。",
        "translate": ""
    },
    {
        "source": "This is in general not true because there might be pinned references to the task's stack.",
        "suggest": "这通常是不正确的，因为可能存在对任务栈的固定引用。",
        "translate": ""
    },
    {
        "source": "Terminate the task Safety: Upheld by the caller",
        "suggest": "终止任务安全: 由调用方支持",
        "translate": ""
    },
    {
        "source": "Indicates the task is already dormant, ignore it",
        "suggest": "表示任务已经休眠，请忽略它",
        "translate": ""
    },
    {
        "source": "Delete the task Safety: Upheld by the caller",
        "suggest": "删除任务安全: 调用方支持",
        "translate": ""
    },
    {
        "source": "Terminate and delete the calling task.",
        "suggest": "终止并删除调用任务。",
        "translate": ""
    },
    {
        "source": "Atomicity is not required - i.e., it can be assumed that other threads won't `ter_tsk` the calling task while this function is still in progress.",
        "suggest": "原子性不是必需的 - 即，可以假设其他线程不会在此函数仍在进行中时 `ter_tsk` 调用任务。",
        "translate": ""
    },
    {
        "source": "(This property makes it easy to implement this operation on μITRON-derived kernels that don't support `exd_tsk`.)",
        "suggest": "(这个属性使得在不支持 `exd_tsk` 的 μITRON 派生内核上实现这个操作变得很容易。)",
        "translate": ""
    },
    {
        "source": "Safety: `exd_tsk` never returns on success",
        "suggest": "安全性: `exd_tsk` 永远不会成功返回",
        "translate": ""
    },
    {
        "source": "Safety: The provided pointer is valid",
        "suggest": "安全: 提供的指针有效",
        "translate": ""
    },
    {
        "source": "There are ways to change the system time",
        "suggest": "有多种方法可以改变系统时间",
        "translate": ""
    },
    {
        "source": "is measured in microseconds",
        "suggest": "以微秒为单位进行测量",
        "translate": ""
    },
    {
        "source": "Split `Duration` into zero or more `RELTIM`s.",
        "suggest": "将 `Duration` 拆分为零个或多个 `RELTIM`。",
        "translate": ""
    },
    {
        "source": "is microseconds",
        "suggest": "是微秒",
        "translate": ""
    },
    {
        "source": "Split `Duration` into one or more `TMO`s.",
        "suggest": "将 `Duration` 拆分为一个或多个 `TMO`。",
        "translate": ""
    },
    {
        "source": "Split `Duration` into one or more API calls with timeout.",
        "suggest": "将 `Duration` 拆分为一个或多个带超时的 API 调用。",
        "translate": ""
    },
    {
        "source": "This function can handle spurious wakeups.",
        "suggest": "这个函数可以处理虚假唤醒。",
        "translate": ""
    },
    {
        "source": "and `SYSTIM` are microseconds.",
        "suggest": "和 `SYSTIM` 是微秒。",
        "translate": ""
    },
    {
        "source": "Clamp at `SYSTIM::MAX` for performance reasons.",
        "suggest": "出于性能原因，Clamp 在 `SYSTIM::MAX` 中。",
        "translate": ""
    },
    {
        "source": "This shouldn't cause a problem in practice.",
        "suggest": "这在实践中应该不会造成问题。",
        "translate": ""
    },
    {
        "source": "(`u64::MAX` μs ≈ 584942 years)",
        "suggest": "(`u64::MAX` μs ≈ 584942 年)",
        "translate": ""
    },
    {
        "source": "This value can be chosen by an application",
        "suggest": "该值可以由应用程序选择",
        "translate": ""
    },
    {
        "source": "Describe the specified SOLID error code.",
        "suggest": "描述指定的 SOLID 错误代码。",
        "translate": ""
    },
    {
        "source": "The SOLID error codes are a superset of μITRON error codes.",
        "suggest": "SOLID 错误代码是 μITRON 错误代码的超集。",
        "translate": ""
    },
    {
        "source": "A file descriptor.",
        "suggest": "一个文件描述符。",
        "translate": ""
    },
    {
        "source": "Safety: we just asserted that the value is in the valid range and isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)",
        "suggest": "安全性: 我们只是断言该值在有效范围内并且不是 `-1` (唯一大于 `0xFF_FF_FF_FE` 的无符号值)",
        "translate": ""
    },
    {
        "source": "Casting to `i64` is fine, too large values will end up as negative which will cause an error in `SOLID_FS_Lseek`.",
        "suggest": "强制转换为 `i64` 很好，太大的值最终会变成负数，这将导致 `SOLID_FS_Lseek` 出现错误。",
        "translate": ""
    },
    {
        "source": "Get the new offset",
        "suggest": "获取新的偏移量",
        "translate": ""
    },
    {
        "source": "This target doesn't support symlinks",
        "suggest": "此目标不支持符号链接",
        "translate": ""
    },
    {
        "source": "is `pub(crate)` so that it can be accessed by `itron/error.rs` as",
        "suggest": "是 `pub(crate)`，所以它可以被 `itron/error.rs` 访问为",
        "translate": ""
    },
    {
        "source": "Judging by the source code, it's unlimited, but specify a lower value just in case.",
        "suggest": "从源代码来看，它是无限的，但为了以防万一，请指定一个较低的值。",
        "translate": ""
    },
    {
        "source": "Returns the last error from the network subsystem.",
        "suggest": "从网络子系统返回最后一个错误。",
        "translate": ""
    },
    {
        "source": "there's no ErrorKind for EINPROGRESS",
        "suggest": "EINPROGRESS 没有 ErrorKind",
        "translate": ""
    },
    {
        "source": "This method is used by sys_common code to abstract over targets.",
        "suggest": "sys_common 代码使用该方法对目标进行抽象。",
        "translate": ""
    },
    {
        "source": "directly maps `errno`s to μITRON error codes.",
        "suggest": "直接将 `errno`s 映射为 μITRON 错误代码。",
        "translate": ""
    },
    {
        "source": "In kmclib, `setenv` and `unsetenv` don't always set `errno`, so this function just returns a generic error.",
        "suggest": "在 kmclib 中，`setenv` 和 `unsetenv` 并不总是设置 `errno`，所以这个函数只是返回一个通用错误。",
        "translate": ""
    },
    {
        "source": "A readers-writer lock implementation backed by the SOLID kernel extension.",
        "suggest": "由 SOLID 内核扩展支持的 readers-writer 锁实现。",
        "translate": ""
    },
    {
        "source": "Safety: `num_readers` is protected by `mtx_num_readers`",
        "suggest": "安全: `num_readers` 受 `mtx_num_readers` 保护",
        "translate": ""
    },
    {
        "source": "Register `tls_dtor` to make sure the TLS destructors are called for tasks created by other means than `std::thread`",
        "suggest": "注册 `tls_dtor` 以确保为通过 `std::thread` 以外的其他方式创建的任务调用 TLS 析构函数",
        "translate": ""
    },
    {
        "source": "Swap the destructor list, call all registered destructors, and repeat this until the list becomes permanently empty.",
        "suggest": "交换析构函数列表，调用所有已注册的析构函数，并重复这个过程，直到列表永久为空。",
        "translate": ""
    },
    {
        "source": "Drop the destructor list",
        "suggest": "丢弃析构函数列表",
        "translate": ""
    },
    {
        "source": "implement on vxWorks, Redox, l4re",
        "suggest": "在 vxWorks、Redox、l4re 上实现",
        "translate": ""
    },
    {
        "source": "thread_local with `const {}` triggers this liny",
        "suggest": "带有 `const {}` 的 thread_local 会触发此 liny",
        "translate": ""
    },
    {
        "source": "Minimum number of elements in a node that is not a root.",
        "suggest": "非根节点中的最小元素数。",
        "translate": ""
    },
    {
        "source": "Every non-leaf node contains at least 1 element (has at least 2 children).",
        "suggest": "每个非叶子节点至少包含 1 个元素 (至少有 2 个子节点)。",
        "translate": ""
    },
    {
        "source": "An empty map is represented either by the absence of a root node or by a root node that is an empty leaf.",
        "suggest": "空的 map 表示不存在根节点或根节点为空叶子。",
        "translate": ""
    },
    {
        "source": "Making this upper bound more tight during iteration would require an extra field.",
        "suggest": "在迭代期间使这个上限更紧将需要一个额外的字段。",
        "translate": ""
    },
    {
        "source": "The returned KV handle is only valid to access the key and value, and only valid until the next call to a `deallocating_` method.",
        "suggest": "返回的 KV 句柄仅对访问键和值有效，并且仅在下一次调用 `deallocating_` 方法之前有效。",
        "translate": ""
    },
    {
        "source": "Requires exclusive access to the `NodeRef` object but not to the root node;",
        "suggest": "需要对 `NodeRef` 对象的独占访问，而不是对根节点的独占访问;",
        "translate": ""
    },
    {
        "source": "VecDeque::with_capacity ensures that there is enough capacity.",
        "suggest": "VecDeque::with_capacity 确保有足够的容量。",
        "translate": ""
    },
    {
        "source": "due to unchecked casts of unsigned amounts to signed offsets the wraparound effectively results in unsigned pointers representing positions 0..usize::MAX, which is valid for ZSTs.",
        "suggest": "由于未检查的无符号量转换为有符号偏移，环绕有效地导致表示位置 0..usize::MAX 的无符号指针，这对 ZST 有效。",
        "translate": ""
    },
    {
        "source": "the min() above ensures that step_size is in bounds",
        "suggest": "上面的 min() 确保 step_size 在界限内",
        "translate": ""
    },
    {
        "source": "same as for advance_by()",
        "suggest": "与 advance_by() 相同",
        "translate": ""
    },
    {
        "source": "TrustedRandomAccess (without NoCoerce) must not be implemented because subtypes/supertypes of `T` might not be `NonDrop`",
        "suggest": "不得实现 TrustedRandomAccess (无 NoCoerce)，因为 `T` 的 subtypes/supertypes 可能不是 `NonDrop`",
        "translate": ""
    },
    {
        "source": "process_one return a bool indicates whether the processing element should be retained.",
        "suggest": "process_one 返回一个 bool 指示是否应保留处理元素。",
        "translate": ""
    },
    {
        "source": "Stage 1: Nothing was deleted.",
        "suggest": "第 1 阶段: 没有删除任何内容。",
        "translate": ""
    },
    {
        "source": "Stage 2: Some elements were deleted.",
        "suggest": "第 2 阶段: 删除了一些元素。",
        "translate": ""
    },
    {
        "source": "If you only need to resize to a smaller size, use [`Vec::truncate`].",
        "suggest": "如果您只需要调整到更小的尺寸，请使用 [`Vec::truncate`]。",
        "translate": ""
    },
    {
        "source": "If hashed by iteration alone, `(x, y)` and `(y, x)` would visit the same order of elements, resulting in the same hash.",
        "suggest": "如果单独通过迭代进行散列，`(x, y)` 和 `(y, x)` 将访问相同顺序的元素，从而产生相同的散列。",
        "translate": ""
    },
    {
        "source": "But now that we also hash the length, they get distinct sequences of hashed data.",
        "suggest": "但是现在我们也对长度进行了散列，他们得到了不同的散列数据序列。",
        "translate": ""
    },
    {
        "source": "we do not need to update the count since that only tallies the number of items consumed from the front.",
        "suggest": "我们不需要更新计数，因为它只计算从前面消耗的 item 数量。",
        "translate": ""
    },
    {
        "source": "consuming items from the back can never reduce that.",
        "suggest": "从后面消费项永远不能减少。",
        "translate": ""
    },
    {
        "source": "step_one calculation may have saturated",
        "suggest": "step_one 计算可能已经饱和",
        "translate": ""
    },
    {
        "source": "the conditions above ensure that the count is in bounds.",
        "suggest": "上述条件确保计数在界限内。",
        "translate": ""
    },
    {
        "source": "If start <= end then steps_between either returns a bound to which we clamp or returns None which together with the initial inequality implies more than usize::MAX steps.",
        "suggest": "如果 start <= end 那么 steps_between 要么返回一个我们钳制的界限，要么返回 None，这与初始不等式一起意味着超过 usize::MAX 个步骤。",
        "translate": ""
    },
    {
        "source": "Otherwise 0 is returned which always safe to use.",
        "suggest": "否则返回 0，这始终可以安全使用。",
        "translate": ""
    },
    {
        "source": "same as the spec_advance_by() implementation",
        "suggest": "与 spec_advance_by() 实现相同",
        "translate": ""
    },
    {
        "source": "Calling `advance_back_by(0)` can do meaningful work, for example [`Flatten`] can advance its outer iterator until it finds an inner iterator that is not empty, which then often allows it to return a more accurate `size_hint()` than in its initial state.",
        "suggest": "调用 `advance_back_by(0)` 可以做有意义的工作，例如 [`Flatten`] 可以推进它的外部迭代器，直到它找到一个不为空的内部迭代器，然后通常允许它返回一个比初始状态更准确的 `size_hint()`。",
        "translate": ""
    },
    {
        "source": "may either return `Ok()` or `Err(0)`.",
        "suggest": "可能返回 `Ok()` 或 `Err(0)`。",
        "translate": ""
    },
    {
        "source": "The former conveys no information whether the iterator is or is not exhausted, the latter can be treated as if [`next_back`] had returned `None`.",
        "suggest": "前者不传达迭代器是否已耗尽的信息，后者可以被视为 [`next_back`] 返回了 `None`。",
        "translate": ""
    },
    {
        "source": "Replacing a `Err(0)` with `Ok` is only correct for `n = 0`.",
        "suggest": "用 `Ok` 替换 `Err(0)` 仅适用于 `n = 0`。",
        "translate": ""
    },
    {
        "source": "Calling `advance_by(0)` can do meaningful work, for example [`Flatten`] can advance its outer iterator until it finds an inner iterator that is not empty, which then often allows it to return a more accurate `size_hint()` than in its initial state.",
        "suggest": "调用 `advance_by(0)` 可以做有意义的工作，例如 [`Flatten`] 可以推进它的外部迭代器，直到它找到一个不为空的内部迭代器，然后通常允许它返回一个比初始状态更准确的 `size_hint()`。",
        "translate": ""
    },
    {
        "source": "The former conveys no information whether the iterator is or is not exhausted, the latter can be treated as if [`next`] had returned `None`.",
        "suggest": "前者不传达迭代器是否已耗尽的信息，后者可以被视为 [`next`] 返回了 `None`。",
        "translate": ""
    },
    {
        "source": "Using `&` helps LLVM see that it is the same check made in division.",
        "suggest": "使用 `&` 有助于 LLVM 看到它是在除法中进行的相同检查。",
        "translate": ""
    },
    {
        "source": "Computes the absolute difference between `self` and `other`.",
        "suggest": "计算 `self` 和 `other` 之间的绝对差。",
        "translate": ""
    },
    {
        "source": "This function always returns the correct answer without overflow or panics by returning an unsigned integer.",
        "suggest": "这个函数总是通过返回一个无符号整数来返回没有溢出或 panics 的正确答案。",
        "translate": ""
    },
    {
        "source": "Converting a non-negative x from signed to unsigned by using `x as U` is left unchanged, but a negative x is converted to value x + 2^N.",
        "suggest": "使用 `x as U` 将非负 x 从有符号转换为无符号保持不变，但负 x 转换为值 x + 2^N。",
        "translate": ""
    },
    {
        "source": "Thus if `s` and `o` are binary variables respectively indicating whether `self` and `other` are negative, we are computing the mathematical value:",
        "suggest": "因此如果 `s` 和 `o` 分别是二元变量变量，表示 `self` 和 `other` 是否为负，我们正在计算数学值:",
        "translate": ""
    },
    {
        "source": "Finally, taking the mod 2^N of the mathematical value of `other - self` does not change it as it already is in the range [0, 2^N).",
        "suggest": "最后，取 `other - self` 的数学值的 mod 2^N 不会改变它，因为它已经在 [0, 2^N) 范围内。",
        "translate": ""
    },
    {
        "source": "Trick LLVM into generating the psadbw instruction when SSE2 is available and this function is autovectorized for u8's.",
        "suggest": "当 SSE2 可用时，诱使 LLVM 生成 psadbw 指令，并且此函数为 u8 自动向量化。",
        "translate": ""
    },
    {
        "source": "FIXME replace `mem::replace` by `mem::take` when the latter is const ready",
        "suggest": "当 `mem::take` 准备好常量时，FIXME 用 `mem::take` 替换 `mem::replace`",
        "translate": ""
    },
    {
        "source": "this implementation, which sidesteps using `Option::map` since it's not const ready yet, should be reverted when possible to avoid code repetition",
        "suggest": "此实现避开使用 `Option::map`，因为它尚未准备好常量，应尽可能还原以避免代码重复",
        "translate": ""
    },
    {
        "source": "applies the provided function to the contained value of [`Ok`], or applies the provided default fallback function to the contained value of [`Err`]",
        "suggest": "将提供的函数应用于 [`Ok`] 的包含值，或将提供的默认回退函数应用于 [`Err`] 的包含值",
        "translate": ""
    },
    {
        "source": "Maps a `Result<T, E>` to `U` by applying a provided default fallback function to a contained [`Err`] value, or a provided function to a contained [`Ok`] value.",
        "suggest": "通过将提供的默认回退函数应用于包含的 [`Err`] 值，或将提供的函数应用于包含的 [`Ok`] 值，Maps 将 `Result<T, E>` 转换为 `U`。",
        "translate": ""
    },
    {
        "source": "test that the methods of `Option` that take mutable references are usable in a const context",
        "suggest": "测试 `Option` 的方法在 const 上下文中是否可用",
        "translate": ""
    },
    {
        "source": "If we've read all the way up to the capacity, reserve more space.",
        "suggest": "如果我们一直读到容量，请保留更多空间。",
        "translate": ""
    },
    {
        "source": "Initialize any excess capacity and adjust the length so we can write to it.",
        "suggest": "初始化任何多余的容量并调整长度，以便我们可以写入它。",
        "translate": ""
    },
    {
        "source": "The buffer might be an exact fit.",
        "suggest": "缓冲区可能是完全合适的。",
        "translate": ""
    },
    {
        "source": "Let's read into a probe buffer and see if it returns `Ok(0)`.",
        "suggest": "让我们读入一个探测缓冲区，看看它是否返回 `Ok(0)`。",
        "translate": ""
    },
    {
        "source": "If so, we've avoided an unnecessary doubling of the capacity.",
        "suggest": "如果是这样，我们就避免了不必要的容量翻倍。",
        "translate": ""
    },
    {
        "source": "But if not, append the probe buffer to the primary buffer and let its capacity grow.",
        "suggest": "但如果没有，请将探测缓冲区附加到主缓冲区并让它容量增长。",
        "translate": ""
    },
    {
        "source": "takes care not to over-allocate when a buffer is the exact size needed.",
        "suggest": "当缓冲区是所需的确切大小时，注意不要过度分配。",
        "translate": ""
    },
    {
        "source": "Returns [`true`] if this address is in a range designated for benchmarking.",
        "suggest": "如果此地址在为基准测试指定的范围内，则返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "See the documentation for [`Ipv4Addr::is_benchmarking()`] and [`Ipv6Addr::is_benchmarking()`] for more details.",
        "suggest": "有关更多详细信息，请参见 [`Ipv4Addr::is_benchmarking()`] 和 [`Ipv6Addr::is_benchmarking()`] 的文档。",
        "translate": ""
    },
    {
        "source": "Returns [`true`] if this is an address reserved for benchmarking (`2001:2::/48`).",
        "suggest": "如果这是为基准测试 (`2001:2::/48`) 保留的地址，则返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "This property is defined in [IETF RFC 5180], where it is mistakenly specified as covering the range `2001:0200::/48`.",
        "suggest": "此属性在 [IETF RFC 5180] 中定义，其中错误地将其指定为覆盖范围 `2001:0200::/48`。",
        "translate": ""
    },
    {
        "source": "This is corrected in [IETF RFC Errata 1752] to `2001:0002::/48`.",
        "suggest": "这在 [IETF RFC Errata 1752] 到 `2001:0002::/48` 中得到纠正。",
        "translate": ""
    },
    {
        "source": "verbatim paths need . and ..",
        "suggest": "verbatim 路径需要 . 和 ..",
        "translate": ""
    },
    {
        "source": "removed",
        "suggest": "移除",
        "translate": ""
    },
    {
        "source": "system_info cpu_count field gets the static data set at boot time with `smp_set_num_cpus` `get_system_info` calls then `smp_get_num_cpus`",
        "suggest": "system_info cpu_count 字段在启动时使用 `smp_set_num_cpus` `get_system_info` 调用然后 `smp_get_num_cpus` 获取静态数据集",
        "translate": ""
    },
    {
        "source": "Only register `WSACleanup` if `WSAStartup` is actually ever called.",
        "suggest": "仅当 `WSAStartup` 被实际调用过时才注册 `WSACleanup`。",
        "translate": ""
    },
    {
        "source": "Workaround to prevent linking to `WS2_32.dll` when no network functionality is used.",
        "suggest": "在不使用网络功能时防止链接到 `WS2_32.dll` 的解决方法。",
        "translate": ""
    },
    {
        "source": "See issue #85441.",
        "suggest": "请参见 issue #85441。",
        "translate": ""
    },
    {
        "source": "only perform cleanup if network functionality was actually initialized",
        "suggest": "仅在实际初始化网络功能时才执行清理",
        "translate": ""
    },
    {
        "source": "see issue #88585",
        "suggest": "请参见 issue #88585",
        "translate": ""
    },
    {
        "source": "Converts a `Cow<'_, [T]>` into a `Box<[T]>`",
        "suggest": "将 `Cow<'_, [T]>` 转换为 `Box<[T]>`",
        "translate": ""
    },
    {
        "source": "When `cow` is the `Cow::Borrowed` variant, this conversion allocates on the heap and copies the underlying slice.",
        "suggest": "当 `cow` 是 `Cow::Borrowed` 成员时，此转换在堆上分配并复制底层切片。",
        "translate": ""
    },
    {
        "source": "Otherwise, it will try to reuse the owned `Vec`'s allocation.",
        "suggest": "否则，它将尝试重用拥有所有权的 `Vec` 的分配。",
        "translate": ""
    },
    {
        "source": "Converts a `Cow<'_, str>` into a `Box<str>`",
        "suggest": "将 `Cow<'_, str>` 转换为 `Box<str>`",
        "translate": ""
    },
    {
        "source": "When `cow` is the `Cow::Borrowed` variant, this conversion allocates on the heap and copies the underlying `str`.",
        "suggest": "当 `cow` 是 `Cow::Borrowed` 成员时，此转换在堆上分配并复制底层 `str`。",
        "translate": ""
    },
    {
        "source": "Otherwise, it will try to reuse the owned `String`'s allocation.",
        "suggest": "否则，它将尝试重用拥有所有权的 `String` 的分配。",
        "translate": ""
    },
    {
        "source": "Attempts to convert a `Box<[T]>` into a `Box<[T; N]>`.",
        "suggest": "尝试将 `Box<[T]>` 转换为 `Box<[T; N]>`。",
        "translate": ""
    },
    {
        "source": "The conversion occurs in-place and does not require a new memory allocation.",
        "suggest": "转换就地发生，不需要新的内存分配。",
        "translate": ""
    },
    {
        "source": "Returns the old `Box<[T]>` in the `Err` variant if `boxed_slice.len()` does not equal `N`.",
        "suggest": "如果 `boxed_slice.len()` 不等于 `N`，则返回 `Err` 成员中的旧 `Box<[T]>`。",
        "translate": ""
    },
    {
        "source": "Creates an array `[T; N]` where each array element `T` is returned by the `cb` call.",
        "suggest": "创建一个数组 `[T; N]`，其中每个数组元素 `T` 都由 `cb` 调用返回。",
        "translate": ""
    },
    {
        "source": "Callback where the passed argument is the current array index.",
        "suggest": "回调，其中传递的参数是当前数组索引。",
        "translate": ""
    },
    {
        "source": "Creates an array `[T; N]` where each fallible array element `T` is returned by the `cb` call.",
        "suggest": "创建一个数组 `[T; N]`，其中每个易出错的数组元素 `T` 由 `cb` 调用返回。",
        "translate": ""
    },
    {
        "source": "Unlike `core::array::from_fn`, where the element creation can't fail, this version will return an error if any element creation was unsuccessful.",
        "suggest": "与 `core::array::from_fn` 不同，元素创建不能失败，如果任何元素创建失败，此版本将返回错误。",
        "translate": ""
    },
    {
        "source": "Infallible version of `collect_into_array_rslt_unchecked`.",
        "suggest": "`collect_into_array_rslt_unchecked` 的可靠版本。",
        "translate": ""
    },
    {
        "source": "The same safety considerations w.r.t.",
        "suggest": "相同的安全注意事项",
        "translate": ""
    },
    {
        "source": "the iterator length apply for `collect_into_array_rslt_unchecked` as for",
        "suggest": "迭代器长度适用于 `collect_into_array_rslt_unchecked`",
        "translate": ""
    },
    {
        "source": "this slice will contain only initialized objects.",
        "suggest": "这个切片将只包含初始化的对象。",
        "translate": ""
    },
    {
        "source": "Swaps the values of two `Cell`s.",
        "suggest": "交换两个 `Cell` 的值。",
        "translate": ""
    },
    {
        "source": "Prefix collisions",
        "suggest": "前缀冲突",
        "translate": ""
    },
    {
        "source": "Implementations of `hash` should ensure that the data they pass to the `Hasher` are prefix-free.",
        "suggest": "`hash` 的实现应该确保它们传递给 `Hasher` 的数据是无前缀的。",
        "translate": ""
    },
    {
        "source": "That is, unequal values should cause two different sequences of values to be written, and neither of the two sequences should be a prefix of the other.",
        "suggest": "也就是说，不相等的值应该导致写入两个不同的值序列，并且两个序列中的任何一个都不应该是另一个的前缀。",
        "translate": ""
    },
    {
        "source": "For example, the standard implementation of [`Hash` for `&str`][impl] passes an extra `0xFF` byte to the `Hasher` so that the values `(\"ab\", \"c\")` and `(\"a\", \"bc\")` hash differently.",
        "suggest": "例如，[`Hash` for `&str`][impl] 的标准实现将额外的 `0xFF` 字节传递给 `Hasher`，以便值 `(\"ab\", \"c\")` 和 `(\"a\", \"bc\")` 哈希不同。",
        "translate": ""
    },
    {
        "source": "Checked addition with an unsigned integer.",
        "suggest": "用无符号整数检查加法。",
        "translate": ""
    },
    {
        "source": "Checked subtraction with an unsigned integer.",
        "suggest": "用无符号整数检查减法。",
        "translate": ""
    },
    {
        "source": "Saturating addition with an unsigned integer.",
        "suggest": "使用无符号整数进行饱和加法。",
        "translate": ""
    },
    {
        "source": "Overflow can only happen at the upper bound We cannot use `unwrap_or` here because it is not `const`",
        "suggest": "溢出只能发生在上限，我们不能在这里使用 `unwrap_or`，因为它不是 `const`",
        "translate": ""
    },
    {
        "source": "Saturating subtraction with an unsigned integer.",
        "suggest": "使用无符号整数进行饱和减法。",
        "translate": ""
    },
    {
        "source": "Overflow can only happen at the lower bound We cannot use `unwrap_or` here because it is not `const`",
        "suggest": "溢出只能发生在下限，我们不能在这里使用 `unwrap_or`，因为它不是 `const`",
        "translate": ""
    },
    {
        "source": "Wrapping (modular) addition with an unsigned integer.",
        "suggest": "用无符号整数包装 (modular) 加法。",
        "translate": ""
    },
    {
        "source": "Wrapping (modular) subtraction with an unsigned integer.",
        "suggest": "用无符号整数包装 (modular) 减法。",
        "translate": ""
    },
    {
        "source": "Calculates `self` + `rhs` with an unsigned `rhs`",
        "suggest": "使用无符号 `rhs` 计算 `self` + `rhs`",
        "translate": ""
    },
    {
        "source": "Calculates `self` - `rhs` with an unsigned `rhs`",
        "suggest": "使用无符号 `rhs` 计算 `self`-`rhs`",
        "translate": ""
    },
    {
        "source": "Returns the logarithm of the number with respect to an arbitrary base, rounded down.",
        "suggest": "返回数字相对于任意底数的对数，向下取整。",
        "translate": ""
    },
    {
        "source": "it panics in debug mode and the return value is 0 in release mode.",
        "suggest": "它在调试模式下为 panics，在生产模式下返回值为 0。",
        "translate": ""
    },
    {
        "source": "Returns the base 2 logarithm of the number, rounded down.",
        "suggest": "返回数字的以 2 为底的对数，向下取整。",
        "translate": ""
    },
    {
        "source": "When the number is zero it panics in debug mode and the return value is 0 in release mode.",
        "suggest": "当数字为零时，它在调试模式下为 panics，在生产模式下返回值为 0。",
        "translate": ""
    },
    {
        "source": "Returns the base 10 logarithm of the number, rounded down.",
        "suggest": "返回数字的以 10 为底的对数，向下取整。",
        "translate": ""
    },
    {
        "source": "NaN (not a number): this value results from calculations like `(-1.0).sqrt()`.",
        "suggest": "NaN (不是数字) : 这个值来自于类似于 `(-1.0).sqrt()` 等的计算得出。",
        "translate": ""
    },
    {
        "source": "See [the documentation for `f32`](f32) for more information on the unusual properties of NaN.",
        "suggest": "有关 NaN 的独特属性的更多信息，请参见 [`f32` 的文档](f32)。",
        "translate": ""
    },
    {
        "source": "Positive or negative infinity, which often results from dividing a nonzero number by zero.",
        "suggest": "正无穷大或负无穷大，通常由非零数除以零产生。",
        "translate": ""
    },
    {
        "source": "See [the documentation for `f32`](f32) for more information on the signedness of zeroes.",
        "suggest": "有关零的符号性的更多信息，请参见 [`f32` 的文档](f32)。",
        "translate": ""
    },
    {
        "source": "Subnormal” or “denormal” floating point representation (less precise, relative to their magnitude, than [`Normal`]).",
        "suggest": "subnormal” 或 “denormal” 浮点表示 (相对于它们的大小，不如 [`Normal`] 精确)。",
        "translate": ""
    },
    {
        "source": "Subnormal numbers are larger in magnitude than [`Zero`] but smaller in magnitude than all [`Normal`] numbers.",
        "suggest": "subnormal 数在数量级上比 [`Zero`] 大，但在数量级上小于所有 [`Normal`] 数。",
        "translate": ""
    },
    {
        "source": "A regular floating point number, not any of the exceptional categories.",
        "suggest": "常规浮点数，不是任何特殊类别。",
        "translate": ""
    },
    {
        "source": "The smallest positive normal numbers are [`f32::MIN_POSITIVE`] and [`f64::MIN_POSITIVE`], and the largest positive normal numbers are [`f32::MAX`] and [`f64::MAX`].",
        "suggest": "最小的 positive normal 数是 [`f32::MIN_POSITIVE`] 和 [`f64::MIN_POSITIVE`]，最大的 positive normal 数是 [`f32::MAX`] 和 [`f64::MAX`]。",
        "translate": ""
    },
    {
        "source": "(Unlike signed integers, floating point numbers are symmetric in their range, so negating any of these constants will produce their negative counterpart.)",
        "suggest": "(与有符号整数不同，浮点数在其范围内是对称的，因此否定这些常量中的任何一个都会产生它们的负对应项。)",
        "translate": ""
    },
    {
        "source": "Checked addition with a signed integer.",
        "suggest": "用有符号整数检查加法。",
        "translate": ""
    },
    {
        "source": "When the number is negative or zero it panics in debug mode and the return value is 0 in release mode.",
        "suggest": "当数字为负数或零时，它在调试模式下为 panics，在生产模式下的返回值为 0。",
        "translate": ""
    },
    {
        "source": "Saturating addition with a signed integer.",
        "suggest": "带符号整数的饱和加法。",
        "translate": ""
    },
    {
        "source": "Wrapping (modular) addition with a signed integer.",
        "suggest": "用有符号整数包装 (modular) 加法。",
        "translate": ""
    },
    {
        "source": "Calculates `self` + `rhs` with a signed `rhs`",
        "suggest": "使用带符号的 `rhs` 计算 `self` + `rhs`",
        "translate": ""
    },
    {
        "source": "When return value overflows (i.e., `self > (1 << (N-1))` for type `uN`), it panics in debug mode and the return value is wrapped to 0 in release mode (the only situation in which method can return 0).",
        "suggest": "当返回值溢出 (即 `uN` 类型为 `self > (1 << (N-1))`) 时，它在调试模式下为 panics，在生产模式下返回值被包装为 0 (方法可以返回 0 的唯一情况)。",
        "translate": ""
    },
    {
        "source": "Maps a `Result<T, E>` to `U` by applying fallback function `default` to a contained [`Err`] value, or function `f` to a contained [`Ok`] value.",
        "suggest": "通过将 fallback 函数 `default` 应用于包含的 [`Err`] 值，或将函数 `f` 应用于包含的 [`Ok`] 值，将 `Result<T, E>` 映射为 `U`。",
        "translate": ""
    },
    {
        "source": "When combined with the `?` operator, this function will propogate any [`Poll::Pending`] values to the caller, and extract the `T` from [`Poll::Ready`].",
        "suggest": "当与 `?` 运算符结合使用时，该函数会将任何 [`Poll::Pending`] 值传播给调用者，并从 [`Poll::Ready`] 中提取 `T`。",
        "translate": ""
    },
    {
        "source": "See [`Poll::ready`] for details.",
        "suggest": "有关详细信息，请参见 [`Poll::ready`]。",
        "translate": ""
    },
    {
        "source": "Indicates how much extra capacity is needed to read the rest of the file.",
        "suggest": "指示读取文件的其余部分需要多少额外容量。",
        "translate": ""
    },
    {
        "source": "Reserves space in the buffer based on the file size when available.",
        "suggest": "根据可用的文件大小在缓冲区中保留空间。",
        "translate": ""
    },
    {
        "source": "The inner reader might have an optimized `read_to_end`.",
        "suggest": "内部 reader 可能具有优化的 `read_to_end`。",
        "translate": ""
    },
    {
        "source": "Drain our buffer and then delegate to the inner implementation.",
        "suggest": "耗尽我们的缓冲区，然后委托给内部实现。",
        "translate": ""
    },
    {
        "source": "In the general `else` case below we must read bytes into a side buffer, check that they are valid UTF-8, and then append them to `buf`.",
        "suggest": "在下面的一般 `else` 情况下，我们必须将字节读入一个 side 缓冲区，检查它们是否是有效的 UTF-8，然后将它们附加到 `buf`。",
        "translate": ""
    },
    {
        "source": "This requires a potentially large memcpy.",
        "suggest": "这需要一个潜在的大型 memcpy。",
        "translate": ""
    },
    {
        "source": "If `buf` is empty--the most common case--we can leverage `append_to_string` to read directly into `buf`'s internal byte buffer, saving an allocation and a memcpy.",
        "suggest": "如果 `buf` 为空 -- 最常见的情况 -- 我们可以利用 `append_to_string` 直接读入 `buf` 的内部字节缓冲区，从而保存分配和 memcpy。",
        "translate": ""
    },
    {
        "source": "`append_to_string`'s safety relies on the buffer only being appended to since it only checks the UTF-8 validity of new data.",
        "suggest": "`append_to_string` 的安全性仅依赖于被附加到的缓冲区，因为它只检查新数据的 UTF-8 有效性。",
        "translate": ""
    },
    {
        "source": "If there were existing content in `buf` then an untrustworthy reader (i.e.",
        "suggest": "如果 `buf` 中存在现有内容，那么不可信的 reader (即",
        "translate": ""
    },
    {
        "source": "`self.inner`) could not only append bytes but also modify existing bytes and render them invalid.",
        "suggest": "`self.inner`) 不仅可以追加字节，还可以修改现有字节并使它们无效。",
        "translate": ""
    },
    {
        "source": "On the other hand, if `buf` is empty then by definition any writes must be appends and `append_to_string` will validate all of the new bytes.",
        "suggest": "另一方面，如果 `buf` 为空，则根据定义，任何写入都必须附加，并且 `append_to_string` 将验证所有新字节。",
        "translate": ""
    },
    {
        "source": "We cannot append our byte buffer directly onto the `buf` String as there could be an incomplete UTF-8 sequence that has only been partially read.",
        "suggest": "我们不能将字节缓冲区直接附加到 `buf` 字符串上，因为可能存在仅部分读取的不完整 UTF-8 序列。",
        "translate": ""
    },
    {
        "source": "We must read everything into a side buffer first and then call `from_utf8` on the complete buffer.",
        "suggest": "我们必须首先将所有内容读入 side 缓冲区，然后在整个缓冲区上调用 `from_utf8`。",
        "translate": ""
    },
    {
        "source": "Several `read_to_string` and `read_line` methods in the standard library will append data into a `String` buffer, but we need to be pretty careful when doing this.",
        "suggest": "标准库中的几个 `read_to_string` 和 `read_line` 方法会将数据附加到 `String` 缓冲区中，但我们在执行此操作时需要非常小心。",
        "translate": ""
    },
    {
        "source": "Note that we do *not* call `r.read_to_end()` here.",
        "suggest": "请注意，我们在这里不调用 `r.read_to_end()`。",
        "translate": ""
    },
    {
        "source": "To prevent extraneously checking the UTF-8-ness of the entire buffer we pass it to our hardcoded `default_read_to_end` implementation which we know is guaranteed to only read data into the end of the buffer.",
        "suggest": "为了防止额外检查整个缓冲区的 UTF-8-ness，我们将它传递给我们的硬编码 `default_read_to_end` 实现，我们知道它保证只将数据读入缓冲区的末尾。",
        "translate": ""
    },
    {
        "source": "Note that in some special cases, such as when reading files, this function will pre-allocate memory based on the size of the input it is reading.",
        "suggest": "请注意，在某些特殊情况下，例如读取文件时，该函数会根据正在读取的输入的大小预先分配内存。",
        "translate": ""
    },
    {
        "source": "In those cases, the performance should be as good as if you had used [`Read::read_to_string`] with a manually pre-allocated buffer.",
        "suggest": "在这些情况下，性能应该与您使用手动预分配缓冲区的 [`Read::read_to_string`] 一样好。",
        "translate": ""
    },
    {
        "source": "requires this flag for stack mapping otherwise the said mapping will fail as a no-op on most systems and has a different meaning on FreeBSD",
        "suggest": "需要这个标志来进行栈映射，否则所述映射将在大多数系统上作为空操作失败，并且在 FreeBSD 上具有不同的含义",
        "translate": ""
    },
    {
        "source": "The caller has to ensure that the spawned thread does not outlive any references in the supplied thread closure and its return type.",
        "suggest": "调用者必须确保新建线程的生命周期不会超过所提供线程闭包及其返回类型中的任何引用。",
        "translate": ""
    },
    {
        "source": "Alias for C++ `std::thread::hardware_concurrency`.",
        "suggest": "C++ `std::thread::hardware_concurrency` 的别名。",
        "translate": ""
    },
    {
        "source": "Alias for a name we gave this API on unstable.",
        "suggest": "我们为这个 API 命名的别名是不稳定的。",
        "translate": ""
    },
    {
        "source": "is from `rust-analyzer/src/cli/analysis_stats.rs`.",
        "suggest": "是来自于 `rust-analyzer/src/cli/analysis_stats.rs`。",
        "translate": ""
    },
    {
        "source": "is from `core/src/hash/mod.rs`.",
        "suggest": "是来自于 `core/src/hash/mod.rs`。",
        "translate": ""
    }
]
