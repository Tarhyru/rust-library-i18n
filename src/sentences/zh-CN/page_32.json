[
    {
        "source": "Generates a std::cout for the intrinsics results that will match the rust debug output format for the return type.",
        "suggest": "为内部函数结果生成一个 std::cout，该结果将匹配 Rust 调试输出格式的返回类型。",
        "translate": ""
    },
    {
        "source": "Only perform the test for intrinsics that are enabled...",
        "suggest": "只对启用的内部函数进行测试...",
        "translate": ""
    },
    {
        "source": "Not sure how we would compare intrinsic that returns void.",
        "suggest": "不知道我们如何比较返回 void 的内部函数。",
        "translate": ""
    },
    {
        "source": "Skip pointers for now, we would probably need to look at the return type to work out how many elements we need to point to.",
        "suggest": "现在跳过指针，我们可能需要查看返回类型来计算我们需要指向多少个元素。",
        "translate": ""
    },
    {
        "source": "intrinsics with a lane parameter have constraints, deal with them later.",
        "suggest": "带有 lane 参数的内部函数有约束，以后再处理。",
        "translate": ""
    },
    {
        "source": "fails to compile this intrinsic due to an error.",
        "suggest": "由于错误，无法编译此内部函数。",
        "translate": ""
    },
    {
        "source": "fatal error: error in backend: Cannot select: 0x2b99c30: i64 = AArch64ISD::VSHL Constant:i64<1>, Constant:i32<1>",
        "suggest": "致命错误：后端错误：无法选择: 0x2b99c30: i64 = AArch64ISD::VSHL Constant:i64<1>, Constant:i32<1>",
        "translate": ""
    },
    {
        "source": "Gets the type part of a c typedef for a type that's in the form of {type}{size}_t.",
        "suggest": "获取 {type}{size}_t 形式的类型的 c typedef 的类型部分。",
        "translate": ""
    },
    {
        "source": "Gets the rust prefix for the type kind i.e. i, u, f.",
        "suggest": "获取类型 kind 的 Rust 前缀，即 i、u、f。",
        "translate": ""
    },
    {
        "source": "The bit length of this type (e.g. 32 for u32).",
        "suggest": "这个类型的位长度 (例如，u32 为 32)。",
        "translate": ""
    },
    {
        "source": "Length of the SIMD vector (i.e. 4 for uint32x4_t), A value of `None` means this is not a simd type.",
        "suggest": "SIMD vector 的长度 (即 4 表示 uint32x4_t)，`None` 值就意味着这不是 simd 类型。",
        "translate": ""
    },
    {
        "source": "A `None` can be assumed to be 1, although in some places a distinction is needed between `u64` and `uint64x1_t` this signals that.",
        "suggest": "可以假设 `None` 为 1，尽管在某些地方需要区分 `u64` 和 `uint64x1_t`，这表明了这一点。",
        "translate": ""
    },
    {
        "source": "The number of rows for SIMD matrices (i.e. 2 for uint8x8x2_t).",
        "suggest": "SIMD 矩阵的行数 (即 2 表示 uint8x8x2_t)。",
        "translate": ""
    },
    {
        "source": "A value of `None` represents a type that does not contain any rows encoded in the type (e.g.",
        "suggest": "`None` 的值表示不包含在该类型中编码的任何行的类型 (例如",
        "translate": ""
    },
    {
        "source": "A value of `None` can be assumed to be 1 though.",
        "suggest": "但是 `None` 的值可以假设为 1。",
        "translate": ""
    },
    {
        "source": "Get the TypeKind for this type, recursing into pointers.",
        "suggest": "获取此类型的 TypeKind，递归到指针中。",
        "translate": ""
    },
    {
        "source": "Get the size of a single element inside this type, recursing into pointers, i.e.",
        "suggest": "获取该类型内单个元素的大小，递归到指针中，即",
        "translate": ""
    },
    {
        "source": "a pointer to a u16 would be 16 rather than the size of a pointer.",
        "suggest": "指向 u16 的指针将是 16 而不是指针的大小。",
        "translate": ""
    },
    {
        "source": "Determine if the type is a simd type, this will treat a type such as `uint64x1` as simd.",
        "suggest": "确定类型是否为 simd 类型，这会将 `uint64x1` 等类型视为 simd。",
        "translate": ""
    },
    {
        "source": "Gets a string containing the typename for this type in C format.",
        "suggest": "以 C 格式获取包含此类型的类型名称的字符串。",
        "translate": ""
    },
    {
        "source": "Gets a cast for this type if needs promotion.",
        "suggest": "如果需要升级，则获取此类型的强制转换。",
        "translate": ""
    },
    {
        "source": "This is required for 8 bit types due to printing as the 8 bit types use a char and when using that in `std::cout` it will print as a character, which means value of 0 will be printed as a null byte.",
        "suggest": "由于 8 位类型使用字符，因此这对于 8 位类型是必需的，当在 `std::cout` 中使用它时，它将打印为字符，这意味着 0 值将打印为空字节。",
        "translate": ""
    },
    {
        "source": "Generates a comma list of values that can be used to initialize an argument for the intrinsic call.",
        "suggest": "生成一个逗号值列表，可用于初始化内部函数调用的参数。",
        "translate": ""
    },
    {
        "source": "This is determistic based on the pass number.",
        "suggest": "这是基于通过数来确定的。",
        "translate": ""
    },
    {
        "source": "The pass index, i.e. the iteration index for the call to an intrinsic",
        "suggest": "通过索引，即调用到内部函数的迭代索引",
        "translate": ""
    },
    {
        "source": "Returns a string such as",
        "suggest": "返回一个字符串，例如",
        "translate": ""
    },
    {
        "source": "if `language` is `Language::C`",
        "suggest": "如果 `language` 是 `Language::C`",
        "translate": ""
    },
    {
        "source": "if `language` is `Language::Rust`",
        "suggest": "如果 `language` 是 `Language::Rust`",
        "translate": ""
    },
    {
        "source": "Determines the load function for this type.",
        "suggest": "确定此类型的加载函数。",
        "translate": ""
    },
    {
        "source": "Determines the get lane function for this type.",
        "suggest": "确定此类型的获取通道函数。",
        "translate": ""
    },
    {
        "source": "Gets a hex constant value for a single lane in in a determistic way",
        "suggest": "以确定的方式获取单个通道的十六进制常量值",
        "translate": ""
    },
    {
        "source": "The number of bits for the type, only 8, 16, 32, 64 are valid values",
        "suggest": "类型的位数，只有 8、16、32、64 是有效值",
        "translate": ""
    },
    {
        "source": "The index of the simd lane we are generating for",
        "suggest": "我们正在生成的 simd 通道的索引",
        "translate": ""
    },
    {
        "source": "The index of the pass we are generating the values for",
        "suggest": "我们正在生成值的传递的索引",
        "translate": ""
    },
    {
        "source": "The smallest normal value.",
        "suggest": "最小的正常值。",
        "translate": ""
    },
    {
        "source": "The value just below 0.5.",
        "suggest": "值略低于 0.5。",
        "translate": ""
    },
    {
        "source": "The value just above 0.5.",
        "suggest": "值略高于 0.5。",
        "translate": ""
    },
    {
        "source": "The value just below 1.0.",
        "suggest": "值略低于 1.0。",
        "translate": ""
    },
    {
        "source": "The value just above 1.0.",
        "suggest": "值略高于 1.0。",
        "translate": ""
    },
    {
        "source": "The largest finite value.",
        "suggest": "最大的有限值。",
        "translate": ""
    },
    {
        "source": "Quiet NaNs",
        "suggest": "安静的 NaNs",
        "translate": ""
    },
    {
        "source": "Signalling NaNs",
        "suggest": "信令 NaNs",
        "translate": ""
    },
    {
        "source": "A recognisable bit pattern.",
        "suggest": "可识别的位模式。",
        "translate": ""
    },
    {
        "source": "The largest subnormal value.",
        "suggest": "最大的 subnormal 值。",
        "translate": ""
    },
    {
        "source": "The smallest subnormal value.",
        "suggest": "最小的 subnormal 值。",
        "translate": ""
    },
    {
        "source": "The same values again, but negated.",
        "suggest": "再次相同的值再次被否定了。",
        "translate": ""
    },
    {
        "source": "Simple values.",
        "suggest": "单个值。",
        "translate": ""
    },
    {
        "source": "Target features need to be enabled for LLVM objdump on Macos ARM64",
        "suggest": "需要为 Macos ARM64 上的 LLVM objdump 启用目标功能",
        "translate": ""
    },
    {
        "source": "Normalize [us]shll.* ..., #0 instructions to the preferred form: [us]xtl.* ...",
        "suggest": "将 `[us]shll.* ..., #0` 指令规范化为首选形式: `[us]xtl.*` ...",
        "translate": ""
    },
    {
        "source": "as LLVM objdump does not do that.",
        "suggest": "因为 LLVM objdump 不这样做。",
        "translate": ""
    },
    {
        "source": "for details.",
        "suggest": "详情。",
        "translate": ""
    },
    {
        "source": "strip trailing comma",
        "suggest": "去除尾随逗号",
        "translate": ""
    },
    {
        "source": "Look for subroutine call instructions in the disassembly to detect whether inlining failed: all intrinsics are `#[inline(always)]`, so calling one intrinsic from another should not generate subroutine call instructions.",
        "suggest": "在反汇编中查找子程序调用指令来检测是否内联失败：所有内部函数都是 `#[inline(always)]`，所以从另一个调用一个内部函数不应生成子程序调用指令。",
        "translate": ""
    },
    {
        "source": "original logic but does not match comment",
        "suggest": "与注释不匹配的原始逻辑",
        "translate": ""
    },
    {
        "source": "Add detection for other archs",
        "suggest": "添加对其他 archs 的检测",
        "translate": ""
    },
    {
        "source": "A iterator for deduping the key of a sorted iterator.",
        "suggest": "一个迭代器，用于对排序后的迭代器的键进行去重。",
        "translate": ""
    },
    {
        "source": "When encountering the duplicated key, only the last key-value pair is yielded.",
        "suggest": "当遇到重复的键时，只产生最后一个键值对。",
        "translate": ""
    },
    {
        "source": "Used by [`BTreeMap::bulk_build_from_sorted_iter`].",
        "suggest": "由 [`BTreeMap::bulk_build_from_sorted_iter`] 使用。",
        "translate": ""
    },
    {
        "source": "Makes a `BTreeMap` from a sorted iterator.",
        "suggest": "从排序的迭代器生成一个 `BTreeMap`。",
        "translate": ""
    },
    {
        "source": "use stable sort to preserve the insertion order.",
        "suggest": "使用稳定排序来保留插入顺序。",
        "translate": ""
    },
    {
        "source": "Traversal isn't needed, it happens using the result of `borrow_mut`.",
        "suggest": "遍历是不需要的，无论发生什么都使用 `borrow_mut` 的结果。",
        "translate": ""
    },
    {
        "source": "Therefore, we move all the resizing and error-handling logic from grow_amortized and handle_reserve behind a call, while making sure that this function is likely to be inlined as just a comparison and a call if the comparison fails.",
        "suggest": "因此，我们将所有的调整大小和错误处理逻辑从 grow_amortized 和 handle_reserve 移到一个调用之后，同时确保如果比较失败，这个函数很可能被内联为一个比较和一个调用。",
        "translate": ""
    },
    {
        "source": "This way, you can avoid moving the original array if its elements are not [`Copy`].",
        "suggest": "这样，如果原始数组的元素不是 [`Copy`]，则可以避免移动原始数组。",
        "translate": ""
    },
    {
        "source": "Returns `Some(t)` if the `bool` is [`true`](../std/keyword.true.html), or `None` otherwise.",
        "suggest": "如果 `bool` 是 [`true`](../std/keyword.true.html)，则返回 `Some(t)`，否则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns `Some(f())` if the `bool` is [`true`](../std/keyword.true.html), or `None` otherwise.",
        "suggest": "如果 `bool` 是 [`true`](../std/keyword.true.html)，则返回 `Some(f())`，否则返回 `None`。",
        "translate": ""
    },
    {
        "source": "It can occur, for example, when giving ill-formed UTF-8 bytes to [`String::from_utf8_lossy`](../std/string/struct.String.html#method.from_utf8_lossy).",
        "suggest": "例如，当将格式错误的 UTF-8 字节提供给 [`String::from_utf8_lossy`](../std/string/struct.String.html#method.from_utf8_lossy) 时，就会发生这种情况。",
        "translate": ""
    },
    {
        "source": "Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):",
        "suggest": "使用 [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):",
        "translate": ""
    },
    {
        "source": "This will escape the characters similar to the [`Debug`](core::fmt::Debug) implementations of `str` or `char`.",
        "suggest": "这将转义类似于 `str` 或 `char` 的 [`Debug`](core::fmt::Debug) 实现的字符。",
        "translate": ""
    },
    {
        "source": "Equivalent to <code>[to_ascii_lowercase]\\(a) == [to_ascii_lowercase]\\(b)</code>.",
        "suggest": "相当于 <code>[to_ascii_lowercase]\\(a) == [to_ascii_lowercase]\\(b)</code>。",
        "translate": ""
    },
    {
        "source": "The reducing function is a closure with two arguments: an 'accumulator', and an element.",
        "suggest": "Reduce 函数是一个闭包，有两个参数：一个 'accumulator' 和一个元素。",
        "translate": ""
    },
    {
        "source": "For iterators with at least one element, this is the same as [`fold()`] with the first element of the iterator as the initial accumulator value, folding every subsequent element into it.",
        "suggest": "对于具有至少一个元素的迭代器，这与 [`fold()`] 相同，将迭代器的第一个元素作为初始累加器值，将每个后续元素 fold 到其中。",
        "translate": ""
    },
    {
        "source": "Those implementations are:",
        "suggest": "这些实现是:",
        "translate": ""
    },
    {
        "source": "Arrays `[T; N]` implement `Unsize<[T]>`.",
        "suggest": "数组 `[T; N]` 实现 `Unsize<[T]>`。",
        "translate": ""
    },
    {
        "source": "Types implementing a trait `Trait` also implement `Unsize<dyn Trait>`.",
        "suggest": "实现 trait `Trait` 的类型也实现 `Unsize<dyn Trait>`。",
        "translate": ""
    },
    {
        "source": "Structs `Foo<..., T, ...>` implement `Unsize<Foo<..., U, ...>>` if all of these conditions are met:",
        "suggest": "如果满足所有这些条件，结构体 `Foo<..., T, ...>` 实现 `Unsize<Foo<..., U, ...>>`:",
        "translate": ""
    },
    {
        "source": "Only the last field of `Foo` has a type involving `T`.",
        "suggest": "只有 `Foo` 的最后一个字段具有涉及 `T` 的类型。",
        "translate": ""
    },
    {
        "source": "where `Bar<T>` stands for the actual type of that last field.",
        "suggest": "其中 `Bar<T>` 代表最后一个字段的实际类型。",
        "translate": ""
    },
    {
        "source": "Returns `None` is `rhs` is zero or the operation would result in overflow.",
        "suggest": "如果 `rhs` 为零，则返回 `None`，否则操作将导致溢出。",
        "translate": ""
    },
    {
        "source": "is guaranteed to have the same layout and ABI as `T`.",
        "suggest": "保证与 `T` 具有相同的布局和 ABI。",
        "translate": ""
    },
    {
        "source": "Inserts `value` into the option, then returns a mutable reference to it.",
        "suggest": "将 `value` 插入到选项，然后返回对它的可变引用。",
        "translate": ""
    },
    {
        "source": "Unzips an option containing a tuple of two options.",
        "suggest": "解压缩包含两个选项的元组的选项。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Some`] value or a default.",
        "suggest": "返回包含的 [`Some`] 值或默认值。",
        "translate": ""
    },
    {
        "source": "Leaves the original `Option` in-place, creating a new one containing a mutable reference to the inner type's [`Deref::Target`] type.",
        "suggest": "在这里保留原始的 `Option`，创建一个包含对内部类型的 [`Deref::Target`] 类型的可变引用的新的 `Option`。",
        "translate": ""
    },
    {
        "source": "Moves `val` into a new [`Some`].",
        "suggest": "将 `val` 移动到新的 [`Some`] 中。",
        "translate": ""
    },
    {
        "source": "Should no [`None`][Option::None] occur, a container of type `V` containing the values of each [`Option`] is returned.",
        "suggest": "如果没有出现 [`None`][Option::None]，则返回一个 `V` 类型的容器，其中包含每个 [`Option`] 的值。",
        "translate": ""
    },
    {
        "source": "Converts from `Option<Option<T>>` to `Option<T>`.",
        "suggest": "从 `Option<Option<T>>` 转换为 `Option<T>`。",
        "translate": ""
    },
    {
        "source": "should have the same contents.",
        "suggest": "应该有相同的内容。",
        "translate": ""
    },
    {
        "source": "These are different files so that relative links work properly without having to have `CARGO_PKG_NAME` set, but conceptually they should always be the same.",
        "suggest": "这些是不同的文件，因此相关链接无需设置 `CARGO_PKG_NAME` 即可正常工作，但从概念上讲，它们应该始终相同。",
        "translate": ""
    },
    {
        "source": "The `bool` represents a value, which could only be either [`true`] or [`false`].",
        "suggest": "`bool` 代表一个值，它只能是 [`true`] 或 [`false`]。",
        "translate": ""
    },
    {
        "source": "If you cast a `bool` into an integer, [`true`] will be 1 and [`false`] will be 0.",
        "suggest": "如果将 `bool` 转换为整数，则 [`true`] 表示为 1，[`false`] 表示为 0。",
        "translate": ""
    },
    {
        "source": "which is an important macro in testing, checks whether an expression is [`true`] and panics if it isn't.",
        "suggest": "测试中的一个重要宏，检查表达式是否为 [`true`]，如果不是则为 panics。",
        "translate": ""
    },
    {
        "source": "Prior to Rust 1.53, arrays did not implement [`IntoIterator`] by value, so the method call `array.into_iter()` auto-referenced into a [slice iterator](slice::iter).",
        "suggest": "在 Rust 1.53 之前，数组没有按值实现 [`IntoIterator`]，因此调用 `array.into_iter()` 方法自动引用到 [slice 迭代器](slice::iter)。",
        "translate": ""
    },
    {
        "source": "Right now, the old behavior is preserved in the 2015 and 2018 editions of Rust for compatibility, ignoring [`IntoIterator`] by value.",
        "suggest": "目前，为了兼容性，Rust 的 2015 和 2018 版本中保留了旧行为，忽略了 [`IntoIterator`] 的值。",
        "translate": ""
    },
    {
        "source": "For example, in [`PartialOrd`] and [`Ord`], the elements are compared sequentially until the first non-equal set is found.",
        "suggest": "例如，在 [`PartialOrd`] 和 [`Ord`] 中，元素按顺序进行比较，直到找到第一个不相等的集合。",
        "translate": ""
    },
    {
        "source": "You can get one by using the `&` or `&mut` operators on a value, or by using a [`ref`](../std/keyword.ref.html) or <code>[ref](../std/keyword.ref.html) [mut](../std/keyword.mut.html)</code> pattern.",
        "suggest": "您可以通过在值上使用 `&` 或 `&mut` 运算符，或者使用 [`ref`](../std/keyword.ref.html) 或 <code>[ref](../std/keyword.ref.html) [mut](../std/keyword.mut.html)</code> 模式。",
        "translate": ""
    },
    {
        "source": "For those familiar with pointers, a reference is just a pointer that is assumed to be aligned, not null, and pointing to memory containing a valid value of `T` - for example, <code>&[bool]</code> can only point to an allocation containing the integer values `1` ([`true`](../std/keyword.true.html)) or `0` ([`false`](../std/keyword.false.html)), but creating a <code>&[bool]</code> that points to an allocation containing the value `3` causes undefined behaviour.",
        "suggest": "对于那些熟悉指针的人来说，引用只是一个被认为是对齐的指针，而不是空的，并且指向包含有效值 `T` 的内存 -- 例如， <code>&[bool]</code> 只能指向包含整数值 `1` ([`true`](../std/keyword.true.html)) 或 `0` ([`false`](../std/keyword.false.html)) 的分配，但创建一个 <code>&[bool]</code> 指向包含值 `3` 的分配会导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "In fact, <code>[Option]\\<&T></code> has the same memory representation as a nullable but aligned pointer, and can be passed across FFI boundaries as such.",
        "suggest": "事实上，<code>[Option]\\<&T></code> 与可为空但已对齐的指针具有相同的内存表示，并且可以像这样跨 FFI 边界传递。",
        "translate": ""
    },
    {
        "source": "\\(note that `&T` references only get `Send` if <code>T: [Sync]</code>)",
        "suggest": "\\ (注意 `&T` 引用只在 <code>T: [Sync]</code> 得到 `Send` )",
        "translate": ""
    },
    {
        "source": "Like references, function pointers are, among other things, assumed to not be null, so if you want to pass a function pointer over FFI and be able to accommodate null pointers, make your type [`Option<fn()>`](core::option#options-and-pointers-nullable-pointers) with your required signature.",
        "suggest": "像引用一样，函数指针被假定为不为空，所以如果您想通过 FFI 传递函数指针并能够容纳空指针，请使用所需的签名来创建类型 [`Option<fn()>`](core::option#options-and-pointers-nullable-pointers)。",
        "translate": ""
    },
    {
        "source": "Lint rustdoc::broken_intra_doc_links is allowed as `slice::sort_by_key` is in crate `alloc`, and as such doesn't exists yet when building `core`:",
        "suggest": "Lint rustdoc::broken_intra_doc_links 是允许的，因为 `slice::sort_by_key` 在 `alloc` crate 中，因此在构建 `core` 时还不存在:",
        "translate": ""
    },
    {
        "source": "This breaks links when slice is displayed in core, but changing it to use relative links would break when the item is re-exported.",
        "suggest": "当切片显示在核心中时，这会断开链接，但将其更改为使用相对链接会在项目重新导出时断开。",
        "translate": ""
    },
    {
        "source": "So allow the core links to be broken for now.",
        "suggest": "所以现在允许核心链接被破坏。",
        "translate": ""
    },
    {
        "source": "Creates an empty span pointing to directly before this span.",
        "suggest": "创建一个直接指向此跨度之前的空跨度。",
        "translate": ""
    },
    {
        "source": "Creates an empty span pointing to directly after this span.",
        "suggest": "创建一个直接指向此跨度之后的空跨度。",
        "translate": ""
    },
    {
        "source": "Of particular interest to collections is the `rev` adapter, which reverses any iterator that supports this operation.",
        "suggest": "集合特别感兴趣的是 `rev` 适配器，它反转支持此操作的任何迭代器。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into an owned [`Cow`] without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`CString`] 转换为拥有所有权的 [`Cow`]。",
        "translate": ""
    },
    {
        "source": "Converts a [`CStr`] into a borrowed [`Cow`] without copying or allocating.",
        "suggest": "将 [`CStr`] 转换为借用的 [`Cow`]，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts a `&`[`CString`] into a borrowed [`Cow`] without copying or allocating.",
        "suggest": "将 `&`[`CString`] 转换为借用的 [`Cow`]，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "This method is primarily used to interface with the [`format_args!()`] macro, and it is rare that this should explicitly be called.",
        "suggest": "此方法主要用于与 [`format_args!()`] 宏接口，很少需要显式调用。",
        "translate": ""
    },
    {
        "source": "breaks from inner loop, lets outer loop continue.",
        "suggest": "从内循环中断，让外循环继续。",
        "translate": ""
    },
    {
        "source": "Compile-time constants, compile-time evaluable functions, and raw pointers.",
        "suggest": "编译时常量、编译时可评估函数和裸指针。",
        "translate": ""
    },
    {
        "source": "On certain platforms right now the \"main modules\" modules that are documented don't compile (missing things in `libc` which is empty), so just omit them with an empty module and add the \"unstable\" attribute.",
        "suggest": "现在在某些平台上，已记录的 \"main modules\" 模块无法编译 (`libc` 中缺少空的内容)，因此只需使用空模块省略它们并添加 \"unstable\" 属性即可。",
        "translate": ""
    },
    {
        "source": "linux, wasi and windows are handled a bit differently.",
        "suggest": "linux、wasi 和 windows 的处理方式略有不同。",
        "translate": ""
    },
    {
        "source": "Creates a new symlink to a non-directory file on the filesystem.",
        "suggest": "创建指向文件系统上非目录文件的新符号链接。",
        "translate": ""
    },
    {
        "source": "The `original` path should not be a directory or a symlink to a directory, otherwise the symlink will be broken.",
        "suggest": "`original` 路径不应是目录或指向目录的符号链接，否则符号链接将被破坏。",
        "translate": ""
    },
    {
        "source": "Use [`symlink_dir`] for directories.",
        "suggest": "对目录使用 [`symlink_dir`]。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to [`CreateSymbolicLinkW`][CreateSymbolicLinkW].",
        "suggest": "该函数目前对应 [`CreateSymbolicLinkW`][CreateSymbolicLinkW]。",
        "translate": ""
    },
    {
        "source": "Note that this [may change in the future][changes].",
        "suggest": "注意这个 [将来可能会发生变化][changes]。",
        "translate": ""
    },
    {
        "source": "Creates a new symlink to a directory on the filesystem.",
        "suggest": "创建一个指向文件系统目录的新符号链接。",
        "translate": ""
    },
    {
        "source": "The `original` path must be a directory or a symlink to a directory, otherwise the symlink will be broken.",
        "suggest": "`original` 路径必须是目录或指向目录的符号链接，否则符号链接将被破坏。",
        "translate": ""
    },
    {
        "source": "Use [`symlink_file`] for other files.",
        "suggest": "对其他文件使用 [`symlink_file`]。",
        "translate": ""
    },
    {
        "source": "Use `panic_str` instead of `panic_display::<&str>` for non_fmt_panic lint.",
        "suggest": "对于 non_fmt_panic lint，使用 `panic_str` 而不是 `panic_display::<&str>`。",
        "translate": ""
    },
    {
        "source": "Special-case the single-argument case for const_panic.",
        "suggest": "特殊情况下 const_panic 的单个参数情况。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`TcpListener::into_incoming`] method.",
        "suggest": "这个 `struct` 是由 [`TcpListener::into_incoming`] 方法创建的。",
        "translate": ""
    },
    {
        "source": "Turn this into an iterator over the connections being received on this listener.",
        "suggest": "在此侦听器上接收到的连接上将其转换为迭代器。",
        "translate": ""
    },
    {
        "source": "Change the owner and group of the specified path.",
        "suggest": "更改指定路径的所有者和组。",
        "translate": ""
    },
    {
        "source": "Specifying either the uid or gid as `None` will leave it unchanged.",
        "suggest": "将 uid 或 gid 指定为 `None` 将保持不变。",
        "translate": ""
    },
    {
        "source": "Changing the owner typically requires privileges, such as root or a specific capability.",
        "suggest": "更改所有者通常需要特权，例如 root 或特定功能。",
        "translate": ""
    },
    {
        "source": "Changing the group typically requires either being the owner and a member of the group, or having privileges.",
        "suggest": "更改组通常需要成为组的所有者和成员，或者具有特权。",
        "translate": ""
    },
    {
        "source": "If called on a symbolic link, this will change the owner and group of the link target.",
        "suggest": "如果在符号链接上调用，这将更改链接目标的所有者和组。",
        "translate": ""
    },
    {
        "source": "To change the owner and group of the link itself, see [`lchown`].",
        "suggest": "要更改链接本身的所有者和组，请参见 [`lchown`]。",
        "translate": ""
    },
    {
        "source": "Change the owner and group of the file referenced by the specified open file descriptor.",
        "suggest": "更改指定打开文件描述符引用的文件的所有者和组。",
        "translate": ""
    },
    {
        "source": "For semantics and required privileges, see [`chown`].",
        "suggest": "有关语义和所需权限，请参见 [`chown`]。",
        "translate": ""
    },
    {
        "source": "Change the owner and group of the specified path, without dereferencing symbolic links.",
        "suggest": "更改指定路径的所有者和组，无需解引用符号链接。",
        "translate": ""
    },
    {
        "source": "Identical to [`chown`], except that if called on a symbolic link, this will change the owner and group of the link itself rather than the owner and group of the link target.",
        "suggest": "与 [`chown`] 相同，除了如果在符号链接上调用，这将更改链接本身的所有者和组，而不是链接目标的所有者和组。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing four `poly64x1_t` vectors.",
        "suggest": "包含四个 `poly64x1_t` vectors 的 ARM 特定类型。",
        "translate": ""
    },
    {
        "source": "ARM-specific type containing four `poly64x2_t` vectors.",
        "suggest": "包含四个 `poly64x2_t` vectors 的 ARM 特定类型。",
        "translate": ""
    },
    {
        "source": "A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an *O*(*n* * log(*n*)) in-place heapsort.",
        "suggest": "二元堆也可以就地转换为已排序的 vector，允许它用于 *O*(*n* * log(*n*)) 就地堆排序。",
        "translate": ""
    },
    {
        "source": "It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the [`Ord`] trait, changes while it is in the heap.",
        "suggest": "项的修改方式是一个逻辑错误，即项相对于任何其他项的排序 (由 [`Ord`] trait 确定) 在它在堆中时发生变化。",
        "translate": ""
    },
    {
        "source": "Either [`core::cmp::Reverse`] or a custom [`Ord`] implementation can be used to make `BinaryHeap` a min-heap.",
        "suggest": "[`core::cmp::Reverse`] 或自定义 [`Ord`] 实现可用于使 `BinaryHeap` 成为最小堆。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by [`BinaryHeap::into_iter()`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 由 [`BinaryHeap::into_iter()`] 创建 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`BTreeMap`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 是通过 [`BTreeMap`] 上的 [`into_iter`] 方法创建的 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`BTreeSet`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 是通过 [`BTreeSet`] 上的 [`into_iter`] 方法创建的 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`LinkedList`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 是通过 [`LinkedList`] 上的 [`into_iter`] 方法创建的 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`VecDeque`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 是通过 [`VecDeque`] 上的 [`into_iter`] 方法创建的 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "Additionally, the return value of this function is [`fmt::Result`] which is a type alias of <code>[Result]<(), [std::fmt::Error]></code>.",
        "suggest": "此外，该函数的返回值是 [`fmt::Result`]，它是 <code>[Result]<(), [std::fmt::Error]></code> 的类型别名。",
        "translate": ""
    },
    {
        "source": "Result \"fmt::Result\"",
        "suggest": "结果 \"fmt::Result\"",
        "translate": ""
    },
    {
        "source": "Error \"fmt::Error\"",
        "suggest": "错误 \"fmt::Error\"",
        "translate": ""
    },
    {
        "source": "Arguments \"fmt::Arguments\"",
        "suggest": "参数 \"fmt::Arguments\"",
        "translate": ""
    },
    {
        "source": "To avoid a memory leak the pointer must be converted back to an `Rc` using [`Rc::from_raw`].",
        "suggest": "为避免内存泄漏，必须使用 [`Rc::from_raw`] 将指针转换回 `Rc`。",
        "translate": ""
    },
    {
        "source": "See [`mem::transmute`] for more information on what restrictions apply in this case.",
        "suggest": "有关在这种情况下适用哪些限制的更多信息，请参见 [`mem::transmute`]。",
        "translate": ""
    },
    {
        "source": "The allocation is accessed by calling [`upgrade`] on the `Weak` pointer, which returns an <code>[Option]<[Rc]\\<T>></code>.",
        "suggest": "通过在 `Weak` 指针上调用 [`upgrade`] 来访问分配，它返回一个 <code>[Option]<[Rc]\\<T>></code>。",
        "translate": ""
    },
    {
        "source": "You can create a `String` from [a literal string][`&str`] with [`String::from`]:",
        "suggest": "您可以使用 [`String::from`] 从一个 [字符串字面量][`&str`] 创建一个 `String`:",
        "translate": ""
    },
    {
        "source": "implements <code>[Deref]<Target = [str]></code>, and so inherits all of [`str`]'s methods.",
        "suggest": "实现 <code>[Deref]<Target = [str]></code>，因此继承了 [`str`] 的所有方法。",
        "translate": ""
    },
    {
        "source": "In this case we are dereferencing a `String` to a [`str`], then referencing the [`str`] back to [`&str`].",
        "suggest": "在这种情况下，我们将 `String` 解引用到 [`str`]，然后将 [`str`] 引用回 [`&str`]。",
        "translate": ""
    },
    {
        "source": "Converts this `String` into a <code>[Box]<[str]></code>.",
        "suggest": "将此 `String` 转换为 <code>[Box]<[str]></code>。",
        "translate": ""
    },
    {
        "source": "Consider <code>Arc<[RefCell\\<T>]></code>.",
        "suggest": "考虑 <code>Arc<[RefCell\\<T>]></code>。",
        "translate": ""
    },
    {
        "source": "isn't [`Sync`], and if `Arc<T>` was always [`Send`], <code>Arc<[RefCell\\<T>]></code> would be as well.",
        "suggest": "不是 [`Sync`]，如果 `Arc<T>` 总是 [`Send`]，则 <code>Arc<[RefCell\\<T>]></code> 也是。",
        "translate": ""
    },
    {
        "source": "The allocation is accessed by calling [`upgrade`] on the `Weak` pointer, which returns an <code>[Option]<[Arc]\\<T>></code>.",
        "suggest": "通过在 `Weak` 指针上调用 [`upgrade`] 来访问分配，它返回一个 <code>[Option]<[Arc]\\<T>></code>。",
        "translate": ""
    },
    {
        "source": "Vectors have *O*(1) indexing, amortized *O*(1) push (to the end) and *O*(1) pop (from the end).",
        "suggest": "Vectors 有 *O*(1) 索引，摊销 *O*(1) push (到最后) 和 *O*(1) pop (从最后)。",
        "translate": ""
    },
    {
        "source": "will allocate if and only if <code>[mem::size_of::\\<T>]\\() * [capacity]\\() > 0</code>.",
        "suggest": "仅当 <code>[mem::size_of::\\<T>]\\() * [capacity]\\() > 0</code> 时，才会分配。",
        "translate": ""
    },
    {
        "source": "In general, `Vec`'s allocation details are very subtle --- if you intend to allocate memory using a `Vec` and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using `from_raw_parts` to recover the `Vec` and then dropping it.",
        "suggest": "一般来说，`Vec` 的分配细节非常微妙 -- 如果您打算使用 `Vec` 分配内存并将其用于其他用途 (或者传递给不安全的代码，或者构建您自己的内存支持集合)，请务必使用 `from_raw_parts` 处理此内存以恢复 `Vec`，然后丢弃它来释放此内存。",
        "translate": ""
    },
    {
        "source": "If a `Vec` *has* allocated memory, then the memory it points to is on the heap (as defined by the allocator Rust is configured to use by default), and its pointer points to [`len`] initialized, contiguous elements in order (what you would see if you coerced it to a slice), followed by <code>[capacity] - [len]</code> logically uninitialized, contiguous elements.",
        "suggest": "如果一个 `Vec` 已分配了内存，那么它指向的内存在堆上（由分配器定义，Rust 被配置为默认使用），它的指针按顺序指向 [`len`] 个已初始化的连续元素（如果将其强制转换为切片，您会看到什么），然后是 <code>[capacity] - [len]</code> 逻辑上未初始化的连续元素。",
        "translate": ""
    },
    {
        "source": "[`push`] and [`insert`] *will* (re)allocate if <code>[len] == [capacity]</code>. That is, the reported capacity is completely accurate, and can be relied on.",
        "suggest": "[`push`] 和 [`insert`] 将在 <code>[len] == [capacity]</code> 时 (重新) 分配。也就是说，报告的容量是完全准确的，并且是可以依赖的。",
        "translate": ""
    },
    {
        "source": "If <code>[len] == [capacity]</code>, (as is the case for the [`vec!`] macro), then a `Vec<T>` can be converted to and from a [`Box<[T]>`][owned slice] without reallocating or moving the elements.",
        "suggest": "如果 <code>[len] == [capacity]</code>，(如 [`vec!`] 宏的情况)，则 `Vec<T>` 可以与 [`Box<[T]>`][owned slice] 相互转换，而无需重新分配或移动元素。",
        "translate": ""
    },
    {
        "source": "This struct represents the unsafety of constructing an `Arguments`.",
        "suggest": "这个结构体代表了构建 `Arguments` 的不安全性。",
        "translate": ""
    },
    {
        "source": "It exists, rather than an unsafe function, in order to simplify the expansion of `format_args!(..)` and reduce the scope of the `unsafe` block.",
        "suggest": "它的存在，而不是一个不安全的函数，是为了简化 `format_args!(..)` 的扩展，并缩小 `unsafe` 块的作用域。",
        "translate": ""
    },
    {
        "source": "See documentation where `UnsafeArg` is required to know when it is safe to create and use `UnsafeArg`.",
        "suggest": "请参见 `UnsafeArg` 的文档，需要知道何时可以安全地创建和使用 `UnsafeArg`。",
        "translate": ""
    },
    {
        "source": "An `UnsafeArg` is required because the following invariants must be held in order for this function to be safe:",
        "suggest": "`UnsafeArg` 是必需的，因为必须保持以下不可变变量才能使此函数安全:",
        "translate": ""
    },
    {
        "source": "The `pieces` slice must be at least as long as `fmt`.",
        "suggest": "`pieces` 必须至少与 `fmt` 一样长。",
        "translate": ""
    },
    {
        "source": "Every [`rt::v1::Argument::position`] value within `fmt` must be a valid index of `args`.",
        "suggest": "`fmt` 中的每个 [`rt::v1::Argument::position`] 值都必须是 `args` 的有效索引。",
        "translate": ""
    },
    {
        "source": "Every [`Count::Param`] within `fmt` must contain a valid index of `args`.",
        "suggest": "`fmt` 中的每个 [`Count::Param`] 都必须包含一个有效的 `args` 索引。",
        "translate": ""
    },
    {
        "source": "An iterator has a method, [`next`], which when called, returns an <code>[Option]\\<Item></code>.",
        "suggest": "迭代器有一个方法 [`next`]，当调用它时，返回一个 <code>[Option]\\<Item></code>.",
        "translate": ""
    },
    {
        "source": "Calling [`next`] will return [`Some(Item)`] as long as there are elements, and once they've all been exhausted, will return `None` to indicate that iteration is finished.",
        "suggest": "只要有元素，调用 [`next`] 就会返回 [`Some(Item)`]，一旦它们全部消费完，将返回 `None` 表示迭代完成。",
        "translate": ""
    },
    {
        "source": "The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.",
        "suggest": "返回的元组的后半部分是 <code>[Option]<[usize]></code>。",
        "translate": ""
    },
    {
        "source": "The default implementation returns <code>(0, [None])</code> which is correct for any iterator.",
        "suggest": "默认实现返回 <code>(0, [None])</code> 这对于任何迭代器都是正确的。",
        "translate": ""
    },
    {
        "source": "Time complexity: *O*(*n*)",
        "suggest": "时间复杂度: *O*(*n*)",
        "translate": ""
    },
    {
        "source": "Avoid inlining the initialization closure into the common path that fetches the already initialized value",
        "suggest": "避免将初始化闭包内联到获取已初始化值的公共路径中",
        "translate": ""
    },
    {
        "source": "Instead, Rust has *optional* pointers, like the optional owned box, <code>[Option]<[Box\\<T>]></code>.",
        "suggest": "相反，Rust 有 *optional* 指针，就像可选的拥有所有权的 box，<code>[Option]<[Box\\<T>]></code>。",
        "translate": ""
    },
    {
        "source": "converts from <code>[&][][Option]\\<T></code> to <code>[Option]<[&]T></code>",
        "suggest": "转换自 <code>[&][][Option]\\<T></code> to <code>[Option]<[&]T></code>",
        "translate": ""
    },
    {
        "source": "converts from <code>[&mut] [Option]\\<T></code> to <code>[Option]<[&mut] T></code>",
        "suggest": "转换自 <code>[&mut] [Option]\\<T></code> to <code>[Option]<[&mut] T></code>",
        "translate": ""
    },
    {
        "source": "converts from <code>[&][][Option]\\<T></code> to <code>[Option]<[&]T::[Target]></code>",
        "suggest": "转换自 <code>[&][][Option]\\<T></code> to <code>[Option]<[&]T::[Target]></code>",
        "translate": ""
    },
    {
        "source": "converts from <code>[&mut] [Option]\\<T></code> to <code>[Option]<[&mut] T::[Target]></code>",
        "suggest": "转换自 <code>[&mut] [Option]\\<T></code> to <code>[Option]<[&mut] T::[Target]></code>",
        "translate": ""
    },
    {
        "source": "converts from <code>[Pin]<[&][][Option]\\<T>></code> to <code>[Option]<[Pin]<[&]T>></code>",
        "suggest": "转换自 <code>[Pin]<[&][][Option]\\<T>></code> to <code>[Option]<[Pin]<[&]T>></code>",
        "translate": ""
    },
    {
        "source": "converts from <code>[Pin]<[&mut] [Option]\\<T>></code> to <code>[Option]<[Pin]<[&mut] T>></code>",
        "suggest": "从 <code>[Pin]<[&mut] [Option]\\<T>></code> to <code>[Option]<[Pin]<[&mut] T>></code>",
        "translate": ""
    },
    {
        "source": "reference \"shared reference\"",
        "suggest": "参考 \"共享引用\"",
        "translate": ""
    },
    {
        "source": "reference \"mutable reference\"",
        "suggest": "参考 \"可变引用\"",
        "translate": ""
    },
    {
        "source": "Converts an <code>Option<[String]></code> into an <code>Option<[usize]></code>, preserving the original.",
        "suggest": "将 <code>Option<[String]></code> 转换为 <code>Option<[usize]></code>，保留原始值。",
        "translate": ""
    },
    {
        "source": "Converts from <code>[Pin]<[&]Option\\<T>></code> to <code>Option<[Pin]<[&]T>></code>.",
        "suggest": "从 <code>[Pin]<[&]Option\\<T>></code> 到 <code>Option<[Pin]<[&]T>></code>。",
        "translate": ""
    },
    {
        "source": "Converts from <code>[Pin]<[&mut] Option\\<T>></code> to <code>Option<[Pin]<[&mut] T>></code>.",
        "suggest": "转换自 <code>[Pin]<[&mut] Option\\<T>></code> 到 <code>Option<[Pin]<[&mut] T>></code>。",
        "translate": ""
    },
    {
        "source": "Converts an <code>Option<[String]></code> into an <code>Option<[usize]></code>, consuming the original:",
        "suggest": "将 <code>Option<[String]></code> 转换为 <code>Option<[usize]></code>，使用原始值:",
        "translate": ""
    },
    {
        "source": "will be mapped to <code>[Ok]\\([None])</code>.",
        "suggest": "将被映射到 <code>[Ok]\\([None])</code>。",
        "translate": ""
    },
    {
        "source": "<code>[Some]\\([Ok]\\(\\_))</code> and <code>[Some]\\([Err]\\(\\_))</code> will be mapped to <code>[Ok]\\([Some]\\(\\_))</code> and <code>[Err]\\(\\_)</code>.",
        "suggest": "<code>[Some]\\([Ok]\\(\\_))</code> 和 <code>[Some]\\([Err]\\(\\_))</code> 将映射到 <code>[Ok]\\([Some]\\(\\_))</code> 和 <code>[Err]\\(\\_)</code>。",
        "translate": ""
    },
    {
        "source": "Converts an <code>[Option]<[String]></code> into an <code>[Option]<[usize]></code>, preserving the original.",
        "suggest": "将 <code>[Option]<[String]></code> 转换为 <code>[Option]<[usize]></code>，保留原始值。",
        "translate": ""
    },
    {
        "source": "The [`map`] method takes the `self` argument by value, consuming the original, so this technique uses `from` to first take an [`Option`] to a reference to the value inside the original.",
        "suggest": "[`map`] 方法按值取 `self` 参数，消耗原始值，因此该技术使用 `from` 首先将 [`Option`] 用于对原始值内部值的引用。",
        "translate": ""
    },
    {
        "source": "The actual definition of [`Write`] uses [`io::Result`], which is just a synonym for <code>[Result]<T, [io::Error]></code>.",
        "suggest": "[`Write`] 的实际定义使用了 [`io::Result`]，它只是 <code>[Result]<T, [io::Error]></code> 的同义词。",
        "translate": ""
    },
    {
        "source": "The default implementation returns <code>(0, [None])</code> which is correct for any stream.",
        "suggest": "默认实现返回了 <code>(0, [None])</code>，这对于任何流都是正确的。",
        "translate": ""
    },
    {
        "source": "Converts a <code>Poll<[String]></code> into a <code>Poll<[usize]></code>, consuming the original:",
        "suggest": "将 <code>Poll<[String]></code> 转换为 <code>Poll<[usize]></code>，消耗原始值:",
        "translate": ""
    },
    {
        "source": "A prefix and postfix may be added.",
        "suggest": "可以添加前缀和后缀。",
        "translate": ""
    },
    {
        "source": "The whole thing is padded to the formatter's `width`, if specified.",
        "suggest": "如果指定，整个内容都填充到格式化程序的 `width` 中。",
        "translate": ""
    },
    {
        "source": "This closure emits the formatted duration without emitting any padding (padding is calculated below).",
        "suggest": "这个闭包发出格式化的持续时间而不发出任何填充 (填充计算如下)。",
        "translate": ""
    },
    {
        "source": "Write the decimal point and the fractional part (if any).",
        "suggest": "写出小数点和小数部分 (如果有)。",
        "translate": ""
    },
    {
        "source": "No `width` specified.",
        "suggest": "未指定 `width`。",
        "translate": ""
    },
    {
        "source": "There's no need to calculate the length of the output in this case, just emit it.",
        "suggest": "在这种情况下，不需要计算输出的长度，只需发出它。",
        "translate": ""
    },
    {
        "source": "A `width` was specified.",
        "suggest": "指定了 `width`。",
        "translate": ""
    },
    {
        "source": "Calculate the actual width of the output in order to calculate the required padding.",
        "suggest": "计算输出的实际宽度，以便计算所需的填充。",
        "translate": ""
    },
    {
        "source": "It consists of 4 parts:",
        "suggest": "它由 4 个部分组成:",
        "translate": ""
    },
    {
        "source": "The prefix: is either \"+\" or \"\", so we can just use len().",
        "suggest": "前缀：是 \"+\" 或 \"\"，所以我们可以只使用 len()。",
        "translate": ""
    },
    {
        "source": "The postfix: can be \"µs\" so we have to count UTF8 characters.",
        "suggest": "后缀：可以是 \"µs\" 所以我们必须计算 UTF8 字符。",
        "translate": ""
    },
    {
        "source": "The integer part:",
        "suggest": "整数部分:",
        "translate": ""
    },
    {
        "source": "integer_part is > 0, so has length log10(x)+1",
        "suggest": "integer_part 是 > 0 的，所以长度是 log10(x)+1",
        "translate": ""
    },
    {
        "source": "integer_part is 0, so has length 1.",
        "suggest": "integer_part 为 0，因此长度为 1。",
        "translate": ""
    },
    {
        "source": "The fractional part (if any):",
        "suggest": "小数部分 (如果有) :",
        "translate": ""
    },
    {
        "source": "Output is already longer than `width`, so don't pad.",
        "suggest": "输出已经比 `width` 长，所以不要填充。",
        "translate": ""
    },
    {
        "source": "We need to add padding.",
        "suggest": "我们需要添加填充。",
        "translate": ""
    },
    {
        "source": "Use the `Formatter::padding` helper function.",
        "suggest": "使用 `Formatter::padding` 帮助函数。",
        "translate": ""
    },
    {
        "source": "default alignment is left:",
        "suggest": "默认对齐方式为左对齐:",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`HashMap`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 是通过 [`HashMap`] 上的 [`into_iter`] 方法创建的 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "This `struct` is created by the [`into_iter`] method on [`HashSet`] (provided by the [`IntoIterator`] trait).",
        "suggest": "这个 `struct` 是通过 [`HashSet`] 上的 [`into_iter`] 方法创建的 (由 [`IntoIterator`] trait 提供)。",
        "translate": ""
    },
    {
        "source": "automatically calls `into_iter`, and takes any <code>T: [IntoIterator]</code>.",
        "suggest": "自动调用 `into_iter`，并接受任何 <code>T: [IntoIterator]</code>。",
        "translate": ""
    },
    {
        "source": "is to <code>&[CStr]</code> as [`String`] is to <code>&[str]</code>: the former in each pair are owned strings;",
        "suggest": "对 <code>&[CStr]</code> 就像 [`String`] 对 <code>&[str]</code> 一样：每对中的前者是拥有所有权的字符串;",
        "translate": ""
    },
    {
        "source": "A `CString` is created from either a byte slice or a byte vector, or anything that implements <code>[Into]<[Vec]<[u8]>></code> (for example, you can build a `CString` straight out of a [`String`] or a <code>&[str]</code>, since both implement that trait).",
        "suggest": "`CString` 是从字节切片、字节 vector 或任何实现 <code>[Into]<[Vec]<[u8]>></code> 创建的 (例如，您可以直接从 [`String`] 或 <code>&[str]</code>，因为两者都实现了该 trait)。",
        "translate": ""
    },
    {
        "source": "The [`CString::new`] method will actually check that the provided <code>&[[u8]]</code> does not have 0 bytes in the middle, and return an error if it finds one.",
        "suggest": "[`CString::new`] 方法实际上会检查提供的 <code>&[[u8]]</code> 中是否没有 0 个字节，如果找到一个，将返回一个错误。",
        "translate": ""
    },
    {
        "source": "Alternatively, you can obtain a <code>&[[u8]]</code> slice from a `CString` with the [`CString::as_bytes`] method.",
        "suggest": "或者，您可以使用 [`CString::as_bytes`] 方法从 `CString` 获取 <code>&[[u8]]</code> 切片。",
        "translate": ""
    },
    {
        "source": "If you need a <code>&[[u8]]</code> slice *with* the nul terminator, you can use [`CString::as_bytes_with_nul`] instead.",
        "suggest": "如果您需要一个带 nul 终止符的 <code>&[[u8]]</code> 切片，您可以使用 [`CString::as_bytes_with_nul`] 代替。",
        "translate": ""
    },
    {
        "source": "It can be constructed safely from a <code>&[[u8]]</code> slice, or unsafely from a raw `*const c_char`.",
        "suggest": "它可以从一个 <code>&[[u8]]</code> 切片安全地构建，或者从原始 `*const c_char` 不安全地构建。",
        "translate": ""
    },
    {
        "source": "It can then be converted to a Rust <code>&[str]</code> by performing UTF-8 validation, or into an owned [`CString`].",
        "suggest": "然后可以通过执行 UTF-8 验证将其转换为 Rust <code>&[str]</code>，或转换为拥有所有权的 [`CString`]。",
        "translate": ""
    },
    {
        "source": "is to [`CString`] as <code>&[str]</code> is to [`String`]: the former in each pair are borrowed references;",
        "suggest": "对 [`CString`] 就像 <code>&[str]</code> 对 [`String`] 一样：每对中的前者都是借用的引用;",
        "translate": ""
    },
    {
        "source": "Converts a <code>[Vec]<[u8]></code> to a [`CString`] without checking the invariants on the given [`Vec`].",
        "suggest": "将 <code>[Vec]<[u8]></code> 转换为 [`CString`]，而不检查给定的 [`Vec`] 上的不可变变量。",
        "translate": ""
    },
    {
        "source": "Attempts to converts a <code>[Vec]<[u8]></code> to a [`CString`].",
        "suggest": "尝试将 <code>[Vec]<[u8]></code> 转换为 [`CString`]。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into a <code>[Vec]<[u8]></code>.",
        "suggest": "将 [`CString`] 转换为 <code>[Vec]<[u8]></code>。",
        "translate": ""
    },
    {
        "source": "Converts a <code>[Box]<[CStr]></code> into a [`CString`] without copying or allocating.",
        "suggest": "将 <code>[Box]<[CStr]></code> 转换为 [`CString`]，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts a <code>[Vec]<[NonZeroU8]></code> into a [`CString`] without copying nor checking for inner null bytes.",
        "suggest": "将 <code>[Vec]<[NonZeroU8]></code> 转换为 [`CString`]，无需复制或检查内部空字节。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into a <code>[Box]<[CStr]></code> without copying or allocating.",
        "suggest": "将 [`CString`] 转换为 <code>[Box]<[CStr]></code>，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into an <code>[Arc]<[CStr]></code> without copying or allocating.",
        "suggest": "将 [`CString`] 转换为 <code>[Arc]<[CStr]></code>，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into an <code>[Rc]<[CStr]></code> without copying or allocating.",
        "suggest": "将 [`CString`] 转换为 <code>[Rc]<[CStr]></code>，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Yields a <code>&[str]</code> slice if the `CStr` contains valid UTF-8.",
        "suggest": "如果 `CStr` 包含有效的 UTF-8，则产生 <code>&[str]</code> 切片。",
        "translate": ""
    },
    {
        "source": "If the contents of the `CStr` are valid UTF-8 data, this function will return the corresponding <code>&[str]</code> slice.",
        "suggest": "如果 `CStr` 的内容是有效的 UTF-8 数据，该函数将返回相应的 <code>&[str]</code> 切片。",
        "translate": ""
    },
    {
        "source": "Converts a `CStr` into a <code>[Cow]<[str]></code>.",
        "suggest": "将 `CStr` 转换为 <code>[Cow]<[str]></code>。",
        "translate": ""
    },
    {
        "source": "If the contents of the `CStr` are valid UTF-8 data, this function will return a <code>[Cow]::[Borrowed]\\(&[str])</code> with the corresponding <code>&[str]</code> slice.",
        "suggest": "如果 `CStr` 的内容是有效的 UTF-8 数据，该函数将返回一个 <code>[Cow]::[Borrowed]\\(&[str])</code> 和相应的 <code>&[str]</code> 切片。",
        "translate": ""
    },
    {
        "source": "Otherwise, it will replace any invalid UTF-8 sequences with [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a <code>[Cow]::[Owned]\\(&[str])</code> with the result.",
        "suggest": "否则，它将用 [`U+FFFD 替换字符`][U+FFFD] 替换任何无效的 UTF-8 序列，并返回 <code>[Cow]::[Owned]\\(&[str])</code> 作为结果。",
        "translate": ""
    },
    {
        "source": "While in Rust accessing a string's length is an *O*(1) operation (because the length is stored);",
        "suggest": "而在 Rust 中，访问字符串的长度是一个 *O*(1) 操作 (因为长度是被存储的) ;",
        "translate": ""
    },
    {
        "source": "in C it is an *O*(*n*) operation because the length needs to be computed by scanning the string for the nul terminator.",
        "suggest": "在 C 中，它是一个 *O*(*n*) 操作，因为需要通过扫描字符串中的 nul 终止符来计算长度。",
        "translate": ""
    },
    {
        "source": "Rust code can create a [`CString`] out of a normal string (provided that the string doesn't have nul characters in the middle), and then use a variety of methods to obtain a raw <code>\\*mut [u8]</code> that can then be passed as an argument to functions which use the C conventions for strings.",
        "suggest": "Rust 代码可以从一个普通字符串中创建一个 [`CString`] (前提是该字符串中间没有 nul 字符)，然后使用多种方法获得一个原始的 <code>\\*mut [u8]</code>，然后可以作为参数传递给使用字符串的 C 约定的函数。",
        "translate": ""
    },
    {
        "source": "it is what you would use to wrap a raw <code>\\*const [u8]</code> that you got from a C function.",
        "suggest": "它是您用来包装从 C 函数获得的原始 <code>\\*const [u8]</code> 的内容。",
        "translate": ""
    },
    {
        "source": "Once you have a [`CStr`], you can convert it to a Rust <code>&[str]</code> if it's valid UTF-8, or lossily convert it by adding replacement characters.",
        "suggest": "一旦您有了 [`CStr`]，您可以将它转换为 Rust <code>&[str]</code>，如果它是有效的 UTF-8，或者通过添加替换字符来有损地转换它。",
        "translate": ""
    },
    {
        "source": "it returns an <code>[Option]<[OsString]></code>. If the environment variable exists you will get a <code>[Some]\\(os_string)</code>, which you can *then* try to convert to a Rust string.",
        "suggest": "它返回一个 <code>[Option]<[OsString]></code>。如果环境变量存在，您将得到一个 <code>[Some]\\(os_string)</code>，您可以在那时尝试将其转换为 Rust 字符串。",
        "translate": ""
    },
    {
        "source": "On Unix, [`OsStr`] implements the <code>std::os::unix::ffi::[OsStrExt][unix.OsStrExt]</code> trait, which augments it with two methods, [`from_bytes`] and [`as_bytes`].",
        "suggest": "在 Unix 上，[`OsStr`] 实现了 <code>std::os::unix::ffi::[OsStrExt][unix.OsStrExt]</code> trait，它增加了两个方法，[`from_bytes`] 和 [`as_bytes`]。",
        "translate": ""
    },
    {
        "source": "Additionally, on Unix [`OsString`] implements the <code>std::os::unix::ffi::[OsStringExt][unix.OsStringExt]</code> trait, which provides [`from_vec`] and [`into_vec`] methods that consume their arguments, and take or produce vectors of [`u8`].",
        "suggest": "此外，在 Unix 上，[`OsString`] 实现了 <code>std::os::unix::ffi::[OsStringExt][unix.OsStringExt]</code> trait，它提供了 [`from_vec`] 和 [`into_vec`] 方法，这些方法使用它们的参数，并获取或生成 [`u8`] 的 vectors。",
        "translate": ""
    },
    {
        "source": "On Windows, [`OsStr`] implements the <code>std::os::windows::ffi::[OsStrExt][windows.OsStrExt]</code> trait, which provides an [`encode_wide`] method.",
        "suggest": "在 Windows 上，[`OsStr`] 实现了 <code>std::os::windows::ffi::[OsStrExt][windows.OsStrExt]</code> trait，它提供了一个 [`encode_wide`] 方法。",
        "translate": ""
    },
    {
        "source": "Additionally, on Windows [`OsString`] implements the <code>std::os::windows:ffi::[OsStringExt][windows.OsStringExt]</code> trait, which provides a [`from_wide`] method.",
        "suggest": "此外，在 Windows 上 [`OsString`] 实现了 <code>std::os::windows:ffi::[OsStringExt][windows.OsStringExt]</code> trait，它提供了一个 [`from_wide`] 方法。",
        "translate": ""
    },
    {
        "source": "is to <code>&[OsStr]</code> as [`String`] is to <code>&[str]</code>: the former in each pair are owned strings;",
        "suggest": "对 <code>&[OsStr]</code> 就像 [`String`] 对 <code>&[str]</code> 一样：每对中的前者是拥有所有权的字符串;",
        "translate": ""
    },
    {
        "source": "**From a Rust string**: `OsString` implements <code>[From]<[String]></code>, so you can use <code>my_string.[into]\\()</code> to create an `OsString` from a normal Rust string.",
        "suggest": "**来自 Rust 字符串**: `OsString` 实现了 <code>[From]<[String]></code>，因此您可以使用 <code>my_string.[into]\\()</code> 从普通 Rust 字符串创建 `OsString`。",
        "translate": ""
    },
    {
        "source": "**From slices:** Just like you can start with an empty Rust [`String`] and then [`String::push_str`] some <code>&[str]</code> sub-string slices into it, you can create an empty `OsString` with the [`OsString::new`] method and then push string slices into it with the [`OsString::push`] method.",
        "suggest": "**从切片: **就像您可以从一个空的 Rust [`String`] 开始，然后用 [`String::push_str`] 将一些 <code>&[str]</code> 子字符串切片放入其中一样，您也可以使用 [`OsString::new`] 方法创建一个空的 `OsString`，然后使用 [`OsString::push`] 方法将字符串切片推入其中。",
        "translate": ""
    },
    {
        "source": "You can use the [`OsString::as_os_str`] method to get an <code>&[OsStr]</code> from an `OsString`;",
        "suggest": "您可以使用 [`OsString::as_os_str`] 方法从 `OsString` 获取 <code>&[OsStr]</code> ;",
        "translate": ""
    },
    {
        "source": "is to [`OsString`] as <code>&[str]</code> is to [`String`]: the former in each pair are borrowed references;",
        "suggest": "对 [`OsString`] 就像 <code>&[str]</code> 对 [`String`] 一样：每对中的前者都是借用的引用;",
        "translate": ""
    },
    {
        "source": "Extends the string with the given <code>&[OsStr]</code> slice.",
        "suggest": "用给定的 <code>&[OsStr]</code> 切片扩展字符串。",
        "translate": ""
    },
    {
        "source": "Yields a <code>&[str]</code> slice if the `OsStr` is valid Unicode.",
        "suggest": "如果 `OsStr` 是有效的 Unicode，则产生 <code>&[str]</code>。",
        "translate": ""
    },
    {
        "source": "Converts an `OsStr` to a <code>[Cow]<[str]></code>.",
        "suggest": "将 `OsStr` 转换为 <code>[Cow]<[str]></code>。",
        "translate": ""
    },
    {
        "source": "Converts a <code>[Box]<[OsStr]></code> into an [`OsString`] without copying or allocating.",
        "suggest": "将 <code>[Box]<[OsStr]></code> 转换为 [`OsString`]，而无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts an [`OsString`] into a <code>[Box]<[OsStr]></code> without copying or allocating.",
        "suggest": "将 [`OsString`] 转换为 <code>[Box]<[OsStr]></code>，而无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts an [`OsString`] into an <code>[Arc]<[OsStr]></code> without copying or allocating.",
        "suggest": "将 [`OsString`] 转换为 <code>[Arc]<[OsStr]></code>，而无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts an [`OsString`] into an <code>[Rc]<[OsStr]></code> without copying or allocating.",
        "suggest": "将 [`OsString`] 转换为 <code>[Rc]<[OsStr]></code>，而无需复制或分配。",
        "translate": ""
    },
    {
        "source": "This iterator is returned from the [`read_dir`] function of this module and will yield instances of <code>[io::Result]<[DirEntry]></code>.",
        "suggest": "该迭代器从该模块的 [`read_dir`] 函数返回，将产生一个 <code>[io::Result]<[DirEntry]></code> 实例。",
        "translate": ""
    },
    {
        "source": "So, before writing, save the current position (using <code>[seek]\\([SeekFrom]::[Current]\\(0))</code>), and restore it before the next read.",
        "suggest": "所以，在写入之前，保存当前位置 (使用 <code>[seek]\\([SeekFrom]::[Current]\\(0))</code>)，并在下次读取之前恢复它。",
        "translate": ""
    },
    {
        "source": "The iterator will yield instances of <code>[io::Result]<[DirEntry]></code>.",
        "suggest": "迭代器将产生 <code>[io::Result]<[DirEntry]></code> 实例。",
        "translate": ""
    },
    {
        "source": "It also provides no advantage when reading from a source that is already in memory, like a <code>[Vec]\\<u8></code>.",
        "suggest": "从已经在内存中的源读取时，它也没有任何优势，例如 <code>[Vec]\\<u8></code>.",
        "translate": ""
    },
    {
        "source": "The position used for seeking with <code>[SeekFrom::Current]\\(_)</code> is the position the underlying reader would be at if the `BufReader<R>` had no internal buffer.",
        "suggest": "用于使用 <code>[SeekFrom::Current]\\(_)</code> 查找的位置是底层 reader 所在的位置，如果 `BufReader<R>` 没有内部缓冲区。",
        "translate": ""
    },
    {
        "source": "In the edge case where you're seeking with <code>[SeekFrom::Current]\\(n)</code> where `n` minus the internal buffer length overflows an `i64`, two seeks will be performed instead of one.",
        "suggest": "在 edge 情况下，您使用 <code>[SeekFrom::Current]\\(n)</code> 进行查找，其中 `n` 减去内部缓冲区长度会溢出 `i64`，将执行两次查找而不是一次查找。",
        "translate": ""
    },
    {
        "source": "If the second seek returns [`Err`], the underlying reader will be left at the same position it would have if you called `seek` with <code>[SeekFrom::Current]\\(0)</code>.",
        "suggest": "如果第二个 seek 返回 [`Err`]，则底层 reader 将保留在与使用 <code>[SeekFrom::Current]\\(0)</code> 调用 `seek` 时相同的位置。",
        "translate": ""
    },
    {
        "source": "It also provides no advantage when writing to a destination that is in memory, like a <code>[Vec]\\<u8></code>.",
        "suggest": "在写入内存中的目标时，它也没有提供任何优势，例如 <code>[Vec]\\<u8></code>.",
        "translate": ""
    },
    {
        "source": "`Cursor`s are used with in-memory buffers, anything implementing <code>[AsRef]<\\[u8]></code>, to allow them to implement [`Read`] and/or [`Write`], allowing these buffers to be used anywhere you might use a reader or writer that does actual I/O.",
        "suggest": "`Cursor`s 与内存缓冲区一起使用，任何实现 <code>[AsRef]<\\[u8]></code>，以允许它们实现 [`Read`] 或者 [`Write`]，从而允许这些缓冲区在您可能使用进行实际 I/O 的读取器或写入器的任何地方使用。",
        "translate": ""
    },
    {
        "source": "The standard library implements some I/O traits on various types which are commonly used as a buffer, like <code>Cursor<[Vec]\\<u8>></code> and <code>Cursor<[&\\[u8\\]][bytes]></code>.",
        "suggest": "标准库在通常用作缓冲区的各种类型上实现了一些 I/O traits，例如 <code>Cursor<[Vec]\\<u8>></code> and <code>Cursor<[&\\[u8\\]][bytes]></code>。",
        "translate": ""
    },
    {
        "source": "The returned type implements [`Iterator`] where the [`Item`] is <code>[Result]<[u8], [io::Error]></code>.",
        "suggest": "返回的类型实现 [`Iterator`]，其中 [`Item`] 是 <code>[Result]<[u8], [io::Error]></code>。",
        "translate": ""
    },
    {
        "source": "The iterator returned from this function will return instances of <code>[io::Result]<[Vec]\\<u8>></code>.",
        "suggest": "这个函数返回的迭代器将返回 <code>[io::Result]<[Vec]\\<u8>></code> 的实例。",
        "translate": ""
    },
    {
        "source": "The iterator returned from this function will yield instances of <code>[io::Result]<[String]></code>.",
        "suggest": "从这个函数返回的迭代器将产生 <code>[io::Result]<[String]></code> 的实例。",
        "translate": ""
    },
    {
        "source": "All reads from the returned reader will return <code>[Ok]\\(0)</code>.",
        "suggest": "从返回的读取器中读取的所有内容都将返回 <code>[Ok]\\(0)</code>。",
        "translate": ""
    },
    {
        "source": "<code>(&[str], [u16])</code>: <code>&[str]</code> should be either a string representation of an [`IpAddr`] address as expected by [`FromStr`] implementation or a host name.",
        "suggest": "<code>(&[str], [u16])</code>: <code>&[str]</code> 应该是 [`FromStr`] 实现所期望的 [`IpAddr`] 地址的字符串表示或主机名。",
        "translate": ""
    },
    {
        "source": "[`u16`] is the port number.",
        "suggest": "[`u16`] 是端口号。",
        "translate": ""
    },
    {
        "source": "<code>&[str]</code>: the string should be either a string representation of a [`SocketAddr`] as expected by its [`FromStr`] implementation or a string like `<host_name>:<port>` pair where `<port>` is a [`u16`] value.",
        "suggest": "<code>&[str]</code>: 该字符串应该是 [`SocketAddr`] 的字符串表示形式，正如其 [`FromStr`] 实现所期望的那样，或者是像 `<host_name>:<port>` 这样的字符串，其中 `<port>` 是一个 [`u16`] 值。",
        "translate": ""
    },
    {
        "source": "Converts this object to an iterator of resolved [`SocketAddr`]s.",
        "suggest": "将此对象转换为已解析的 [`SocketAddr`] 的迭代器。",
        "translate": ""
    },
    {
        "source": "All currently blocked and future [reads] will return <code>[Ok]\\(0)</code>.",
        "suggest": "所有当前被阻止的和未来的 [reads] 将返回 <code>[Ok]\\(0)</code>。",
        "translate": ""
    },
    {
        "source": "Linux-specific extensions to primitives in the [`std::fs`] module.",
        "suggest": "[`std::fs`] 模块中原语的 Linux 特定扩展。",
        "translate": ""
    },
    {
        "source": "Linux-specific extensions to primitives in the [`std::process`] module.",
        "suggest": "[`std::process`] 模块中原语的 Linux 特定扩展。",
        "translate": ""
    },
    {
        "source": "On modern architectures this type will always be either [`i8`] or [`u8`], as they use byte-addresses memory with 8-bit bytes.",
        "suggest": "在现代体系结构中，这种类型将始终是 [`i8`] 或 [`u8`]，因为它们使用具有 8 位字节的字节地址内存。",
        "translate": ""
    },
    {
        "source": "Unix-specific extensions to primitives in the [`std::ffi`] module.",
        "suggest": "[`std::ffi`] 模块中原语的 Unix 特定扩展。",
        "translate": ""
    },
    {
        "source": "Unix-specific extensions to primitives in the [`std::fs`] module.",
        "suggest": "[`std::fs`] 模块中原语的 Unix 特定扩展。",
        "translate": ""
    },
    {
        "source": "It exposes more ways to deal with platform-specific strings ([`OsStr`], [`OsString`]), allows to set permissions more granularly, extract low-level file descriptors from files and sockets, and has platform-specific helpers for spawning processes.",
        "suggest": "它公开了更多处理特定平台字符串的方法 ([`OsStr`]，[`OsString`])，允许更精细地设置权限，从文件和套接字中提取低级文件描述符，并具有特定于平台的帮助程序来生成进程。",
        "translate": ""
    },
    {
        "source": "Unix-specific networking functionality.",
        "suggest": "Unix 特定的网络功能。",
        "translate": ""
    },
    {
        "source": "Unix-specific extensions to primitives in the [`std::process`] module.",
        "suggest": "[`std::process`] 模块中原语的 Unix 特定扩展。",
        "translate": ""
    },
    {
        "source": "Unix-specific extensions to primitives in the [`std::thread`] module.",
        "suggest": "[`std::thread`] 模块中原语的 Unix 特定扩展。",
        "translate": ""
    },
    {
        "source": "WASI-specific extensions to primitives in the [`std::ffi`] module",
        "suggest": "[`std::ffi`] 模块中原语的 WASI 特定扩展",
        "translate": ""
    },
    {
        "source": "WASI-specific extensions to primitives in the [`std::fs`] module.",
        "suggest": "[`std::fs`] 模块中原语的 WASI 特定扩展。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to primitives in the [`std::ffi`] module.",
        "suggest": "[`std::ffi`] 模块中原语的 Windows 特定扩展。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to primitives in the [`std::fs`] module.",
        "suggest": "[`std::fs`] 模块中原语的 Windows 特定扩展。",
        "translate": ""
    },
    {
        "source": "use handle with native windows bindings",
        "suggest": "将句柄与本地 windows 绑定一起使用",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to primitives in the [`std::process`] module.",
        "suggest": "[`std::process`] 模块中原语的 Windows 特定扩展。",
        "translate": ""
    },
    {
        "source": "Windows-specific extensions to primitives in the [`std::thread`] module.",
        "suggest": "[`std::thread`] 模块中原语的 Windows 特定扩展。",
        "translate": ""
    },
    {
        "source": "The iterator will yield instances of <code>[io::Result]<[fs::DirEntry]></code>.",
        "suggest": "迭代器将产生一个 <code>[io::Result]<[fs::DirEntry]></code> 的实例。",
        "translate": ""
    },
    {
        "source": "The handle returned from `get_handle` must be valid and non-null.",
        "suggest": "从 `get_handle` 返回的句柄必须有效且非空。",
        "translate": ""
    },
    {
        "source": "If successful, <code>[Ok]\\([Duration])</code> is returned where the duration represents the amount of time elapsed from the specified measurement to this one.",
        "suggest": "如果成功，则返回 <code>[Ok]\\([Duration])</code>，其中持续时间表示从指定测量到此测量所经过的时间。",
        "translate": ""
    },
    {
        "source": "If successful, <code>[Ok]\\([Duration])</code> is returned where the duration represents the amount of time elapsed from this time measurement to the current time.",
        "suggest": "如果成功，则返回 <code>[Ok]\\([Duration])</code>，其中持续时间表示从这次时间测量到当前时间所经过的时间。",
        "translate": ""
    },
    {
        "source": "Even if you drop a `Vec`, its buffer may simply be reused by another allocation.",
        "suggest": "即使您丢弃了一个 `Vec`，它的缓冲区也可能会被另一个分配重用。",
        "translate": ""
    },
    {
        "source": "converts from <code>[&][][Option]\\<T></code> to",
        "suggest": "从 <code>[&][][Option]\\<T></code> 转换为",
        "translate": ""
    },
    {
        "source": "converts from <code>[&mut] [Option]\\<T></code> to",
        "suggest": "从 <code>[&mut] [Option]\\<T></code> 转换为",
        "translate": ""
    },
    {
        "source": "converts from <code>[Pin]<[&][][Option]\\<T>></code> to",
        "suggest": "从 <code>[Pin]<[&][][Option]\\<T>></code> 转换为",
        "translate": ""
    },
    {
        "source": "converts from <code>[Pin]<[&mut] [Option]\\<T>></code> to",
        "suggest": "从 <code>[Pin]<[&mut] [Option]\\<T>></code> 转换为",
        "translate": ""
    },
    {
        "source": "and <code>[Some]\\([Err]\\(\\_))</code> will be mapped to <code>[Ok]\\([Some]\\(\\_))</code> and <code>[Err]\\(\\_)</code>.",
        "suggest": "和 <code>[Some]\\([Err]\\(\\_))</code> 将映射到 <code>[Ok]\\([Some]\\(\\_))</code> 和 <code>[Err]\\(\\_)</code>。",
        "translate": ""
    },
    {
        "source": "There were the same number of elements to switch on both blocks during the last iteration, so there are no remaining elements on either block.",
        "suggest": "在上次迭代期间要在两个块上切换的元素数量相同，因此任何一个块上都没有剩余的元素。",
        "translate": ""
    },
    {
        "source": "Cover the remaining items with roughly equally-sized blocks.",
        "suggest": "用大致相同大小的块覆盖剩余的项。",
        "translate": ""
    },
    {
        "source": "while the loop condition holds there are still elements in `offsets_l`, so it is safe to point `end_l` to the previous element.",
        "suggest": "当循环条件成立时 `offsets_l` 中仍有元素，因此将 `end_l` 指向前一个元素是安全的。",
        "translate": ""
    },
    {
        "source": "The `ptr::swap` is safe if both its arguments are valid for reads and writes:",
        "suggest": "如果 `ptr::swap` 的参数对读和写都有效，则它是安全的:",
        "translate": ""
    },
    {
        "source": "Per the debug assert above, the distance between `l` and `r` is `block_l` elements, so there can be at most `block_l` remaining offsets between `start_l` and `end_l`.",
        "suggest": "根据上面的调试断言，`l` 和 `r` 之间的距离是 `block_l` 元素，因此 `start_l` 和 `end_l` 之间最多可以有 `block_l` 剩余偏移量。",
        "translate": ""
    },
    {
        "source": "This means `r` will be moved at most `block_l` steps back, which makes the `r.offset` calls valid (at that point `l == r`).",
        "suggest": "这意味着 `r` 最多将向后移动 `block_l` 步，这使得 `r.offset` 调用有效 (在那个时候 `l == r`)。",
        "translate": ""
    },
    {
        "source": "contains valid offsets into `v` collected during the partitioning of the last block, so the `l.offset` calls are valid.",
        "suggest": "包含在最后一个块的分区过程中收集到的 `v` 的有效偏移量，因此 `l.offset` 调用是有效的。",
        "translate": ""
    },
    {
        "source": "See the reasoning in [remaining-elements-safety].",
        "suggest": "请参见 [剩余元素安全][remaining-elements-safety] 中的推理。",
        "translate": ""
    },
    {
        "source": "`pivot` is a reference to the first element of `v`, so `ptr::read` is safe.",
        "suggest": "`pivot` 是对 `v` 第一个元素的引用，所以 `ptr::read` 是安全的。",
        "translate": ""
    },
    {
        "source": "`len >= 8` so there are at least two elements in the neighborhoods of `a`, `b` and `c`.",
        "suggest": "`len >= 8` 所以在 `a`、`b` 和 `c` 的邻域中至少有两个元素。",
        "translate": ""
    },
    {
        "source": "This means the three calls to `sort_adjacent` result in corresponding calls to `sort3` with valid 3-item neighborhoods around each pointer, which in turn means the calls to `sort2` are done with valid references.",
        "suggest": "这意味着对 `sort_adjacent` 的三个调用导致对 `sort3` 的相应调用以及每个指针周围的有效 3 项邻域，这反过来意味着对 `sort2` 的调用是通过有效的引用完成的。",
        "translate": ""
    },
    {
        "source": "Thus the `v.get_unchecked` calls are safe, as is the `ptr::swap` call.",
        "suggest": "因此 `v.get_unchecked` 调用是安全的，`ptr::swap` 调用也是安全的。",
        "translate": ""
    },
    {
        "source": "Trailing 0 byte will be appended by this function.",
        "suggest": "该函数将追加尾随的 0 字节。",
        "translate": ""
    },
    {
        "source": "Additionally, on Windows [`OsString`] implements the",
        "suggest": "此外，在 Windows 上 [`OsString`] 实现了",
        "translate": ""
    },
    {
        "source": "trait, which provides a [`from_wide`] method.",
        "suggest": "trait，它提供了一个 [`from_wide`] 方法。",
        "translate": ""
    },
    {
        "source": "<code>&[str]</code> should be either a string representation of an [`IpAddr`] address as expected by [`FromStr`] implementation or a host name.",
        "suggest": "<code>&[str]</code> 应该是 [`FromStr`] 实现所期望的 [`IpAddr`] 地址的字符串表示形式或主机名。",
        "translate": ""
    },
    {
        "source": "SOLID-specific extension to the primitives in the `std::ffi` module",
        "suggest": "`std::ffi` 模块中原语的 SOLID 特定扩展",
        "translate": ""
    },
    {
        "source": "SOLID-specific extensions to general I/O primitives",
        "suggest": "对通用 I/O 原语的 SOLID 特定扩展",
        "translate": ""
    },
    {
        "source": "A trait to extract the raw SOLID Sockets file descriptor from an underlying object.",
        "suggest": "从底层对象中提取原始 SOLID 套接字文件描述符的 trait。",
        "translate": ""
    },
    {
        "source": "various operations for both destructors and overloading `()`.",
        "suggest": "析构函数和重载 `()` 的各种操作。",
        "translate": ""
    },
    {
        "source": "the ubiquitous trait that defines [`clone`][Clone::clone], the method for producing a copy of a value.",
        "suggest": "定义 [`clone`][Clone::clone] 的无处不在的 trait ，即生成一个值副本的方法。",
        "translate": ""
    },
    {
        "source": "the comparison traits, which implement the comparison operators and are often seen in trait bounds.",
        "suggest": "比较 traits，它实现了比较相等，经常在 trait bounds 中看到。",
        "translate": ""
    },
    {
        "source": "generic conversions, used by savvy API authors to create overloaded methods.",
        "suggest": "泛型转换，由精明的 API 作者用来创建重载方法。",
        "translate": ""
    },
    {
        "source": "iterators of various kinds.",
        "suggest": "各种迭代器。",
        "translate": ""
    },
    {
        "source": "a type which expresses the presence or absence of a value.",
        "suggest": "表示值存在或不存在的类型。",
        "translate": ""
    },
    {
        "source": "a type for functions that may succeed or fail.",
        "suggest": "一种可能成功也可能失败的函数类型。",
        "translate": ""
    },
    {
        "source": "heap-allocated strings.",
        "suggest": "堆分配的字符串。",
        "translate": ""
    },
    {
        "source": "ABI for μITRON derivatives",
        "suggest": "μITRON 衍生的 ABI",
        "translate": ""
    },
    {
        "source": "Kernel object ID",
        "suggest": "内核对象 ID",
        "translate": ""
    },
    {
        "source": "The current task.",
        "suggest": "当前任务。",
        "translate": ""
    },
    {
        "source": "Relative time",
        "suggest": "相对时间",
        "translate": ""
    },
    {
        "source": "Timeout (a valid `RELTIM` value or `TMO_FEVR`)",
        "suggest": "超时 (有效的 `RELTIM` 值或 `TMO_FEVR`)",
        "translate": ""
    },
    {
        "source": "The infinite timeout value",
        "suggest": "无限超时的值",
        "translate": ""
    },
    {
        "source": "The maximum valid value of `RELTIM`",
        "suggest": "`RELTIM` 的最大有效值",
        "translate": ""
    },
    {
        "source": "System time",
        "suggest": "系统时间",
        "translate": ""
    },
    {
        "source": "Error code type",
        "suggest": "错误代码类型",
        "translate": ""
    },
    {
        "source": "Error code type, `ID` on success",
        "suggest": "错误代码类型，成功时的 `ID`",
        "translate": ""
    },
    {
        "source": "Task or interrupt priority",
        "suggest": "任务或中断优先级",
        "translate": ""
    },
    {
        "source": "The special value of `PRI` representing the current task's priority.",
        "suggest": "`PRI` 的特殊值，表示当前任务的优先级。",
        "translate": ""
    },
    {
        "source": "Use the priority inheritance protocol",
        "suggest": "使用优先继承协议",
        "translate": ""
    },
    {
        "source": "Activate the task on creation",
        "suggest": "在创建时激活任务",
        "translate": ""
    },
    {
        "source": "The maximum count of a semaphore",
        "suggest": "信号量的最大计数",
        "translate": ""
    },
    {
        "source": "Callback parameter",
        "suggest": "回调参数",
        "translate": ""
    },
    {
        "source": "Task entrypoint",
        "suggest": "任务入口点",
        "translate": ""
    },
    {
        "source": "Error codes",
        "suggest": "错误代码",
        "translate": ""
    },
    {
        "source": "conditional variable implementation based on user-space wait queues.",
        "suggest": "基于用户空间等待队列的条件变量实现。",
        "translate": ""
    },
    {
        "source": "The implementation is inspired by the queue-based implementation shown in Andrew D.",
        "suggest": "该实现受到了 Andrew D. 中所示的基于队列的实现的启发",
        "translate": ""
    },
    {
        "source": "Birrell's paper \"Implementing Condition Variables with Semaphores\"",
        "suggest": "Birrell 的论文 \"用信号量实现条件变量\"",
        "translate": ""
    },
    {
        "source": "Unpark the task",
        "suggest": "Unpark 任务",
        "translate": ""
    },
    {
        "source": "The task already has a token.",
        "suggest": "任务已经有一个 token。",
        "translate": ""
    },
    {
        "source": "Can't undo the effect;",
        "suggest": "无法撤消效果;",
        "translate": ""
    },
    {
        "source": "abort the program on failure",
        "suggest": "失败时中止程序",
        "translate": ""
    },
    {
        "source": "Construct `Waiter`.",
        "suggest": "构建 `Waiter`。",
        "translate": ""
    },
    {
        "source": "Wait until `waiter` is removed from the queue",
        "suggest": "等待 `waiter` 从队列中移除",
        "translate": ""
    },
    {
        "source": "Park the current task",
        "suggest": "Park 当前任务",
        "translate": ""
    },
    {
        "source": "Construct and pin `Waiter`",
        "suggest": "构建和固定 `Waiter`",
        "translate": ""
    },
    {
        "source": "Park the current task and do not wake up until the timeout elapses or the task gets woken up by `notify_*`",
        "suggest": "Park 当前任务，直到超时或任务被 `notify_*` 唤醒后才唤醒",
        "translate": ""
    },
    {
        "source": "We were unparked.",
        "suggest": "我们没有 unpark。",
        "translate": ""
    },
    {
        "source": "Are we really dequeued?",
        "suggest": "我们真的出队了吗？",
        "translate": ""
    },
    {
        "source": "No we are not.",
        "suggest": "不，我们没有。",
        "translate": ""
    },
    {
        "source": "Continue waiting.",
        "suggest": "继续等待。",
        "translate": ""
    },
    {
        "source": "Remove `waiter` from `self.waiters`.",
        "suggest": "从 `self.waiters` 上移除 `waiter`。",
        "translate": ""
    },
    {
        "source": "If `waiter` is still in `waiters`, it means we woke up because of a timeout.",
        "suggest": "如果 `waiter` 还在 `waiters` 中，则表示我们因为超时而醒来。",
        "translate": ""
    },
    {
        "source": "Otherwise, we woke up because of `notify_*`.",
        "suggest": "否则，我们会因为 `notify_*` 而醒来。",
        "translate": ""
    },
    {
        "source": "These fields are only accessed through `&[mut] WaiterQueue`.",
        "suggest": "这些字段只能通过 `&[mut] WaiterQueue` 访问。",
        "translate": ""
    },
    {
        "source": "The waiting task's ID.",
        "suggest": "等待任务的 ID。",
        "translate": ""
    },
    {
        "source": "Will be zeroed when the task is woken up and removed from a queue.",
        "suggest": "当任务被唤醒并从队列中移除时将被清零。",
        "translate": ""
    },
    {
        "source": "Zeroness of `Waiter::task` indicates whether the `Waiter` is linked to a queue or not.",
        "suggest": "`Waiter::task` 为零表示 `Waiter` 是否链接到队列。",
        "translate": ""
    },
    {
        "source": "This invariant is important for the correctness.",
        "suggest": "这个不可变变量对于正确性很重要。",
        "translate": ""
    },
    {
        "source": "The caller must own `*waiter_ptr`.",
        "suggest": "调用者必须拥有 `*waiter_ptr`。",
        "translate": ""
    },
    {
        "source": "The caller will lose the ownership until `*waiter_ptr` is removed from `self`.",
        "suggest": "调用者将失去所有权，直到 `*waiter_ptr` 从 `self` 中删除。",
        "translate": ""
    },
    {
        "source": "must be valid until it's removed from the queue.",
        "suggest": "在从队列中删除之前必须有效的。",
        "translate": ""
    },
    {
        "source": "must not have been previously inserted to a `WaiterQueue`.",
        "suggest": "之前不能插入到 `WaiterQueue` 中。",
        "translate": ""
    },
    {
        "source": "Find the insertion position and insert `waiter`",
        "suggest": "找到插入位置并插入 `waiter`",
        "translate": ""
    },
    {
        "source": "and all previous waiters have the same or higher priority than `current_task_priority`.",
        "suggest": "并且所有前面的 waiter 都具有与 `current_task_priority` 相同或更高的优先级。",
        "translate": ""
    },
    {
        "source": "Insert the new waiter right after `cursor`.",
        "suggest": "在 `cursor` 之后立即插入新的 waiter。",
        "translate": ""
    },
    {
        "source": "Insert `waiter` after `insert_after`",
        "suggest": "在 `insert_after` 之后插入 `waiter`",
        "translate": ""
    },
    {
        "source": "Insert `waiter` to the front",
        "suggest": "在前面插入 `waiter`",
        "translate": ""
    },
    {
        "source": "is the only element",
        "suggest": "是唯一的元素",
        "translate": ""
    },
    {
        "source": "Given a `Waiter` that was previously inserted to `self`, remove it from `self` if it's still there.",
        "suggest": "给定一个之前插入到 `self` 的 `Waiter`，如果它仍然存在，请将其从 `self` 中删除。",
        "translate": ""
    },
    {
        "source": "Given a `Waiter` that was previously inserted to `self`, return a flag indicating whether it's still in `self`.",
        "suggest": "给定一个先前插入到 `self` 的 `Waiter`，返回一个标志，指示它是否仍在 `self` 中。",
        "translate": ""
    },
    {
        "source": "Get the ID",
        "suggest": "获取 ID",
        "translate": ""
    },
    {
        "source": "Unlink the waiter",
        "suggest": "断开 waiter 的连接",
        "translate": ""
    },
    {
        "source": "Wraps a μITRON error code.",
        "suggest": "包装一个 μITRON 错误代码。",
        "translate": ""
    },
    {
        "source": "Construct `ItronError` from the specified error code.",
        "suggest": "根据指定的错误代码构造 `ItronError`。",
        "translate": ""
    },
    {
        "source": "Returns `None` if the error code does not represent a failure or warning.",
        "suggest": "如果错误代码不代表失败或警告，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns `Ok(er)` if `er` represents a success or `Err(_)` otherwise.",
        "suggest": "如果 `er` 表示成功，则返回 `Ok(er)`，否则返回 `Err(_)`。",
        "translate": ""
    },
    {
        "source": "Get the raw error code.",
        "suggest": "获取原始错误代码。",
        "translate": ""
    },
    {
        "source": "Allow the platforms to extend `error_name`",
        "suggest": "允许平台扩展 `error_name`",
        "translate": ""
    },
    {
        "source": "Describe the specified μITRON error code.",
        "suggest": "描述指定的 μITRON 错误代码。",
        "translate": ""
    },
    {
        "source": "Returns `None` if it's an undefined error code.",
        "suggest": "如果是未定义的错误代码，则返回 `None`。",
        "translate": ""
    },
    {
        "source": "The TOPPERS third generation kernels",
        "suggest": "TOPPERS 第三代内核",
        "translate": ""
    },
    {
        "source": "Similar to `ItronError::err_if_negative(er).expect()` except that, while panicking, it prints the message to `panic_output` and aborts the program instead.",
        "suggest": "与 `ItronError::err_if_negative(er).expect()` 类似，不同之处在于，当 panic 时，它将消息打印到 `panic_output` 并中止程序。",
        "translate": ""
    },
    {
        "source": "This ensures the error message is not obscured by double panicking.",
        "suggest": "这确保错误消息不会被双重 panic 所掩盖。",
        "translate": ""
    },
    {
        "source": "This is useful for diagnosing creation failures of synchronization primitives that are used by `std`'s internal mechanisms.",
        "suggest": "这对于诊断 `std` 内部机制使用的同步原语的创建失败非常有用。",
        "translate": ""
    },
    {
        "source": "Such failures are common when the system is mis-configured to provide a too-small pool for kernel objects.",
        "suggest": "当系统被错误配置为为内核对象提供一个太小的池时，这种故障很常见。",
        "translate": ""
    },
    {
        "source": "Similar to `ItronError::err_if_negative(er).expect()` but aborts instead.",
        "suggest": "与 `ItronError::err_if_negative(er).expect()` 类似，但改为中止。",
        "translate": ""
    },
    {
        "source": "Use this where panicking is not allowed or the effect of the failure would be persistent.",
        "suggest": "在不允许 panic 或失败的影响将持续存在的情况下使用此选项。",
        "translate": ""
    },
    {
        "source": "Mutex implementation backed by μITRON mutexes.",
        "suggest": "μITRON 互斥体支持互斥锁实现。",
        "translate": ""
    },
    {
        "source": "Assumes `acre_mtx` and `TA_INHERIT` are available.",
        "suggest": "假设 `acre_mtx` 和 `TA_INHERIT` 可用。",
        "translate": ""
    },
    {
        "source": "The ID of the underlying mutex object",
        "suggest": "底层 mutex 对象的 ID",
        "translate": ""
    },
    {
        "source": "Create a mutex object.",
        "suggest": "创建一个 mutex 对象。",
        "translate": ""
    },
    {
        "source": "This function never panics.",
        "suggest": "这个函数永远不会 panic。",
        "translate": ""
    },
    {
        "source": "Priority inheritance mutex",
        "suggest": "优先继承 mutex",
        "translate": ""
    },
    {
        "source": "Initialize `self.mtx` eagerly",
        "suggest": "急切地初始化 `self.mtx`",
        "translate": ""
    },
    {
        "source": "Get the inner mutex's ID, which is lazily created.",
        "suggest": "获取延迟创建的内部 mutex 的 ID。",
        "translate": ""
    },
    {
        "source": "The lock count.",
        "suggest": "锁计数。",
        "translate": ""
    },
    {
        "source": "Recursive lock",
        "suggest": "递归锁",
        "translate": ""
    },
    {
        "source": "counter overflow",
        "suggest": "计数器溢出",
        "translate": ""
    },
    {
        "source": "Locked by another thread",
        "suggest": "被另一个线程锁定",
        "translate": ""
    },
    {
        "source": "Top-level lock by the current thread",
        "suggest": "当前线程的顶级锁",
        "translate": ""
    },
    {
        "source": "A mutex implemented by `dis_dsp` (for intra-core synchronization) and a spinlock (for inter-core synchronization).",
        "suggest": "由 `dis_dsp` (用于内核内同步) 和自旋锁 (用于内核间同步) 实现的互斥锁。",
        "translate": ""
    },
    {
        "source": "Acquire a lock.",
        "suggest": "获得一个锁。",
        "translate": ""
    },
    {
        "source": "Wait until the current processor acquires a lock.",
        "suggest": "等待直到当前处理器获得锁。",
        "translate": ""
    },
    {
        "source": "implemented by `dis_dsp` (for intra-core synchronization) and a spinlock (for inter-core synchronization).",
        "suggest": "由 `dis_dsp` (用于内核内同步) 和自旋锁 (用于内核间同步) 实现。",
        "translate": ""
    },
    {
        "source": "It's assumed that `0` is not a valid ID, and all kernel object IDs fall into range `1..=usize::MAX`.",
        "suggest": "假设 `0` 不是有效 ID，并且所有内核对象 ID 都在 `1..=usize::MAX` 范围内。",
        "translate": ""
    },
    {
        "source": "Assign the content without checking if it's already initialized or being initialized.",
        "suggest": "分配内容而不检查它是否已经初始化或正在初始化。",
        "translate": ""
    },
    {
        "source": "Assumption: A positive `abi::ID` fits in `usize`.",
        "suggest": "假设：正的 `abi::ID` 适合 `usize`。",
        "translate": ""
    },
    {
        "source": "Warning: `f` must not perform a blocking operation, which includes panicking.",
        "suggest": "警告: `f` 不得执行阻塞操作，包括 panic。",
        "translate": ""
    },
    {
        "source": "Fast path",
        "suggest": "快速路径",
        "translate": ""
    },
    {
        "source": "Safety: The inner value has been initialized",
        "suggest": "安全：内部值已经初始化",
        "translate": ""
    },
    {
        "source": "Store the initialized contents.",
        "suggest": "存储初始化的内容。",
        "translate": ""
    },
    {
        "source": "Use the release ordering to make sure the write is visible to the callers of `get`.",
        "suggest": "使用发布顺序确保写入对 `get` 的调用者可见。",
        "translate": ""
    },
    {
        "source": "Get the ID of the task in Running state.",
        "suggest": "获取处于运行状态的任务的 ID。",
        "translate": ""
    },
    {
        "source": "Panics on failure.",
        "suggest": "Panics 失败。",
        "translate": ""
    },
    {
        "source": "Aborts on failure.",
        "suggest": "失败时中止。",
        "translate": ""
    },
    {
        "source": "Get the specified task's priority.",
        "suggest": "获取指定任务的优先级。",
        "translate": ""
    },
    {
        "source": "Thread implementation backed by μITRON tasks.",
        "suggest": "由 μITRON 任务支持的线程实现。",
        "translate": ""
    },
    {
        "source": "Assumes `acre_tsk` and `exd_tsk` are available.",
        "suggest": "假设 `acre_tsk` 和 `exd_tsk` 可用。",
        "translate": ""
    },
    {
        "source": "The ID of the underlying task.",
        "suggest": "基础任务的 ID。",
        "translate": ""
    },
    {
        "source": "State data shared between a parent thread and child thread.",
        "suggest": "父线程和子线程之间共享的状态数据。",
        "translate": ""
    },
    {
        "source": "It's dropped on a transition to one of the final states.",
        "suggest": "它是在过渡到最终状态之一时被丢弃的。",
        "translate": ""
    },
    {
        "source": "This field is used on thread creation to pass a closure from `Thread::new` to the created task.",
        "suggest": "该字段用于线程创建以将来自 `Thread::new` 的闭包传递给创建的任务。",
        "translate": ""
    },
    {
        "source": "A state machine.",
        "suggest": "状态机。",
        "translate": ""
    },
    {
        "source": "Each transition is annotated with `[...]` in the source code.",
        "suggest": "每个转换都在源代码中用 `[...]` 注解。",
        "translate": ""
    },
    {
        "source": "Safety: The only `!Sync` field, `ThreadInner::start`, is only touched by the task represented by `ThreadInner`.",
        "suggest": "安全性：唯一的 `!Sync` 字段，`ThreadInner::start`，仅被 `ThreadInner` 所代表的任务触及。",
        "translate": ""
    },
    {
        "source": "there's no single value for `JOINING`",
        "suggest": "`JOINING` 没有单一的值",
        "translate": ""
    },
    {
        "source": "See `thread::Builder::spawn_unchecked` for safety requirements.",
        "suggest": "有关安全要求，请参见 `thread::Builder::spawn_unchecked`。",
        "translate": ""
    },
    {
        "source": "Inherit the current task's priority",
        "suggest": "继承当前任务的优先级",
        "translate": ""
    },
    {
        "source": "Safety: `ThreadInner` is alive at this point",
        "suggest": "安全性：此时 `ThreadInner` 此时处于活动状态",
        "translate": ""
    },
    {
        "source": "Safety: Since `trampoline` is called only once for each `ThreadInner` and only `trampoline` touches `start`, `start` contains contents and is safe to mutably borrow.",
        "suggest": "安全性：由于每个 `ThreadInner` 只调用一次 `trampoline`，并且只有 `trampoline` 接触 `start`，因此 `start` 包含内容，可以安全地可变借用。",
        "translate": ""
    },
    {
        "source": "Fix the current thread's state just in case, so that the destructors won't abort Safety: Not really unsafe",
        "suggest": "修复当前线程的状态以防万一，以便析构函数不会终止安全：并不是真的不安全",
        "translate": ""
    },
    {
        "source": "Run TLS destructors now because they are not called automatically for terminated tasks.",
        "suggest": "现在运行 TLS 析构函数，因为终止的任务不会自动调用它们。",
        "translate": ""
    },
    {
        "source": "No one will ever join, so we'll ask the collector task to delete the task.",
        "suggest": "没有人会加入，因此我们将要求收集器任务删除该任务。",
        "translate": ""
    },
    {
        "source": "In this case, `inner`'s ownership has been moved to us, And we are responsible for dropping it.",
        "suggest": "在这种情况下，`inner` 的所有权已经转移给我们，我们负责丢弃它。",
        "translate": ""
    },
    {
        "source": "The acquire ordering is not necessary because the parent thread made no memory acccess needing synchronization since the call to `acre_tsk`.",
        "suggest": "获取顺序不是必需的，因为当调用 `acre_tsk` 后，父线程没有进行需要同步的内存访问。",
        "translate": ""
    },
    {
        "source": "Safety: See above.",
        "suggest": "安全：见上文。",
        "translate": ""
    },
    {
        "source": "Safety: There are no pinned references to the stack",
        "suggest": "安全性：没有对栈的固定引用",
        "translate": ""
    },
    {
        "source": "The parent hasn't decided whether to join or detach this thread yet.",
        "suggest": "父任务还没有决定是加入还是分离这个线程。",
        "translate": ""
    },
    {
        "source": "Whichever option the parent chooses, it'll have to delete this task.",
        "suggest": "无论父任务选择哪个选项，它都必须删除此任务。",
        "translate": ""
    },
    {
        "source": "Since the parent might drop `*inner` as soon as it sees `FINISHED`, the release ordering must be used in the above `swap` call.",
        "suggest": "由于父任务可能会在看到 `FINISHED` 时立即丢弃 `*inner`，因此必须在上述 `swap` 调用中使用发布顺序。",
        "translate": ""
    },
    {
        "source": "Since the parent might drop `*inner` and terminate us as soon as it sees `JOIN_FINALIZE`, the release ordering must be used in the above `swap` call.",
        "suggest": "由于父任务可能会丢弃 `*inner` 并在它看到 `JOIN_FINALIZE` 后立即终止我们，因此必须在上述 `swap` 调用中使用发布顺序。",
        "translate": ""
    },
    {
        "source": "Wake up the parent task.",
        "suggest": "唤醒父任务。",
        "translate": ""
    },
    {
        "source": "indicates there's already a parking token",
        "suggest": "表示已经 parking token",
        "translate": ""
    },
    {
        "source": "Activate this task immediately",
        "suggest": "立即激活此任务",
        "translate": ""
    },
    {
        "source": "The entry point",
        "suggest": "入口点",
        "translate": ""
    },
    {
        "source": "Let the kernel allocate the stack,",
        "suggest": "让内核分配栈，",
        "translate": ""
    },
    {
        "source": "Get the current task ID.",
        "suggest": "获取当前任务的 ID。",
        "translate": ""
    },
    {
        "source": "Panicking here would cause a resource leak, so just abort on failure.",
        "suggest": "在这里 panic 会导致资源泄漏，所以只要在失败时中止即可。",
        "translate": ""
    },
    {
        "source": "The child task will transition the state to `JOIN_FINALIZE` and wake us up.",
        "suggest": "子任务将状态转换为 `JOIN_FINALIZE` 并唤醒我们。",
        "translate": ""
    },
    {
        "source": "To synchronize with the child task's memory accesses to `inner` up to the point of the assignment of `JOIN_FINALIZE`, `Ordering::Acquire` must be used for the `load`.",
        "suggest": "为了与子任务对 `inner` 的内存访问同步到 `JOIN_FINALIZE` 的分配点，`Ordering::Acquire` 必须用于 `load`。",
        "translate": ""
    },
    {
        "source": "To synchronize with the child task's memory accesses to `inner` up to the point of the assignment of `FINISHED`, `Ordering::Acquire` must be used for the above `swap` call`.",
        "suggest": "为了与子任务对 `inner` 的内存访问同步到 `FINISHED` 的分配点，`Ordering::Acquire` 必须用于上述 `swap` 调用 `。",
        "translate": ""
    },
    {
        "source": "Terminate and delete the task Safety: `self.task` still represents a task we own (because this method or `detach_inner` is called only once for each `Thread`).",
        "suggest": "终止并删除任务 Safety: `self.task` 仍然代表我们拥有所有权的任务 (因为这个方法或 `detach_inner` 对于每个 `Thread` 只调用一次)。",
        "translate": ""
    },
    {
        "source": "The task indicated that it's safe to delete by entering the `FINISHED` or `JOIN_FINALIZE` state.",
        "suggest": "该任务表明可以通过进入 `FINISHED` 或 `JOIN_FINALIZE` 状态进行安全删除。",
        "translate": ""
    },
    {
        "source": "In either case, we are responsible for dropping `inner`.",
        "suggest": "在任何一种情况下，我们都应对丢弃 `inner` 负责。",
        "translate": ""
    },
    {
        "source": "Safety: The contents of `self.inner` will not be accessed hereafter",
        "suggest": "安全: `self.inner` 的内容以后将不会被访问",
        "translate": ""
    },
    {
        "source": "Skip the destructor (because it would attempt to detach the thread)",
        "suggest": "跳过析构函数 (因为它会尝试分离线程)",
        "translate": ""
    },
    {
        "source": "Detach the thread.",
        "suggest": "分离线程。",
        "translate": ""
    },
    {
        "source": "When the time comes, the child will figure out that no one will ever join it.",
        "suggest": "当时机成熟时，子节点会发现没有人会加入。",
        "translate": ""
    },
    {
        "source": "The ownership of `self.inner` is moved to the child thread.",
        "suggest": "`self.inner` 的所有权转移到子线程。",
        "translate": ""
    },
    {
        "source": "However, the release ordering is not necessary because we made no memory acccess needing synchronization since the call to `acre_tsk`.",
        "suggest": "但是，释放顺序不是必需的，因为自从调用 `acre_tsk` 之后，我们没有进行需要同步的内存访问。",
        "translate": ""
    },
    {
        "source": "The task has already decided that we should delete the task.",
        "suggest": "任务已经决定我们应该删除任务。",
        "translate": ""
    },
    {
        "source": "To synchronize with the child task's memory accesses to `inner` up to the point of the assignment of `FINISHED`, the acquire ordering is required for the above `swap` call.",
        "suggest": "为了与子任务对 `inner` 的内存访问同步到 `FINISHED` 的分配点，上述 `swap` 调用需要获取排序。",
        "translate": ""
    },
    {
        "source": "Terminate and delete the task Safety: `self.task` still represents a task we own (because this method or `join_inner` is called only once for each `Thread`).",
        "suggest": "终止并删除任务安全: `self.task` 仍然代表我们拥有的任务 (因为这个方法或 `join_inner` 对于每个 `Thread` 只调用一次)。",
        "translate": ""
    },
    {
        "source": "The task  indicated that it's safe to delete by entering the `FINISHED` state.",
        "suggest": "任务表明可以通过进入 `FINISHED` 状态进行安全删除。",
        "translate": ""
    },
    {
        "source": "Wwe are responsible for dropping `inner`.",
        "suggest": "Wwe 负责丢弃 `inner`。",
        "translate": ""
    },
    {
        "source": "Terminate and delete the specified task.",
        "suggest": "终止并删除指定的任务。",
        "translate": ""
    },
    {
        "source": "This function will abort if `deleted_task` refers to the calling task.",
        "suggest": "如果 `deleted_task` 指的是调用任务，则这个函数将终止。",
        "translate": ""
    },
    {
        "source": "It is assumed that the specified task is solely managed by the caller - i.e., other threads must not \"resuscitate\" the specified task or delete it prematurely while this function is still in progress.",
        "suggest": "假设指定的任务是由调用者单独管理的 -- 即，在此函数仍在进行中时，其他线程不得对指定的任务进行 \"resuscitate\" 或过早删除。",
        "translate": ""
    },
    {
        "source": "It is allowed for the specified task to exit by its own.",
        "suggest": "允许指定的任务自行退出。",
        "translate": ""
    },
    {
        "source": "The task must be safe to terminate.",
        "suggest": "任务必须可以安全终止。",
        "translate": ""
    },
    {
        "source": "This is in general not true because there might be pinned references to the task's stack.",
        "suggest": "这通常是不正确的，因为可能存在对任务栈的固定引用。",
        "translate": ""
    },
    {
        "source": "Terminate the task Safety: Upheld by the caller",
        "suggest": "终止任务安全：由调用方支持",
        "translate": ""
    },
    {
        "source": "Indicates the task is already dormant, ignore it",
        "suggest": "表示任务已经休眠，请忽略它",
        "translate": ""
    },
    {
        "source": "Delete the task Safety: Upheld by the caller",
        "suggest": "删除任务安全：调用方支持",
        "translate": ""
    },
    {
        "source": "Terminate and delete the calling task.",
        "suggest": "终止并删除调用任务。",
        "translate": ""
    },
    {
        "source": "Atomicity is not required - i.e., it can be assumed that other threads won't `ter_tsk` the calling task while this function is still in progress.",
        "suggest": "原子性不是必需的 - 即，可以假设其他线程不会在此函数仍在进行中时 `ter_tsk` 调用任务。",
        "translate": ""
    },
    {
        "source": "(This property makes it easy to implement this operation on μITRON-derived kernels that don't support `exd_tsk`.)",
        "suggest": "(这个属性使得在不支持 `exd_tsk` 的 μITRON 派生内核上实现这个操作变得很容易。)",
        "translate": ""
    },
    {
        "source": "Safety: `exd_tsk` never returns on success",
        "suggest": "安全性: `exd_tsk` 永远不会成功返回",
        "translate": ""
    },
    {
        "source": "Safety: The provided pointer is valid",
        "suggest": "安全：提供的指针有效",
        "translate": ""
    },
    {
        "source": "There are ways to change the system time",
        "suggest": "有多种方法可以改变系统时间",
        "translate": ""
    },
    {
        "source": "is measured in microseconds",
        "suggest": "以微秒为单位进行测量",
        "translate": ""
    },
    {
        "source": "Split `Duration` into zero or more `RELTIM`s.",
        "suggest": "将 `Duration` 拆分为零个或多个 `RELTIM`。",
        "translate": ""
    },
    {
        "source": "is microseconds",
        "suggest": "是微秒",
        "translate": ""
    },
    {
        "source": "Split `Duration` into one or more `TMO`s.",
        "suggest": "将 `Duration` 拆分为一个或多个 `TMO`。",
        "translate": ""
    },
    {
        "source": "Split `Duration` into one or more API calls with timeout.",
        "suggest": "将 `Duration` 拆分为一个或多个带超时的 API 调用。",
        "translate": ""
    },
    {
        "source": "This function can handle spurious wakeups.",
        "suggest": "这个函数可以处理虚假唤醒。",
        "translate": ""
    },
    {
        "source": "and `SYSTIM` are microseconds.",
        "suggest": "和 `SYSTIM` 是微秒。",
        "translate": ""
    },
    {
        "source": "Clamp at `SYSTIM::MAX` for performance reasons.",
        "suggest": "出于性能原因，Clamp 在 `SYSTIM::MAX` 中。",
        "translate": ""
    },
    {
        "source": "This shouldn't cause a problem in practice.",
        "suggest": "这在实践中应该不会造成问题。",
        "translate": ""
    },
    {
        "source": "(`u64::MAX` μs ≈ 584942 years)",
        "suggest": "(`u64::MAX` μs ≈ 584942 年)",
        "translate": ""
    },
    {
        "source": "This value can be chosen by an application",
        "suggest": "该值可以由应用程序选择",
        "translate": ""
    },
    {
        "source": "Describe the specified SOLID error code.",
        "suggest": "描述指定的 SOLID 错误代码。",
        "translate": ""
    },
    {
        "source": "The SOLID error codes are a superset of μITRON error codes.",
        "suggest": "SOLID 错误代码是 μITRON 错误代码的超集。",
        "translate": ""
    },
    {
        "source": "A file descriptor.",
        "suggest": "一个文件描述符。",
        "translate": ""
    },
    {
        "source": "Safety: we just asserted that the value is in the valid range and isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)",
        "suggest": "安全性：我们只是断言该值在有效范围内并且不是 `-1` (唯一大于 `0xFF_FF_FF_FE` 的无符号值)",
        "translate": ""
    },
    {
        "source": "Casting to `i64` is fine, too large values will end up as negative which will cause an error in `SOLID_FS_Lseek`.",
        "suggest": "强制转换为 `i64` 很好，太大的值最终会变成负数，这将导致 `SOLID_FS_Lseek` 出现错误。",
        "translate": ""
    },
    {
        "source": "Get the new offset",
        "suggest": "获取新的偏移量",
        "translate": ""
    },
    {
        "source": "This target doesn't support symlinks",
        "suggest": "此目标不支持符号链接",
        "translate": ""
    },
    {
        "source": "is `pub(crate)` so that it can be accessed by `itron/error.rs` as",
        "suggest": "是 `pub(crate)`，所以它可以被 `itron/error.rs` 访问为",
        "translate": ""
    },
    {
        "source": "Judging by the source code, it's unlimited, but specify a lower value just in case.",
        "suggest": "从源代码来看，它是无限的，但为了以防万一，请指定一个较低的值。",
        "translate": ""
    },
    {
        "source": "Returns the last error from the network subsystem.",
        "suggest": "从网络子系统返回最后一个错误。",
        "translate": ""
    },
    {
        "source": "there's no ErrorKind for EINPROGRESS",
        "suggest": "EINPROGRESS 没有 ErrorKind",
        "translate": ""
    },
    {
        "source": "This method is used by sys_common code to abstract over targets.",
        "suggest": "sys_common 代码使用该方法对目标进行抽象。",
        "translate": ""
    },
    {
        "source": "directly maps `errno`s to μITRON error codes.",
        "suggest": "直接将 `errno`s 映射为 μITRON 错误代码。",
        "translate": ""
    },
    {
        "source": "In kmclib, `setenv` and `unsetenv` don't always set `errno`, so this function just returns a generic error.",
        "suggest": "在 kmclib 中，`setenv` 和 `unsetenv` 并不总是设置 `errno`，所以这个函数只是返回一个通用错误。",
        "translate": ""
    },
    {
        "source": "A readers-writer lock implementation backed by the SOLID kernel extension.",
        "suggest": "由 SOLID 内核扩展支持的 readers-writer 锁实现。",
        "translate": ""
    },
    {
        "source": "Safety: `num_readers` is protected by `mtx_num_readers`",
        "suggest": "安全: `num_readers` 受 `mtx_num_readers` 保护",
        "translate": ""
    },
    {
        "source": "Register `tls_dtor` to make sure the TLS destructors are called for tasks created by other means than `std::thread`",
        "suggest": "注册 `tls_dtor` 以确保为通过 `std::thread` 以外的其他方式创建的任务调用 TLS 析构函数",
        "translate": ""
    },
    {
        "source": "Swap the destructor list, call all registered destructors, and repeat this until the list becomes permanently empty.",
        "suggest": "交换析构函数列表，调用所有已注册的析构函数，并重复这个过程，直到列表永久为空。",
        "translate": ""
    },
    {
        "source": "Drop the destructor list",
        "suggest": "丢弃析构函数列表",
        "translate": ""
    },
    {
        "source": "implement on vxWorks, Redox, l4re",
        "suggest": "在 vxWorks、Redox、l4re 上实现",
        "translate": ""
    },
    {
        "source": "thread_local with `const {}` triggers this liny",
        "suggest": "带有 `const {}` 的 thread_local 会触发此 liny",
        "translate": ""
    },
    {
        "source": "Minimum number of elements in a node that is not a root.",
        "suggest": "非根节点中的最小元素数。",
        "translate": ""
    },
    {
        "source": "Every non-leaf node contains at least 1 element (has at least 2 children).",
        "suggest": "每个非叶子节点至少包含 1 个元素 (至少有 2 个子节点)。",
        "translate": ""
    },
    {
        "source": "An empty map is represented either by the absence of a root node or by a root node that is an empty leaf.",
        "suggest": "空的 map 表示不存在根节点或根节点为空叶子。",
        "translate": ""
    },
    {
        "source": "Making this upper bound more tight during iteration would require an extra field.",
        "suggest": "在迭代期间使这个上限更紧将需要一个额外的字段。",
        "translate": ""
    },
    {
        "source": "The returned KV handle is only valid to access the key and value, and only valid until the next call to a `deallocating_` method.",
        "suggest": "返回的 KV 句柄仅对访问键和值有效，并且仅在下一次调用 `deallocating_` 方法之前有效。",
        "translate": ""
    },
    {
        "source": "Requires exclusive access to the `NodeRef` object but not to the root node;",
        "suggest": "需要对 `NodeRef` 对象的独占访问，而不是对根节点的独占访问;",
        "translate": ""
    },
    {
        "source": "VecDeque::with_capacity ensures that there is enough capacity.",
        "suggest": "VecDeque::with_capacity 确保有足够的容量。",
        "translate": ""
    },
    {
        "source": "due to unchecked casts of unsigned amounts to signed offsets the wraparound effectively results in unsigned pointers representing positions 0..usize::MAX, which is valid for ZSTs.",
        "suggest": "由于未检查的无符号量转换为有符号偏移，环绕有效地导致表示位置 0..usize::MAX 的无符号指针，这对 ZST 有效。",
        "translate": ""
    },
    {
        "source": "the min() above ensures that step_size is in bounds",
        "suggest": "上面的 min() 确保 step_size 在界限内",
        "translate": ""
    },
    {
        "source": "same as for advance_by()",
        "suggest": "与 advance_by() 相同",
        "translate": ""
    },
    {
        "source": "TrustedRandomAccess (without NoCoerce) must not be implemented because subtypes/supertypes of `T` might not be `NonDrop`",
        "suggest": "不得实现 TrustedRandomAccess (无 NoCoerce)，因为 `T` 的 subtypes/supertypes 可能不是 `NonDrop`",
        "translate": ""
    },
    {
        "source": "process_one return a bool indicates whether the processing element should be retained.",
        "suggest": "process_one 返回一个 bool 指示是否应保留处理元素。",
        "translate": ""
    },
    {
        "source": "Stage 1: Nothing was deleted.",
        "suggest": "第 1 阶段：没有删除任何内容。",
        "translate": ""
    },
    {
        "source": "Stage 2: Some elements were deleted.",
        "suggest": "第 2 阶段：删除了一些元素。",
        "translate": ""
    },
    {
        "source": "If you only need to resize to a smaller size, use [`Vec::truncate`].",
        "suggest": "如果您只需要调整到更小的尺寸，请使用 [`Vec::truncate`]。",
        "translate": ""
    },
    {
        "source": "If hashed by iteration alone, `(x, y)` and `(y, x)` would visit the same order of elements, resulting in the same hash.",
        "suggest": "如果单独通过迭代进行散列，`(x, y)` 和 `(y, x)` 将访问相同顺序的元素，从而产生相同的散列。",
        "translate": ""
    },
    {
        "source": "But now that we also hash the length, they get distinct sequences of hashed data.",
        "suggest": "但是现在我们也对长度进行了散列，他们得到了不同的散列数据序列。",
        "translate": ""
    },
    {
        "source": "we do not need to update the count since that only tallies the number of items consumed from the front.",
        "suggest": "我们不需要更新计数，因为它只计算从前面消耗的 item 数量。",
        "translate": ""
    },
    {
        "source": "consuming items from the back can never reduce that.",
        "suggest": "从后面消费项永远不能减少。",
        "translate": ""
    },
    {
        "source": "step_one calculation may have saturated",
        "suggest": "step_one 计算可能已经饱和",
        "translate": ""
    },
    {
        "source": "the conditions above ensure that the count is in bounds.",
        "suggest": "上述条件确保计数在界限内。",
        "translate": ""
    },
    {
        "source": "If start <= end then steps_between either returns a bound to which we clamp or returns None which together with the initial inequality implies more than usize::MAX steps.",
        "suggest": "如果 start <= end 那么 steps_between 要么返回一个我们钳制的界限，要么返回 None，这与初始不等式一起意味着超过 usize::MAX 个步骤。",
        "translate": ""
    },
    {
        "source": "Otherwise 0 is returned which always safe to use.",
        "suggest": "否则返回 0，这始终可以安全使用。",
        "translate": ""
    },
    {
        "source": "same as the spec_advance_by() implementation",
        "suggest": "与 spec_advance_by() 实现相同",
        "translate": ""
    },
    {
        "source": "Calling `advance_back_by(0)` can do meaningful work, for example [`Flatten`] can advance its outer iterator until it finds an inner iterator that is not empty, which then often allows it to return a more accurate `size_hint()` than in its initial state.",
        "suggest": "调用 `advance_back_by(0)` 可以做有意义的工作，例如 [`Flatten`] 可以推进它的外部迭代器，直到它找到一个不为空的内部迭代器，然后通常允许它返回一个比初始状态更准确的 `size_hint()`。",
        "translate": ""
    },
    {
        "source": "may either return `Ok()` or `Err(0)`.",
        "suggest": "可能返回 `Ok()` 或 `Err(0)`。",
        "translate": ""
    },
    {
        "source": "The former conveys no information whether the iterator is or is not exhausted, the latter can be treated as if [`next_back`] had returned `None`.",
        "suggest": "前者不传达迭代器是否已耗尽的信息，后者可以被视为 [`next_back`] 返回了 `None`。",
        "translate": ""
    },
    {
        "source": "Replacing a `Err(0)` with `Ok` is only correct for `n = 0`.",
        "suggest": "用 `Ok` 替换 `Err(0)` 仅适用于 `n = 0`。",
        "translate": ""
    },
    {
        "source": "Calling `advance_by(0)` can do meaningful work, for example [`Flatten`] can advance its outer iterator until it finds an inner iterator that is not empty, which then often allows it to return a more accurate `size_hint()` than in its initial state.",
        "suggest": "调用 `advance_by(0)` 可以做有意义的工作，例如 [`Flatten`] 可以推进它的外部迭代器，直到它找到一个不为空的内部迭代器，然后通常允许它返回一个比初始状态更准确的 `size_hint()`。",
        "translate": ""
    },
    {
        "source": "The former conveys no information whether the iterator is or is not exhausted, the latter can be treated as if [`next`] had returned `None`.",
        "suggest": "前者不传达迭代器是否已耗尽的信息，后者可以被视为 [`next`] 返回了 `None`。",
        "translate": ""
    },
    {
        "source": "Using `&` helps LLVM see that it is the same check made in division.",
        "suggest": "使用 `&` 有助于 LLVM 看到它是在除法中进行的相同检查。",
        "translate": ""
    },
    {
        "source": "Computes the absolute difference between `self` and `other`.",
        "suggest": "计算 `self` 和 `other` 之间的绝对差。",
        "translate": ""
    },
    {
        "source": "This function always returns the correct answer without overflow or panics by returning an unsigned integer.",
        "suggest": "这个函数总是通过返回一个无符号整数来返回没有溢出或 panics 的正确答案。",
        "translate": ""
    },
    {
        "source": "Converting a non-negative x from signed to unsigned by using `x as U` is left unchanged, but a negative x is converted to value x + 2^N.",
        "suggest": "使用 `x as U` 将非负 x 从有符号转换为无符号保持不变，但负 x 转换为值 x + 2^N。",
        "translate": ""
    },
    {
        "source": "Thus if `s` and `o` are binary variables respectively indicating whether `self` and `other` are negative, we are computing the mathematical value:",
        "suggest": "因此如果 `s` 和 `o` 分别是二元变量变量，表示 `self` 和 `other` 是否为负，我们正在计算数学值:",
        "translate": ""
    },
    {
        "source": "Finally, taking the mod 2^N of the mathematical value of `other - self` does not change it as it already is in the range [0, 2^N).",
        "suggest": "最后，取 `other - self` 的数学值的 mod 2^N 不会改变它，因为它已经在 [0, 2^N) 范围内。",
        "translate": ""
    },
    {
        "source": "Trick LLVM into generating the psadbw instruction when SSE2 is available and this function is autovectorized for u8's.",
        "suggest": "当 SSE2 可用时，诱使 LLVM 生成 psadbw 指令，并且此函数为 u8 自动向量化。",
        "translate": ""
    },
    {
        "source": "FIXME replace `mem::replace` by `mem::take` when the latter is const ready",
        "suggest": "当 `mem::take` 准备好常量时，FIXME 用 `mem::take` 替换 `mem::replace`",
        "translate": ""
    },
    {
        "source": "this implementation, which sidesteps using `Option::map` since it's not const ready yet, should be reverted when possible to avoid code repetition",
        "suggest": "此实现避开使用 `Option::map`，因为它尚未准备好常量，应尽可能还原以避免代码重复",
        "translate": ""
    },
    {
        "source": "applies the provided function to the contained value of [`Ok`], or applies the provided default fallback function to the contained value of [`Err`]",
        "suggest": "将提供的函数应用于 [`Ok`] 的包含值，或将提供的默认回退函数应用于 [`Err`] 的包含值",
        "translate": ""
    },
    {
        "source": "Maps a `Result<T, E>` to `U` by applying a provided default fallback function to a contained [`Err`] value, or a provided function to a contained [`Ok`] value.",
        "suggest": "通过将提供的默认回退函数应用于包含的 [`Err`] 值，或将提供的函数应用于包含的 [`Ok`] 值，Maps 将 `Result<T, E>` 转换为 `U`。",
        "translate": ""
    },
    {
        "source": "test that the methods of `Option` that take mutable references are usable in a const context",
        "suggest": "测试 `Option` 的方法在 const 上下文中是否可用",
        "translate": ""
    },
    {
        "source": "If we've read all the way up to the capacity, reserve more space.",
        "suggest": "如果我们一直读到容量，请保留更多空间。",
        "translate": ""
    },
    {
        "source": "Initialize any excess capacity and adjust the length so we can write to it.",
        "suggest": "初始化任何多余的容量并调整长度，以便我们可以写入它。",
        "translate": ""
    },
    {
        "source": "The buffer might be an exact fit.",
        "suggest": "缓冲区可能是完全合适的。",
        "translate": ""
    },
    {
        "source": "Let's read into a probe buffer and see if it returns `Ok(0)`.",
        "suggest": "让我们读入一个探测缓冲区，看看它是否返回 `Ok(0)`。",
        "translate": ""
    },
    {
        "source": "If so, we've avoided an unnecessary doubling of the capacity.",
        "suggest": "如果是这样，我们就避免了不必要的容量翻倍。",
        "translate": ""
    },
    {
        "source": "But if not, append the probe buffer to the primary buffer and let its capacity grow.",
        "suggest": "但如果没有，请将探测缓冲区附加到主缓冲区并让它容量增长。",
        "translate": ""
    },
    {
        "source": "takes care not to over-allocate when a buffer is the exact size needed.",
        "suggest": "当缓冲区是所需的确切大小时，注意不要过度分配。",
        "translate": ""
    },
    {
        "source": "Returns [`true`] if this address is in a range designated for benchmarking.",
        "suggest": "如果此地址在为基准测试指定的范围内，则返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "See the documentation for [`Ipv4Addr::is_benchmarking()`] and [`Ipv6Addr::is_benchmarking()`] for more details.",
        "suggest": "有关更多详细信息，请参见 [`Ipv4Addr::is_benchmarking()`] 和 [`Ipv6Addr::is_benchmarking()`] 的文档。",
        "translate": ""
    },
    {
        "source": "Returns [`true`] if this is an address reserved for benchmarking (`2001:2::/48`).",
        "suggest": "如果这是为基准测试 (`2001:2::/48`) 保留的地址，则返回 [`true`]。",
        "translate": ""
    },
    {
        "source": "This property is defined in [IETF RFC 5180], where it is mistakenly specified as covering the range `2001:0200::/48`.",
        "suggest": "此属性在 [IETF RFC 5180] 中定义，其中错误地将其指定为覆盖范围 `2001:0200::/48`。",
        "translate": ""
    },
    {
        "source": "This is corrected in [IETF RFC Errata 1752] to `2001:0002::/48`.",
        "suggest": "这在 [IETF RFC Errata 1752] 到 `2001:0002::/48` 中得到纠正。",
        "translate": ""
    },
    {
        "source": "verbatim paths need . and ..",
        "suggest": "verbatim 路径需要 . 和 ..",
        "translate": ""
    },
    {
        "source": "removed",
        "suggest": "移除",
        "translate": ""
    },
    {
        "source": "system_info cpu_count field gets the static data set at boot time with `smp_set_num_cpus` `get_system_info` calls then `smp_get_num_cpus`",
        "suggest": "system_info cpu_count 字段在启动时使用 `smp_set_num_cpus` `get_system_info` 调用然后 `smp_get_num_cpus` 获取静态数据集",
        "translate": ""
    },
    {
        "source": "Only register `WSACleanup` if `WSAStartup` is actually ever called.",
        "suggest": "仅当 `WSAStartup` 被实际调用过时才注册 `WSACleanup`。",
        "translate": ""
    },
    {
        "source": "Workaround to prevent linking to `WS2_32.dll` when no network functionality is used.",
        "suggest": "在不使用网络功能时防止链接到 `WS2_32.dll` 的解决方法。",
        "translate": ""
    },
    {
        "source": "See issue #85441.",
        "suggest": "请参见 issue #85441。",
        "translate": ""
    },
    {
        "source": "only perform cleanup if network functionality was actually initialized",
        "suggest": "仅在实际初始化网络功能时才执行清理",
        "translate": ""
    },
    {
        "source": "see issue #88585",
        "suggest": "请参见 issue #88585",
        "translate": ""
    },
    {
        "source": "Converts a `Cow<'_, [T]>` into a `Box<[T]>`",
        "suggest": "将 `Cow<'_, [T]>` 转换为 `Box<[T]>`",
        "translate": ""
    },
    {
        "source": "When `cow` is the `Cow::Borrowed` variant, this conversion allocates on the heap and copies the underlying slice.",
        "suggest": "当 `cow` 是 `Cow::Borrowed` 成员时，此转换在堆上分配并复制底层切片。",
        "translate": ""
    },
    {
        "source": "Otherwise, it will try to reuse the owned `Vec`'s allocation.",
        "suggest": "否则，它将尝试重用拥有所有权的 `Vec` 的分配。",
        "translate": ""
    },
    {
        "source": "Converts a `Cow<'_, str>` into a `Box<str>`",
        "suggest": "将 `Cow<'_, str>` 转换为 `Box<str>`",
        "translate": ""
    },
    {
        "source": "When `cow` is the `Cow::Borrowed` variant, this conversion allocates on the heap and copies the underlying `str`.",
        "suggest": "当 `cow` 是 `Cow::Borrowed` 成员时，此转换在堆上分配并复制底层 `str`。",
        "translate": ""
    },
    {
        "source": "Otherwise, it will try to reuse the owned `String`'s allocation.",
        "suggest": "否则，它将尝试重用拥有所有权的 `String` 的分配。",
        "translate": ""
    },
    {
        "source": "Attempts to convert a `Box<[T]>` into a `Box<[T; N]>`.",
        "suggest": "尝试将 `Box<[T]>` 转换为 `Box<[T; N]>`。",
        "translate": ""
    },
    {
        "source": "The conversion occurs in-place and does not require a new memory allocation.",
        "suggest": "转换就地发生，不需要新的内存分配。",
        "translate": ""
    },
    {
        "source": "Returns the old `Box<[T]>` in the `Err` variant if `boxed_slice.len()` does not equal `N`.",
        "suggest": "如果 `boxed_slice.len()` 不等于 `N`，则返回 `Err` 成员中的旧 `Box<[T]>`。",
        "translate": ""
    },
    {
        "source": "Creates an array `[T; N]` where each array element `T` is returned by the `cb` call.",
        "suggest": "创建一个数组 `[T; N]`，其中每个数组元素 `T` 都由 `cb` 调用返回。",
        "translate": ""
    },
    {
        "source": "Callback where the passed argument is the current array index.",
        "suggest": "回调，其中传递的参数是当前数组索引。",
        "translate": ""
    },
    {
        "source": "Creates an array `[T; N]` where each fallible array element `T` is returned by the `cb` call.",
        "suggest": "创建一个数组 `[T; N]`，其中每个易出错的数组元素 `T` 由 `cb` 调用返回。",
        "translate": ""
    },
    {
        "source": "Unlike `core::array::from_fn`, where the element creation can't fail, this version will return an error if any element creation was unsuccessful.",
        "suggest": "与 `core::array::from_fn` 不同，元素创建不能失败，如果任何元素创建失败，此版本将返回错误。",
        "translate": ""
    },
    {
        "source": "Infallible version of `collect_into_array_rslt_unchecked`.",
        "suggest": "`collect_into_array_rslt_unchecked` 的可靠版本。",
        "translate": ""
    },
    {
        "source": "The same safety considerations w.r.t.",
        "suggest": "相同的安全注意事项",
        "translate": ""
    },
    {
        "source": "the iterator length apply for `collect_into_array_rslt_unchecked` as for",
        "suggest": "迭代器长度适用于 `collect_into_array_rslt_unchecked`",
        "translate": ""
    },
    {
        "source": "this slice will contain only initialized objects.",
        "suggest": "这个切片将只包含初始化的对象。",
        "translate": ""
    },
    {
        "source": "Swaps the values of two `Cell`s.",
        "suggest": "交换两个 `Cell` 的值。",
        "translate": ""
    },
    {
        "source": "Prefix collisions",
        "suggest": "前缀冲突",
        "translate": ""
    },
    {
        "source": "Implementations of `hash` should ensure that the data they pass to the `Hasher` are prefix-free.",
        "suggest": "`hash` 的实现应该确保它们传递给 `Hasher` 的数据是无前缀的。",
        "translate": ""
    },
    {
        "source": "That is, unequal values should cause two different sequences of values to be written, and neither of the two sequences should be a prefix of the other.",
        "suggest": "也就是说，不相等的值应该导致写入两个不同的值序列，并且两个序列中的任何一个都不应该是另一个的前缀。",
        "translate": ""
    },
    {
        "source": "For example, the standard implementation of [`Hash` for `&str`][impl] passes an extra `0xFF` byte to the `Hasher` so that the values `(\"ab\", \"c\")` and `(\"a\", \"bc\")` hash differently.",
        "suggest": "例如，[`Hash` for `&str`][impl] 的标准实现将额外的 `0xFF` 字节传递给 `Hasher`，以便值 `(\"ab\", \"c\")` 和 `(\"a\", \"bc\")` 哈希不同。",
        "translate": ""
    },
    {
        "source": "Checked addition with an unsigned integer.",
        "suggest": "用无符号整数检查加法。",
        "translate": ""
    },
    {
        "source": "Checked subtraction with an unsigned integer.",
        "suggest": "用无符号整数检查减法。",
        "translate": ""
    },
    {
        "source": "Saturating addition with an unsigned integer.",
        "suggest": "使用无符号整数进行饱和加法。",
        "translate": ""
    },
    {
        "source": "Overflow can only happen at the upper bound We cannot use `unwrap_or` here because it is not `const`",
        "suggest": "溢出只能发生在上限，我们不能在这里使用 `unwrap_or`，因为它不是 `const`",
        "translate": ""
    },
    {
        "source": "Saturating subtraction with an unsigned integer.",
        "suggest": "使用无符号整数进行饱和减法。",
        "translate": ""
    },
    {
        "source": "Overflow can only happen at the lower bound We cannot use `unwrap_or` here because it is not `const`",
        "suggest": "溢出只能发生在下限，我们不能在这里使用 `unwrap_or`，因为它不是 `const`",
        "translate": ""
    },
    {
        "source": "Wrapping (modular) addition with an unsigned integer.",
        "suggest": "用无符号整数包装 (modular) 加法。",
        "translate": ""
    },
    {
        "source": "Wrapping (modular) subtraction with an unsigned integer.",
        "suggest": "用无符号整数包装 (modular) 减法。",
        "translate": ""
    },
    {
        "source": "Calculates `self` + `rhs` with an unsigned `rhs`",
        "suggest": "使用无符号 `rhs` 计算 `self` + `rhs`",
        "translate": ""
    },
    {
        "source": "Calculates `self` - `rhs` with an unsigned `rhs`",
        "suggest": "使用无符号 `rhs` 计算 `self`-`rhs`",
        "translate": ""
    },
    {
        "source": "Returns the logarithm of the number with respect to an arbitrary base, rounded down.",
        "suggest": "返回数字相对于任意底数的对数，向下取整。",
        "translate": ""
    },
    {
        "source": "it panics in debug mode and the return value is 0 in release mode.",
        "suggest": "它在调试模式下为 panics，在生产模式下返回值为 0。",
        "translate": ""
    },
    {
        "source": "Returns the base 2 logarithm of the number, rounded down.",
        "suggest": "返回数字的以 2 为底的对数，向下取整。",
        "translate": ""
    },
    {
        "source": "When the number is zero it panics in debug mode and the return value is 0 in release mode.",
        "suggest": "当数字为零时，它在调试模式下为 panics，在生产模式下返回值为 0。",
        "translate": ""
    },
    {
        "source": "Returns the base 10 logarithm of the number, rounded down.",
        "suggest": "返回数字的以 10 为底的对数，向下取整。",
        "translate": ""
    },
    {
        "source": "NaN (not a number): this value results from calculations like `(-1.0).sqrt()`.",
        "suggest": "NaN (不是数字) : 这个值来自于类似于 `(-1.0).sqrt()` 等的计算得出。",
        "translate": ""
    },
    {
        "source": "See [the documentation for `f32`](f32) for more information on the unusual properties of NaN.",
        "suggest": "有关 NaN 的独特属性的更多信息，请参见 [`f32` 的文档](f32)。",
        "translate": ""
    },
    {
        "source": "Positive or negative infinity, which often results from dividing a nonzero number by zero.",
        "suggest": "正无穷大或负无穷大，通常由非零数除以零产生。",
        "translate": ""
    },
    {
        "source": "See [the documentation for `f32`](f32) for more information on the signedness of zeroes.",
        "suggest": "有关零的符号性的更多信息，请参见 [`f32` 的文档](f32)。",
        "translate": ""
    },
    {
        "source": "Subnormal” or “denormal” floating point representation (less precise, relative to their magnitude, than [`Normal`]).",
        "suggest": "subnormal” 或 “denormal” 浮点表示 (相对于它们的大小，不如 [`Normal`] 精确)。",
        "translate": ""
    },
    {
        "source": "Subnormal numbers are larger in magnitude than [`Zero`] but smaller in magnitude than all [`Normal`] numbers.",
        "suggest": "subnormal 数在数量级上比 [`Zero`] 大，但在数量级上小于所有 [`Normal`] 数。",
        "translate": ""
    },
    {
        "source": "A regular floating point number, not any of the exceptional categories.",
        "suggest": "常规浮点数，不是任何特殊类别。",
        "translate": ""
    },
    {
        "source": "The smallest positive normal numbers are [`f32::MIN_POSITIVE`] and [`f64::MIN_POSITIVE`], and the largest positive normal numbers are [`f32::MAX`] and [`f64::MAX`].",
        "suggest": "最小的 positive normal 数是 [`f32::MIN_POSITIVE`] 和 [`f64::MIN_POSITIVE`]，最大的 positive normal 数是 [`f32::MAX`] 和 [`f64::MAX`]。",
        "translate": ""
    },
    {
        "source": "(Unlike signed integers, floating point numbers are symmetric in their range, so negating any of these constants will produce their negative counterpart.)",
        "suggest": "(与有符号整数不同，浮点数在其范围内是对称的，因此否定这些常量中的任何一个都会产生它们的负对应项。)",
        "translate": ""
    },
    {
        "source": "Checked addition with a signed integer.",
        "suggest": "用有符号整数检查加法。",
        "translate": ""
    },
    {
        "source": "When the number is negative or zero it panics in debug mode and the return value is 0 in release mode.",
        "suggest": "当数字为负数或零时，它在调试模式下为 panics，在生产模式下的返回值为 0。",
        "translate": ""
    },
    {
        "source": "Saturating addition with a signed integer.",
        "suggest": "带符号整数的饱和加法。",
        "translate": ""
    },
    {
        "source": "Wrapping (modular) addition with a signed integer.",
        "suggest": "用有符号整数包装 (modular) 加法。",
        "translate": ""
    },
    {
        "source": "Calculates `self` + `rhs` with a signed `rhs`",
        "suggest": "使用带符号的 `rhs` 计算 `self` + `rhs`",
        "translate": ""
    },
    {
        "source": "When return value overflows (i.e., `self > (1 << (N-1))` for type `uN`), it panics in debug mode and the return value is wrapped to 0 in release mode (the only situation in which method can return 0).",
        "suggest": "当返回值溢出 (即 `uN` 类型为 `self > (1 << (N-1))`) 时，它在调试模式下为 panics，在生产模式下返回值被包装为 0 (方法可以返回 0 的唯一情况)。",
        "translate": ""
    },
    {
        "source": "Maps a `Result<T, E>` to `U` by applying fallback function `default` to a contained [`Err`] value, or function `f` to a contained [`Ok`] value.",
        "suggest": "通过将 fallback 函数 `default` 应用于包含的 [`Err`] 值，或将函数 `f` 应用于包含的 [`Ok`] 值，将 `Result<T, E>` 映射为 `U`。",
        "translate": ""
    },
    {
        "source": "When combined with the `?` operator, this function will propogate any [`Poll::Pending`] values to the caller, and extract the `T` from [`Poll::Ready`].",
        "suggest": "当与 `?` 运算符结合使用时，该函数会将任何 [`Poll::Pending`] 值传播给调用者，并从 [`Poll::Ready`] 中提取 `T`。",
        "translate": ""
    },
    {
        "source": "See [`Poll::ready`] for details.",
        "suggest": "有关详细信息，请参见 [`Poll::ready`]。",
        "translate": ""
    },
    {
        "source": "Indicates how much extra capacity is needed to read the rest of the file.",
        "suggest": "指示读取文件的其余部分需要多少额外容量。",
        "translate": ""
    },
    {
        "source": "Reserves space in the buffer based on the file size when available.",
        "suggest": "根据可用的文件大小在缓冲区中保留空间。",
        "translate": ""
    },
    {
        "source": "The inner reader might have an optimized `read_to_end`.",
        "suggest": "内部 reader 可能具有优化的 `read_to_end`。",
        "translate": ""
    },
    {
        "source": "Drain our buffer and then delegate to the inner implementation.",
        "suggest": "耗尽我们的缓冲区，然后委托给内部实现。",
        "translate": ""
    },
    {
        "source": "In the general `else` case below we must read bytes into a side buffer, check that they are valid UTF-8, and then append them to `buf`.",
        "suggest": "在下面的一般 `else` 情况下，我们必须将字节读入一个 side 缓冲区，检查它们是否是有效的 UTF-8，然后将它们附加到 `buf`。",
        "translate": ""
    },
    {
        "source": "This requires a potentially large memcpy.",
        "suggest": "这需要一个潜在的大型 memcpy。",
        "translate": ""
    },
    {
        "source": "If `buf` is empty--the most common case--we can leverage `append_to_string` to read directly into `buf`'s internal byte buffer, saving an allocation and a memcpy.",
        "suggest": "如果 `buf` 为空 -- 最常见的情况 -- 我们可以利用 `append_to_string` 直接读入 `buf` 的内部字节缓冲区，从而保存分配和 memcpy。",
        "translate": ""
    },
    {
        "source": "`append_to_string`'s safety relies on the buffer only being appended to since it only checks the UTF-8 validity of new data.",
        "suggest": "`append_to_string` 的安全性仅依赖于被附加到的缓冲区，因为它只检查新数据的 UTF-8 有效性。",
        "translate": ""
    },
    {
        "source": "If there were existing content in `buf` then an untrustworthy reader (i.e.",
        "suggest": "如果 `buf` 中存在现有内容，那么不可信的 reader (即",
        "translate": ""
    },
    {
        "source": "`self.inner`) could not only append bytes but also modify existing bytes and render them invalid.",
        "suggest": "`self.inner`) 不仅可以追加字节，还可以修改现有字节并使它们无效。",
        "translate": ""
    },
    {
        "source": "On the other hand, if `buf` is empty then by definition any writes must be appends and `append_to_string` will validate all of the new bytes.",
        "suggest": "另一方面，如果 `buf` 为空，则根据定义，任何写入都必须附加，并且 `append_to_string` 将验证所有新字节。",
        "translate": ""
    },
    {
        "source": "We cannot append our byte buffer directly onto the `buf` String as there could be an incomplete UTF-8 sequence that has only been partially read.",
        "suggest": "我们不能将字节缓冲区直接附加到 `buf` 字符串上，因为可能存在仅部分读取的不完整 UTF-8 序列。",
        "translate": ""
    },
    {
        "source": "We must read everything into a side buffer first and then call `from_utf8` on the complete buffer.",
        "suggest": "我们必须首先将所有内容读入 side 缓冲区，然后在整个缓冲区上调用 `from_utf8`。",
        "translate": ""
    },
    {
        "source": "Several `read_to_string` and `read_line` methods in the standard library will append data into a `String` buffer, but we need to be pretty careful when doing this.",
        "suggest": "标准库中的几个 `read_to_string` 和 `read_line` 方法会将数据附加到 `String` 缓冲区中，但我们在执行此操作时需要非常小心。",
        "translate": ""
    },
    {
        "source": "Note that we do *not* call `r.read_to_end()` here.",
        "suggest": "请注意，我们在这里不调用 `r.read_to_end()`。",
        "translate": ""
    },
    {
        "source": "To prevent extraneously checking the UTF-8-ness of the entire buffer we pass it to our hardcoded `default_read_to_end` implementation which we know is guaranteed to only read data into the end of the buffer.",
        "suggest": "为了防止额外检查整个缓冲区的 UTF-8-ness，我们将它传递给我们的硬编码 `default_read_to_end` 实现，我们知道它保证只将数据读入缓冲区的末尾。",
        "translate": ""
    },
    {
        "source": "Note that in some special cases, such as when reading files, this function will pre-allocate memory based on the size of the input it is reading.",
        "suggest": "请注意，在某些特殊情况下，例如读取文件时，该函数会根据正在读取的输入的大小预先分配内存。",
        "translate": ""
    },
    {
        "source": "In those cases, the performance should be as good as if you had used [`Read::read_to_string`] with a manually pre-allocated buffer.",
        "suggest": "在这些情况下，性能应该与您使用手动预分配缓冲区的 [`Read::read_to_string`] 一样好。",
        "translate": ""
    },
    {
        "source": "requires this flag for stack mapping otherwise the said mapping will fail as a no-op on most systems and has a different meaning on FreeBSD",
        "suggest": "需要这个标志来进行栈映射，否则所述映射将在大多数系统上作为空操作失败，并且在 FreeBSD 上具有不同的含义",
        "translate": ""
    },
    {
        "source": "The caller has to ensure that the spawned thread does not outlive any references in the supplied thread closure and its return type.",
        "suggest": "调用者必须确保新建线程的生命周期不会超过所提供线程闭包及其返回类型中的任何引用。",
        "translate": ""
    },
    {
        "source": "Alias for C++ `std::thread::hardware_concurrency`.",
        "suggest": "C++ `std::thread::hardware_concurrency` 的别名。",
        "translate": ""
    },
    {
        "source": "Alias for a name we gave this API on unstable.",
        "suggest": "我们为这个 API 命名的别名是不稳定的。",
        "translate": ""
    },
    {
        "source": "is from `rust-analyzer/src/cli/analysis_stats.rs`.",
        "suggest": "是来自于 `rust-analyzer/src/cli/analysis_stats.rs`。",
        "translate": ""
    },
    {
        "source": "is from `core/src/hash/mod.rs`.",
        "suggest": "是来自于 `core/src/hash/mod.rs`。",
        "translate": ""
    },
    {
        "source": "Specifically, it is possible to have implementations for two different function pointer types:",
        "suggest": "具体来说，可以实现两种不同的函数指针类型:",
        "translate": ""
    },
    {
        "source": "For better performance, avoid branches by assembling the solution in the bits above the low 8 bits.",
        "suggest": "为了获得更好的性能，通过在低 8 位以上的位中组合解决方案来避免分支。",
        "translate": ""
    },
    {
        "source": "Adding c1 to val gives 10 in the top bits for val < 10, 11 for val >= 10",
        "suggest": "将 c1 添加到 val 时，val < 10 的最高位为 10，val> = 10 时为 11",
        "translate": ""
    },
    {
        "source": "Adding c2 to val gives 01 in the top bits for val < 100, 10 for val >= 100",
        "suggest": "将 c2 添加到 val 时，val < 100 的最高位为 01，val >= 100 时为 10",
        "translate": ""
    },
    {
        "source": "Value of top bits:",
        "suggest": "最高位的值:",
        "translate": ""
    },
    {
        "source": "Similar to u8, when adding one of these constants to val, we get two possible bit patterns above the low 17 bits, depending on whether val is below or above the threshold.",
        "suggest": "与 u8 类似，当将这些常量之一添加到 val 时，我们会根据 val 是否低于或高于阈值，在低 17 位上获得两种可能的位模式。",
        "translate": ""
    },
    {
        "source": "When combined with the `?` operator, this function will propagate any [`Poll::Pending`] values to the caller, and extract the `T` from [`Poll::Ready`].",
        "suggest": "当与 `?` 运算符结合使用时，该函数会将任何 [`Poll::Pending`] 值传播给调用者，并从 [`Poll::Ready`] 中提取 `T`。",
        "translate": ""
    },
    {
        "source": "Returns an estimate of the default amount of parallelism a program should use.",
        "suggest": "返回程序应该使用的默认并行量的估计值。",
        "translate": ""
    },
    {
        "source": "Parallelism is a resource.",
        "suggest": "并行性是一种资源。",
        "translate": ""
    },
    {
        "source": "A given machine provides a certain capacity for parallelism, i.e., a bound on the number of computations it can perform simultaneously.",
        "suggest": "给定的机器提供一定的并行能力，即它可以同时执行的计算数量的界限。",
        "translate": ""
    },
    {
        "source": "This number often corresponds to the amount of CPUs or computer has, but it may diverge in various cases.",
        "suggest": "这个数字通常对应于 CPU 或计算机的数量，但在各种情况下可能会有所不同。",
        "translate": ""
    },
    {
        "source": "Host environments such as VMs or container orchestrators may want to restrict the amount of parallelism made available to programs in them.",
        "suggest": "虚拟机或容器编排器等主机环境可能希望限制其中的程序可用的并行量。",
        "translate": ""
    },
    {
        "source": "This is often done to limit the potential impact of (unintentionally) resource-intensive programs on other programs running on the same machine.",
        "suggest": "这样做通常是为了限制 (非故意地) 资源密集型程序对同一台机器上运行的其他程序的潜在影响。",
        "translate": ""
    },
    {
        "source": "The purpose of this API is to provide an easy and portable way to query the default amount of parallelism the program should use.",
        "suggest": "此 API 的目的是提供一种简单且可移植的方式来查询程序应使用的默认并行量。",
        "translate": ""
    },
    {
        "source": "Among other things it does not expose information on NUMA regions, does not account for differences in (co)processor capabilities, and will not modify the program's global state in order to more accurately query the amount of available parallelism.",
        "suggest": "除其他外，它不公开有关 NUMA 区域的信息，不考虑 (协同) 处理器功能的差异，并且不会为了更准确地查询可用并行度的数量而修改程序的整体状态。",
        "translate": ""
    },
    {
        "source": "The value returned by this function should be considered a simplified approximation of the actual amount of parallelism available at any given time.",
        "suggest": "这个函数返回的值应该被认为是任何给定时间可用的实际并行量的简化近似值。",
        "translate": ""
    },
    {
        "source": "To get a more detailed or precise overview of the amount of parallelism available to the program, you may wish to use platform-specific APIs as well.",
        "suggest": "要更详细或更准确地了解程序可用的并行量，您可能还希望使用特定于平台的 API。",
        "translate": ""
    },
    {
        "source": "The following platform limitations currently apply to `available_parallelism`:",
        "suggest": "以下平台限制目前适用于 `available_parallelism`:",
        "translate": ""
    },
    {
        "source": "It may undercount the amount of parallelism available on systems with more than 64 logical CPUs.",
        "suggest": "它可能会低估具有超过 64 个逻辑 CPU 的系统上可用的并行量。",
        "translate": ""
    },
    {
        "source": "However, programs typically need specific support to take advantage of more than 64 logical CPUs, and in the absence of such support, the number returned by this function accurately reflects the number of logical CPUs the program can use by default.",
        "suggest": "但是，程序通常需要特定的支持才能利用超过 64 个逻辑 CPU，而在没有这种支持的情况下，此函数返回的数字准确地反映了程序默认可以使用的逻辑 CPU 的数量。",
        "translate": ""
    },
    {
        "source": "It may overcount the amount of parallelism available on systems limited by process-wide affinity masks, or job object limitations.",
        "suggest": "它可能会过度计算系统上可用的并行量，这些并行量受到进程范围的相似性屏蔽或作业对象限制的限制。",
        "translate": ""
    },
    {
        "source": "It may overcount the amount of parallelism available when limited by a process-wide affinity mask, or when affected by cgroup limits.",
        "suggest": "当受到进程范围的相似性掩码限制时，或者受到组限制的影响时，它可能会过度计算可用的并行量。",
        "translate": ""
    },
    {
        "source": "On all targets:",
        "suggest": "在所有目标上:",
        "translate": ""
    },
    {
        "source": "It may overcount the amount of parallelism available when running in a VM with CPU usage limits (e.g. an overcommitted host).",
        "suggest": "当在具有 CPU 使用限制的 VM 中运行时 (例如过载的主机)，它可能会过度计算可用的并行量。",
        "translate": ""
    },
    {
        "source": "This function will, but is not limited to, return errors in the following cases:",
        "suggest": "在以下情况下，此函数将返回错误，但不限于此:",
        "translate": ""
    },
    {
        "source": "If the amount of parallelism is not known for the target platform.",
        "suggest": "如果目标平台的并行量未知。",
        "translate": ""
    },
    {
        "source": "If the program lacks permission to query the amount of parallelism made available to it.",
        "suggest": "如果程序没有查询可用的并行量的权限。",
        "translate": ""
    },
    {
        "source": "Alias for a previous name we gave this API on unstable.",
        "suggest": "我们为这个 API 提供了不稳定的前一个名称的别名。",
        "translate": ""
    },
    {
        "source": "Alias for a popular ecosystem crate which provides similar functionality.",
        "suggest": "提供类似功能的流行生态系统 crate 的别名。",
        "translate": ""
    },
    {
        "source": "Copies all values from `src` to `dst`, wrapping around if needed.",
        "suggest": "将所有值从 `src` 复制到 `dst`，并在需要时进行包装。",
        "translate": ""
    },
    {
        "source": "Assumes capacity is sufficient.",
        "suggest": "假设容量足够。",
        "translate": ""
    },
    {
        "source": "Update pointers after copying to avoid leaving doppelganger in case of panics.",
        "suggest": "复制后更新指针，以避免在 panics 的情况下留下分身。",
        "translate": ""
    },
    {
        "source": "Silently drop values in `other`.",
        "suggest": "默默地丢弃 `other` 中的值。",
        "translate": ""
    },
    {
        "source": "Consumes and leaks the `Vec`, returning a mutable reference to the contents, `&'a mut [T]`.",
        "suggest": "消耗并泄漏 `Vec`，返回对内容的可变引用，`&'a mut [T]`。",
        "translate": ""
    },
    {
        "source": "As of Rust 1.57, this method does not reallocate or shrink the `Vec`, so the leaked allocation may include unused capacity that is not part of the returned slice.",
        "suggest": "从 Rust 1.57 开始，此方法不会重新分配或收缩 `Vec`，因此泄漏的分配可能包括不属于返回切片的未使用的容量。",
        "translate": ""
    },
    {
        "source": "Selects which function to call depending on the context.",
        "suggest": "根据上下文选择要调用的函数。",
        "translate": ""
    },
    {
        "source": "If this function is evaluated at compile-time, then a call to this intrinsic will be replaced with a call to `called_in_const`.",
        "suggest": "如果在编译时对该函数求值，那么这个内部函数的调用将被替换为 `called_in_const` 的调用。",
        "translate": ""
    },
    {
        "source": "It gets replaced with a call to `called_at_rt` otherwise.",
        "suggest": "否则，它会被替换为对 `called_at_rt` 的调用。",
        "translate": ""
    },
    {
        "source": "Type Requirements",
        "suggest": "类型要求",
        "translate": ""
    },
    {
        "source": "The two functions must be both function items.",
        "suggest": "这两个函数必须都是函数项。",
        "translate": ""
    },
    {
        "source": "They cannot be function pointers or closures.",
        "suggest": "它们不能是函数指针或闭包。",
        "translate": ""
    },
    {
        "source": "will be the arguments that will be passed to either one of the two functions, therefore, both functions must accept the same type of arguments.",
        "suggest": "将是将传递给两个函数之一的参数，因此，两个函数必须接受相同类型的参数。",
        "translate": ""
    },
    {
        "source": "Both functions must return RET.",
        "suggest": "两个函数都必须返回 RET。",
        "translate": ""
    },
    {
        "source": "This intrinsic allows breaking [referential transparency] in `const fn` and is therefore `unsafe`.",
        "suggest": "这个内部函数允许在 `const fn` 中破坏 [引用透明性][referential transparency]，因此是 `unsafe` 的。",
        "translate": ""
    },
    {
        "source": "Code that uses this intrinsic must be extremely careful to ensure that `const fn`s remain referentially-transparent independently of when they are evaluated.",
        "suggest": "使用这个内部函数的代码必须非常小心，以确保 `const fn`s 在它们被计算时保持引用透明。",
        "translate": ""
    },
    {
        "source": "The Rust compiler assumes that it is sound to replace a call to a `const fn` with the result produced by evaluating it at compile-time.",
        "suggest": "Rust 编译器假定将调用替换为 `const fn` 是合理的，它是在编译时对其求值所产生的结果。",
        "translate": ""
    },
    {
        "source": "If evaluating the function at run-time were to produce a different result, or have any other observable side-effects, the behavior is undefined.",
        "suggest": "如果在运行时评估函数会产生不同的结果，或者有任何其他可观察到的副作用，则行为是未定义的。",
        "translate": ""
    },
    {
        "source": "we know that 1 and 3 are both indices of the slice",
        "suggest": "我们知道 1 和 3 都是切片的索引",
        "translate": ""
    },
    {
        "source": "we just checked that both `a` and `b` are in bounds",
        "suggest": "我们刚刚检查了 `a` 和 `b` 都在边界内",
        "translate": ""
    },
    {
        "source": "Swaps two elements in the slice, without doing bounds checking.",
        "suggest": "在不做边界检查的情况下交换切片中的两个元素。",
        "translate": ""
    },
    {
        "source": "For a safe alternative see [`swap`].",
        "suggest": "有关安全的替代方案，请参见 [`swap`]。",
        "translate": ""
    },
    {
        "source": "Calling this method with an out-of-bounds index is *[undefined behavior]*.",
        "suggest": "使用越界索引调用此方法是 [未定义的行为][undefined behavior]。",
        "translate": ""
    },
    {
        "source": "The caller has to ensure that `a < self.len()` and `b < self.len()`.",
        "suggest": "调用者必须保证 `a < self.len()` 和 `b < self.len()`。",
        "translate": ""
    },
    {
        "source": "caller has to guarantee that `a < self.len()` and `b < self.len()`",
        "suggest": "调用者必须保证 `a < self.len()` 和 `b < self.len()`",
        "translate": ""
    },
    {
        "source": "The error type is specific to the implementation of the trait.",
        "suggest": "错误类型特定于 trait 的实现。",
        "translate": ""
    },
    {
        "source": "For reference, the `std` library requires `AtomicBool`s and pointer-sized atomics, although `core` does not.",
        "suggest": "作为参考，`std` 库需要 `AtomicBool`s 和 pointer-sized atomics，尽管 `core` 不需要。",
        "translate": ""
    },
    {
        "source": "Returns the contents of this address if it is an abstract namespace without the leading null byte.",
        "suggest": "如果它是一个没有前导空字节的抽象命名空间，则返回此地址的内容。",
        "translate": ""
    },
    {
        "source": "Creates an abstract domain socket address from a namespace",
        "suggest": "从命名空间创建抽象域套接字地址",
        "translate": ""
    },
    {
        "source": "An abstract address does not create a file unlike traditional path-based Unix sockets.",
        "suggest": "与传统的基于路径的 Unix 套接字不同，抽象地址不会创建文件。",
        "translate": ""
    },
    {
        "source": "The advantage of this is that the address will disappear when the socket bound to it is closed, so no filesystem clean up is required.",
        "suggest": "这样做的好处是当绑定到它的套接字关闭时，地址将消失，因此不需要清理文件系统。",
        "translate": ""
    },
    {
        "source": "The leading null byte for the abstract namespace is automatically added.",
        "suggest": "自动添加抽象命名空间的前导空字节。",
        "translate": ""
    },
    {
        "source": "This is a Linux-specific extension.",
        "suggest": "这是一个特定于 Linux 的扩展。",
        "translate": ""
    },
    {
        "source": "See more at [`unix(7)`].",
        "suggest": "有关详细信息，请参见 [`unix(7)`]。",
        "translate": ""
    },
    {
        "source": "This will return an error if the given namespace is too long",
        "suggest": "如果给定的命名空间太长，这将返回一个错误",
        "translate": ""
    },
    {
        "source": "Creates a Unix datagram socket bound to an address.",
        "suggest": "创建绑定到地址的 Unix 数据报套接字。",
        "translate": ""
    },
    {
        "source": "Connects the socket to the specified path address.",
        "suggest": "将套接字连接到指定的路径地址。",
        "translate": ""
    },
    {
        "source": "Connects the socket to an address.",
        "suggest": "将套接字连接到一个地址。",
        "translate": ""
    },
    {
        "source": "Sends data on the socket to the specified [SocketAddr].",
        "suggest": "将套接字上的数据发送到指定的 [SocketAddr]。",
        "translate": ""
    },
    {
        "source": "Creates a new `UnixListener` bound to the specified [`socket address`].",
        "suggest": "创建绑定到指定 [套接字地址][`socket address`] 的新 `UnixListener`。",
        "translate": ""
    },
    {
        "source": "Connects to the socket specified by [`address`].",
        "suggest": "连接到 [`address`] 指定的套接字。",
        "translate": ""
    },
    {
        "source": "set by connect_addr",
        "suggest": "由 connect_addr 设置",
        "translate": ""
    },
    {
        "source": "The upper four bits gives the minor version.",
        "suggest": "高四位给出了次要版本。",
        "translate": ""
    },
    {
        "source": "ReadConsoleW returns success with ERROR_OPERATION_ABORTED for Ctrl-C or Ctrl-Break.",
        "suggest": "对于 Ctrl-C 或 Ctrl-Break，ReadConsoleW 使用 ERROR_OPERATION_ABORTED 返回成功。",
        "translate": ""
    },
    {
        "source": "Explicitly check for that case here and try again.",
        "suggest": "在此处明确检查该情况，并进行重试",
        "translate": ""
    },
    {
        "source": "While issues have been seen on arm64 platforms the Arm architecture requires that the counter monotonically increases and that it must provide a uniform view of system time (e.g.",
        "suggest": "虽然在 arm64 平台上已经发现问题，但 Arm 架构要求计数器单调增加，并且必须提供系统时间的统一视图 (例如",
        "translate": ""
    },
    {
        "source": "it must not be possible for a core to recieve a message from another core with a time stamp and observe time going backwards (ARM DDI 0487G.b D11.1.2).",
        "suggest": "一个核心不可能接收到来自另一个具有时间戳的核心的消息，并观察到时间倒流 (ARM DDI 0487G.b D11.1.2)。",
        "translate": ""
    },
    {
        "source": "While there have been a few 64bit SoCs that have bugs which cause time to not monoticially increase, these have been fixed in the Linux kernel and we shouldn't penalize all Arm SoCs for those who refuse to update their kernels:",
        "suggest": "虽然有一些 64 位 SoC 存在错误，导致时间不会单方面增加，但这些问题已在 Linux 内核中得到解决，我们不应该对那些拒绝更新内核的人而惩罚所有的 Arm SoC:",
        "translate": ""
    },
    {
        "source": "SUN50I_ERRATUM_UNKNOWN1 - Allwinner A64 / Pine A64 - fixed in 5.1 FSL_ERRATUM_A008585 - Freescale LS2080A/LS1043A - fixed in 4.10 HISILICON_ERRATUM_161010101 - Hisilicon 1610 - fixed in 4.11 ARM64_ERRATUM_858921 - Cortex A73 - fixed in 4.12",
        "suggest": "SUN50I_ERRATUM_UNKNOWN1 - Allwinner A64 / Pine A64 - 在 5.1 中修复 FSL_ERRATUM_A008585 - Freescale LS2080A/LS1043A - 在 4.10 中修复 HISILICON_ERRATUM_161010101 - Hisilicon 1610 - 在 4.11 中修复 ARM64_ERRATUM_858921 - Cortex A73 - 在 4.12 中修复",
        "translate": ""
    },
    {
        "source": "Library features:",
        "suggest": "库特征:",
        "translate": ""
    },
    {
        "source": "Not necessary, but here to test the `nll` feature.",
        "suggest": "没有必要，但在这里测试 `nll` 特征。",
        "translate": ""
    },
    {
        "source": "Rustdoc features:",
        "suggest": "Rustdoc 特征:",
        "translate": ""
    },
    {
        "source": "Determines if a value should use exponential based on its magnitude, given the precondition that it will not be rounded any further before it is displayed.",
        "suggest": "确定一个值是否应该基于其大小使用指数，前提是它在显示之前不会进一步四舍五入。",
        "translate": ""
    },
    {
        "source": "this behavior of {:.PREC?} predates exponential formatting for {:?}",
        "suggest": "{:.PREC?} 的这种行为早于 {:?} 的指数格式",
        "translate": ""
    },
    {
        "source": "since there is no precision, there will be no rounding",
        "suggest": "因为没有精度，就不会有四舍五入",
        "translate": ""
    },
    {
        "source": "Since SourceIter forwards the left hand side we do the same here",
        "suggest": "由于 SourceIter 转发到了左手边，所以我们在这里也这样做",
        "translate": ""
    },
    {
        "source": "If this is changed to sometimes return None, deal with that case in std::panicking::default_hook and core::panicking::panic_fmt.",
        "suggest": "如果将其更改为有时返回 None，请在 std::panicking::default_hook 和 core::panicking::panic_fmt 中处理这种情况。",
        "translate": ""
    },
    {
        "source": "Bypassing libc for `clone3` can make further libc calls unsafe, so we use it sparingly for now.",
        "suggest": "为 `clone3` 绕过 libc 会使进一步的 libc 调用变得不安全，所以我们现在很少使用它。",
        "translate": ""
    },
    {
        "source": "See #89522 for details.",
        "suggest": "有关详细信息，请参见 #89522。",
        "translate": ""
    },
    {
        "source": "Some tools (e.g. sandboxing tools) may also expect `fork` rather than `clone3`.",
        "suggest": "一些工具 (例如沙箱工具) 也可能期望 `fork` 而不是 `clone3`。",
        "translate": ""
    },
    {
        "source": "Generally, we just call `fork`.",
        "suggest": "通常，我们只是调用 `fork`。",
        "translate": ""
    },
    {
        "source": "If we get here after wanting `clone3`, then the syscall does not exist or we do not have permission to call it.",
        "suggest": "如果我们在想要 `clone3` 之后到达这里，那么系统调用不存在，或者我们没有调用它的权限。",
        "translate": ""
    },
    {
        "source": "The behavior resulting from such a logic error is not specified (it could include panics, incorrect results, aborts, memory leaks, or non-termination) but will not be undefined behavior.",
        "suggest": "没有指定由此类逻辑错误导致的行为 (可能包括 panics、不正确的结果、中止、内存泄漏或未终止)，但不会是未定义的行为。",
        "translate": ""
    },
    {
        "source": "Using linear search, searching for a random element is expected to take B * log(n) comparisons, which is generally worse than a BST.",
        "suggest": "使用线性搜索，搜索随机元素预计需要进行` B * log(n)` 次比较，这通常比 `BST` 差。",
        "translate": ""
    },
    {
        "source": "This function is unsafe because the returned `&mut Vec` allows writing bytes which are not valid UTF-8.",
        "suggest": "这个函数是不安全的，因为返回的 `&mut Vec` 允许写入无效的 UTF-8 字节。",
        "translate": ""
    },
    {
        "source": "If this constraint is violated, using the original `String` after dropping the `&mut Vec` may violate memory safety, as the rest of the standard library assumes that `String`s are valid UTF-8.",
        "suggest": "如果违反此约束，则在丢弃 `&mut Vec` 后使用原始 `String` 可能会违反内存安全，因为标准库的其余部分假定 `String` 是有效的 UTF-8。",
        "translate": ""
    },
    {
        "source": "The macOS linker emits a \"compact\" unwind table that only includes an entry for a function if that function either has an LSDA or its encoding differs from that of the previous entry.",
        "suggest": "macOS 链接器发出一个 \"compact\" 展开表，如果函数有 LSDA 或其编码与前一个条目不同，则该表只包含该函数的一个条目。",
        "translate": ""
    },
    {
        "source": "Consequently, on macOS, `_Unwind_FindEnclosingFunction` is unreliable (it can return a pointer to some totally unrelated function).",
        "suggest": "因此，在 macOS 上，`_Unwind_FindEnclosingFunction` 是不可靠的 (它可以返回一个指向一些完全不相关的函数的指针)。",
        "translate": ""
    },
    {
        "source": "Instead, we just always return the ip.",
        "suggest": "相反，我们总是返回 ip。",
        "translate": ""
    },
    {
        "source": "Note the `skip_inner_frames.rs` test is skipped on macOS due to this clause, and if this is fixed that test in theory can be run on macOS!",
        "suggest": "请注意，由于此条款，在 macOS 上跳过了 `skip_inner_frames.rs` 测试，如果修复了该问题，理论上可以在 macOS 上运行该测试！",
        "translate": ""
    },
    {
        "source": "This function performs the same function as `resolve` except that it takes a `Frame` as an argument instead of an address.",
        "suggest": "该函数执行与 `resolve` 相同的函数，只是它将 `Frame` 作为参数而不是地址。",
        "translate": ""
    },
    {
        "source": "Divides one array reference into two at an index.",
        "suggest": "在一个索引处将一个数组的引用分成两个。",
        "translate": ""
    },
    {
        "source": "The first will contain all indices from `[0, M)` (excluding the index `M` itself) and the second will contain all indices from `[M, N)` (excluding the index `N` itself).",
        "suggest": "第一个将包含来自 `[0, M)` 的所有索引 (不包括索引 `M` 本身)，第二个将包含来自 `[M, N)` 的所有索引 (不包括索引 `N` 本身)。",
        "translate": ""
    },
    {
        "source": "Divides one mutable array reference into two at an index.",
        "suggest": "在一个索引处将一个可变数组的引用分成两个。",
        "translate": ""
    },
    {
        "source": "Equivalent to the non-const version, with the addition of `rustc_const_unstable`",
        "suggest": "与非常量版本相同，增加了 `rustc_const_unstable`",
        "translate": ""
    },
    {
        "source": "needed for `non-fmt-panics` lint",
        "suggest": "`non-fmt-panics` lint 需要",
        "translate": ""
    },
    {
        "source": "hooked by const-eval",
        "suggest": "被 const-eval hook 了",
        "translate": ""
    },
    {
        "source": "Divides one slice into an array and a remainder slice at an index.",
        "suggest": "将一个切片分成一个数组和一个索引处的剩余切片。",
        "translate": ""
    },
    {
        "source": "The array will contain all indices from `[0, N)` (excluding the index `N` itself) and the slice will contain all indices from `[N, len)` (excluding the index `len` itself).",
        "suggest": "该数组将包含来自 `[0, N)` 的所有索引 (不包括索引 `N` 本身)，并且切片将包含来自 `[N, len)` 的所有索引 (不包括索引 `len` 本身)。",
        "translate": ""
    },
    {
        "source": "Panics if `N > len`.",
        "suggest": "如果 `N > len`，则产生 panics。",
        "translate": ""
    },
    {
        "source": "a points to [T; N]?",
        "suggest": "一个指针指向了 [T; N]？",
        "translate": ""
    },
    {
        "source": "Yes it's [T] of length N (checked by split_at)",
        "suggest": "是的，它是长度 N 的 [T] (由 split_at 检查)",
        "translate": ""
    },
    {
        "source": "Divides one mutable slice into an array and a remainder slice at an index.",
        "suggest": "将一个可变切片分成一个数组和一个索引处的剩余切片。",
        "translate": ""
    },
    {
        "source": "Yes it's [T] of length N (checked by split_at_mut)",
        "suggest": "是的，它是长度 N 的 [T] (由 split_at_mut 检查)",
        "translate": ""
    },
    {
        "source": "In debug builds checks that `data` pointer is aligned and non-null and that slice with given `len` would cover less than half the address space",
        "suggest": "在调试版本中，检查 `data` 指针是否对齐且不为 null，并且具有给定 `len` 的切片将覆盖不到一半的地址空间",
        "translate": ""
    },
    {
        "source": "is just a debug assert to hint users that they are causing UB, it is not required for safety (the safety must be guatanteed by the `from_raw_parts[_mut]` caller).",
        "suggest": "只是一个调试断言来提示用户他们正在导致未定义的行为，它不是安全所必需的 (安全性必须由 `from_raw_parts[_mut]` 调用者保证)。",
        "translate": ""
    },
    {
        "source": "Since the checks are not required, we ignore them in CTFE as they can't be done there (alignment does not make much sense there).",
        "suggest": "由于不需要检查，我们在 CTFE 中忽略了它们，因为它们不能在那里完成 (在那里对齐没有多大意义)。",
        "translate": ""
    },
    {
        "source": "Returns a slice of the given string from the byte range \\[0, `end`).",
        "suggest": "返回字节范围 \\[0, `end`) 中返回给定字符串的切片。",
        "translate": ""
    },
    {
        "source": "Returns a slice of the given string from the byte range \\[`begin`, `len`).",
        "suggest": "从字节范围 \\[`begin`, `len`) 中返回给定字符串的切片。",
        "translate": ""
    },
    {
        "source": "Equivalent to `&self[begin .. len]` or `&mut self[begin .. len]`.",
        "suggest": "相当于 `&self[begin .. len]` 或 `&mut self[begin .. len]`。",
        "translate": ""
    },
    {
        "source": "Returns a slice of the given string from the byte range \\[0, `end`\\].",
        "suggest": "返回字节范围 \\[0, `end`\\] 中返回给定字符串的切片。",
        "translate": ""
    },
    {
        "source": "Value is not a finite value (either + or - infinity or NaN).",
        "suggest": "值不是一个有限的值 (+ 或 - 无穷大或 NaN)。",
        "translate": ""
    },
    {
        "source": "Value is negative.",
        "suggest": "值是负数。",
        "translate": ""
    },
    {
        "source": "Ensure `fs::create_dir` works on Windows with longer paths.",
        "suggest": "确保 `fs::create_dir` 在具有更长路径的 Windows 上工作。",
        "translate": ""
    },
    {
        "source": "Skip the test in the unlikely event the local user has a long temp directory path.",
        "suggest": "如果本地用户有很长的临时目录路径，请跳过测试。",
        "translate": ""
    },
    {
        "source": "This should not affect CI.",
        "suggest": "这不应该影响 CI。",
        "translate": ""
    },
    {
        "source": "Increase the length of the path.",
        "suggest": "增加路径的长度。",
        "translate": ""
    },
    {
        "source": "This should succeed.",
        "suggest": "这应该会成功。",
        "translate": ""
    },
    {
        "source": "This will fail if the path isn't converted to verbatim.",
        "suggest": "如果路径没有被一字不差地转换，这将会失败。",
        "translate": ""
    },
    {
        "source": "octal zero",
        "suggest": "八进制零",
        "translate": ""
    },
    {
        "source": "all octets are in octal",
        "suggest": "所有八位字节都是八进制的",
        "translate": ""
    },
    {
        "source": "first octet is a zero in octal",
        "suggest": "第一个八位字节是八进制中的零",
        "translate": ""
    },
    {
        "source": "all octets are in hex",
        "suggest": "所有八位字节都是十六进制的",
        "translate": ""
    },
    {
        "source": "Notably, octal numbers (which are indicated with a leading `0`) and hexadecimal numbers (which are indicated with a leading `0x`) are not allowed per [IETF RFC 6943].",
        "suggest": "值得注意的是，每个 [IETF RFC 6943] 不允许使用八进制数 (以 `0` 开头) 和十六进制数 (以 `0x` 开头)。",
        "translate": ""
    },
    {
        "source": "don't try to parse if too long",
        "suggest": "如果太长的话，就不要尝试解析",
        "translate": ""
    },
    {
        "source": "if `self` has a verbatim prefix (e.g.",
        "suggest": "如果 `self` 有 verbatim 前缀 (例如",
        "translate": ""
    },
    {
        "source": "`\\\\?\\C:\\windows`) and `path` is not empty, the new path is normalized: all references to `.` and `..` are removed.",
        "suggest": "`\\\\?\\C:\\windows`) 并且 `path` 不为空，新路径被规范化：所有对 `.` 和 `..` 的引用都被删除。",
        "translate": ""
    },
    {
        "source": "The magic constant -4 can be used as the token passed to GetUserProfileDirectoryW below instead of us having to go through these multiple steps to get a token.",
        "suggest": "魔术常量 -4 可以用作传递给下面的 GetUserProfileDirectoryW 的 token，而不是我们必须通过这些多个步骤来获得 token。",
        "translate": ""
    },
    {
        "source": "However this is not implemented on Windows 7, only Windows 8 and up.",
        "suggest": "然而，没有在 Windows 7 上实现，只在 Windows 8 和更高版本上实现了。",
        "translate": ""
    },
    {
        "source": "When we drop support for Windows 7 we can simplify this code.",
        "suggest": "当我们支持 Windows 7 时，我们可以简化此代码。",
        "translate": ""
    },
    {
        "source": "See #90144 for details.",
        "suggest": "有关详细信息，请参见 #90144。",
        "translate": ""
    },
    {
        "source": "Ensure long paths are correctly prefixed.",
        "suggest": "确保长路径的前缀正确。",
        "translate": ""
    },
    {
        "source": "prefixed paths are left unchanged...",
        "suggest": "前缀路径保持不变...",
        "translate": ""
    },
    {
        "source": "But `//?/` is not a verbatim prefix so it will be normalized.",
        "suggest": "但是 `//?/` 不是 verbatim 前缀，因此它将被规范化。",
        "translate": ""
    },
    {
        "source": "For performance, short absolute paths are left unchanged.",
        "suggest": "为了性能，短绝对路径保持不变。",
        "translate": ""
    },
    {
        "source": "Check that paths of length 247 are converted to verbatim.",
        "suggest": "检查长度为 247 的路径是否已逐字转换。",
        "translate": ""
    },
    {
        "source": "This is necessary for `CreateDirectory`.",
        "suggest": "这对于 `CreateDirectory` 是必需的。",
        "translate": ""
    },
    {
        "source": "Make sure opening a drive will work.",
        "suggest": "确保打开驱动器可以正常工作。",
        "translate": ""
    },
    {
        "source": "An empty path or a path that contains null are not valid paths.",
        "suggest": "空路径或包含 null 的路径不是有效路径。",
        "translate": ""
    },
    {
        "source": "Returns a UTF-16 encoded path capable of bypassing the legacy `MAX_PATH` limits.",
        "suggest": "返回能够绕过传统 `MAX_PATH` 限制的 UTF-16 编码路径。",
        "translate": ""
    },
    {
        "source": "This path may or may not have a verbatim prefix.",
        "suggest": "此路径可能有也可能没有 verbatim 前缀。",
        "translate": ""
    },
    {
        "source": "Normally the MAX_PATH is 260 UTF-16 code units (including the NULL).",
        "suggest": "通常 MAX_PATH 是 260 个 UTF-16 代码单元 (包括 NULL)。",
        "translate": ""
    },
    {
        "source": "However, for APIs such as CreateDirectory[1], the limit is 248.",
        "suggest": "但是，对于 CreateDirectory[1] 等 API，限制为 248 个。",
        "translate": ""
    },
    {
        "source": "encoded code points, used in parsing and building UTF-16 paths.",
        "suggest": "编码的代码点，用于解析和构建 UTF-16 路径。",
        "translate": ""
    },
    {
        "source": "All of these are in the ASCII range so they can be cast directly to `u16`.",
        "suggest": "所有这些都在 ASCII 范围内，因此它们可以直接转换为 `u16`。",
        "translate": ""
    },
    {
        "source": "Early return for paths that are already verbatim.",
        "suggest": "提前返回已经逐字记录的路径。",
        "translate": ""
    },
    {
        "source": "Early return if an absolute path is less < 260 UTF-16 code units.",
        "suggest": "如果绝对路径小于 260 个 UTF-16 代码单元，则提前返回。",
        "translate": ""
    },
    {
        "source": "This is an optimization to avoid calling `GetFullPathNameW` unnecessarily.",
        "suggest": "这是为了避免不必要地调用 `GetFullPathNameW` 的优化。",
        "translate": ""
    },
    {
        "source": "Starts with `D:`, `D:\\`, `D:/`, etc.",
        "suggest": "以 `D:`、`D:\\`、`D:/` 等开头。",
        "translate": ""
    },
    {
        "source": "Does not match if the path starts with a `\\` or `/`.",
        "suggest": "如果路径以 `\\` 或 `/` 开头，则不匹配。",
        "translate": ""
    },
    {
        "source": "Starts with `\\\\`, `//`, etc",
        "suggest": "以 `\\\\`、`//` 等开头",
        "translate": ""
    },
    {
        "source": "Firstly, get the absolute path using `GetFullPathNameW`.",
        "suggest": "首先，使用 `GetFullPathNameW` 获取绝对路径。",
        "translate": ""
    },
    {
        "source": "`fill_utf16_buf` ensures the `buffer` and `size` are valid.",
        "suggest": "`fill_utf16_buf` 确保 `buffer` 和 `size` 有效。",
        "translate": ""
    },
    {
        "source": "is a pointer to a null terminated string that is not invalidated until after `GetFullPathNameW` returns successfully.",
        "suggest": "是一个指向 null 终止字符串的指针，该字符串直到 `GetFullPathNameW` 成功返回后才会失效。",
        "translate": ""
    },
    {
        "source": "While the docs for `GetFullPathNameW` have the standard note about needing a `\\\\?\\` path for a long lpfilename, this does not appear to be true in practice.",
        "suggest": "虽然 `GetFullPathNameW` 的文档有关于需要一个 `\\\\?\\` 路径来获取 long lpfilename 的标准说明，但这在实践中似乎并不正确。",
        "translate": ""
    },
    {
        "source": "Secondly, add the verbatim prefix.",
        "suggest": "其次，添加 verbatim 前缀。",
        "translate": ""
    },
    {
        "source": "This is easier here because we know the path is now absolute and fully normalized (e.g.",
        "suggest": "这在这里更容易，因为我们知道路径现在是绝对的并且完全标准化 (例如",
        "translate": ""
    },
    {
        "source": "has been changed to `\\`).",
        "suggest": "已更改为 `\\`)。",
        "translate": ""
    },
    {
        "source": "Leave \\\\?\\ and \\??\\ as-is.",
        "suggest": "保留 \\\\?\\ 和 \\??\\ 原样。",
        "translate": ""
    },
    {
        "source": "Anything else we leave alone.",
        "suggest": "任何其他的事我们都不去管了。",
        "translate": ""
    },
    {
        "source": "Returns a slice of the given string for the byte range \\[`begin`..`end`).",
        "suggest": "返回字节范围 \\[`begin`..`end`) 的给定字符串的切片。",
        "translate": ""
    },
    {
        "source": "Resource limits can be changed during the runtime of a program, therefore the value is not cached and instead recomputed every time this function is called.",
        "suggest": "资源限制可以在程序运行时更改，因此该值不会被缓存，而是在每次调用此函数时重新计算。",
        "translate": ""
    },
    {
        "source": "It should not be called from hot code.",
        "suggest": "不应从热代码中调用它。",
        "translate": ""
    },
    {
        "source": "Disable dedup guard.",
        "suggest": "禁用重复数据保护。",
        "translate": ""
    },
    {
        "source": "Only works if the LLVM MergeFunctions pass is disabled, e.g.",
        "suggest": "仅当 LLVM 合并函数传递被禁用时有效，例如",
        "translate": ""
    },
    {
        "source": "with `-Z merge-functions=disabled` in RUSTFLAGS.",
        "suggest": "使用 RUSTFLAGS 中的 `-Z merge-functions=disabled`。",
        "translate": ""
    },
    {
        "source": "Private vfp4 version used by FMA intriniscs because LLVM does not inline the non-vfp4 version in vfp4 functions.",
        "suggest": "FMA intriniscs 使用了私有的 vfp4 版本，因为 LLVM 不会在 vfp4 函数中内联非 vfp4 版本。",
        "translate": ""
    },
    {
        "source": "should be vpmovb2m but compiled to vpmovmskb in the test shim because that takes less cycles than",
        "suggest": "应该是 vpmovb2m 但在测试垫片中编译为 vpmovmskb，因为这比",
        "translate": ""
    },
    {
        "source": "using vpmovb2m plus converting the mask register to a standard register.",
        "suggest": "使用 vpmovb2m plus 将掩码寄存器转换为标准寄存器。",
        "translate": ""
    },
    {
        "source": "generate normal lea/add code instead of kaddd",
        "suggest": "生成普通 lea/add 代码而不是 kaddd",
        "translate": ""
    },
    {
        "source": "Panics if `M > N`.",
        "suggest": "如果 `M > N`，则为 panics。",
        "translate": ""
    },
    {
        "source": "Similar to [`Option`] and [`Result`], this enum can be used with the `?` operator to return immediately if the [`Break`] variant is present or otherwise continue normally with the value inside the [`Continue`] variant.",
        "suggest": "与 [`Option`] 和 [`Result`] 类似，此枚举可与 `?` 运算符一起使用，以便在 [`Break`] 成员存在时立即返回，或者以其他方式正常继续使用 [`Continue`] 成员中的值。",
        "translate": ""
    },
    {
        "source": "array of chars pattern",
        "suggest": "字符模式数组",
        "translate": ""
    },
    {
        "source": "Associated type for `<[char; N] as Pattern<'a>>::Searcher`.",
        "suggest": "`<[char; N] as Pattern<'a>>::Searcher` 的关联类型。",
        "translate": ""
    },
    {
        "source": "Associated type for `<&[char; N] as Pattern<'a>>::Searcher`.",
        "suggest": "`<&[char; N] as Pattern<'a>>::Searcher` 的关联类型。",
        "translate": ""
    },
    {
        "source": "Searches for chars that are equal to any of the [`char`]s in the array.",
        "suggest": "搜索等于数组中任何 [`char`] 的字符。",
        "translate": ""
    },
    {
        "source": "Equivalent to C's `ptrdiff_t` type, from `stddef.h` (or `cstddef` for C++).",
        "suggest": "相当于 C 的 `ptrdiff_t` 类型，来自 `stddef.h` (或 C++ 的 `cstddef`)。",
        "translate": ""
    },
    {
        "source": "Equivalent to C's `ssize_t` (on POSIX) or `SSIZE_T` (on Windows) type.",
        "suggest": "相当于 C 的 `ssize_t` (在 POSIX 上) 或 `SSIZE_T` 类型 (在 Windows 上)。",
        "translate": ""
    },
    {
        "source": "Returns `true` if the path exists on disk and is pointing at a symbolic link.",
        "suggest": "如果路径存在于磁盘上并且指向符号链接，则返回 `true`。",
        "translate": ""
    },
    {
        "source": "If you want to check errors, call [`fs::symlink_metadata`] and handle its [`Result`].",
        "suggest": "如果要检查错误，请调用 [`fs::symlink_metadata`] 并处理其 [`Result`]。",
        "translate": ""
    },
    {
        "source": "Then call [`fs::Metadata::is_symlink`] if it was [`Ok`].",
        "suggest": "如果是 [`Ok`]，则调用 [`fs::Metadata::is_symlink`]。",
        "translate": ""
    },
    {
        "source": "Implements thread-local destructors that are not associated with any particular data.",
        "suggest": "实现与任何特定数据无关的线程本地析构函数。",
        "translate": ""
    },
    {
        "source": "Using a per-thread list avoids the problems in synchronizing global state.",
        "suggest": "使用每个线程的列表避免了同步全局状态的问题。",
        "translate": ""
    },
    {
        "source": "Runs destructors.",
        "suggest": "运行析构函数。",
        "translate": ""
    },
    {
        "source": "This should not be called until thread exit.",
        "suggest": "在线程退出之前不应该调用它。",
        "translate": ""
    },
    {
        "source": "Drop all the destructors.",
        "suggest": "删除所有的析构函数。",
        "translate": ""
    },
    {
        "source": "While this is potentially an infinite loop, it *should* be the case that this loop always terminates because we provide the guarantee that a TLS key cannot be set after it is flagged for destruction.",
        "suggest": "虽然这可能是一个无限循环，但它应该总是终止，因为我们保证在标记为销毁后无法设置 TLS 密钥。",
        "translate": ""
    },
    {
        "source": "We're done so free the memory.",
        "suggest": "我们完成了内存的释放。",
        "translate": ""
    },
    {
        "source": "Checks if the the associated thread is still running its main function.",
        "suggest": "检查关联的线程是否仍在运行其对应的 `main` 函数。",
        "translate": ""
    },
    {
        "source": "This might return `false` for a brief moment after the thread's main function has returned, but before the thread itself has stopped running.",
        "suggest": "这可能会在线程的 `main` 函数返回后的一小段时间内返回 `false`，但在线程本身停止运行之前。",
        "translate": ""
    },
    {
        "source": "Thread is definitely running here, since it's still waiting for the barrier.",
        "suggest": "线程肯定在这里运行，因为它仍在等待 barrier。",
        "translate": ""
    },
    {
        "source": "Unblock the barrier.",
        "suggest": "对 barrier 解锁。",
        "translate": ""
    },
    {
        "source": "Now check that t.is_running() becomes false within a reasonable time.",
        "suggest": "现在检查 t.is_running() 是否在合理的时间内变为 `false`。",
        "translate": ""
    },
    {
        "source": "Joining the thread should not block for a significant time now.",
        "suggest": "现在加入的线程不应该阻塞很长时间。",
        "translate": ""
    },
    {
        "source": "The declaration of the `Box` struct must be kept in sync with the `alloc::alloc::box_free` function or ICEs will happen.",
        "suggest": "`Box` 结构的声明必须与 `alloc::alloc::box_free` 函数保持同步，否则会发生 ICE。",
        "translate": ""
    },
    {
        "source": "See the comment on `box_free` for more details.",
        "suggest": "有关更多详细信息，请参见 `box_free` 上的注释。",
        "translate": ""
    },
    {
        "source": "Note that this negative impl isn't strictly necessary for correctness, as `Rc` transitively contains a `Cell`, which is itself `!Sync`.",
        "suggest": "请注意，这个 negative impl 对于正确性来说并不是严格必要的，因为 `Rc` 传递地包含一个 `Cell`，它本身就是 `!Sync`。",
        "translate": ""
    },
    {
        "source": "However, given how important `Rc`'s `!Sync`-ness is, having an explicit negative impl is nice for documentation purposes and results in nicer error messages.",
        "suggest": "然而，考虑到 `Rc` 的 `!Sync` 特性的重要性，有一个显式的 negative impl 对于文档来说是很好的，并且会产生更好的错误消息。",
        "translate": ""
    },
    {
        "source": "Note that this negative impl isn't strictly necessary for correctness, as `Cell` wraps `UnsafeCell`, which is itself `!Sync`.",
        "suggest": "请注意，这个 negative impl 对于正确性来说并不是严格必要的，因为 `Cell` 包装了 `UnsafeCell`，而 `UnsafeCell` 本身就是 `!Sync`。",
        "translate": ""
    },
    {
        "source": "However, given how important `Cell`'s `!Sync`-ness is, having an explicit negative impl is nice for documentation purposes and results in nicer error messages.",
        "suggest": "然而，考虑到 `Cell` 的 `!Sync` 特性是多么重要，有一个显式的 negative impl 对于文档来说是很好的，并且会产生更好的错误消息。",
        "translate": ""
    },
    {
        "source": "When a user calls `map.entry(key)`, the map will search for the key and then yield a variant of the `Entry` enum.",
        "suggest": "当用户调用 `map.entry(key)` 时，map 将搜索键，然后生成 `Entry` 枚举的成员。",
        "translate": ""
    },
    {
        "source": "This uses `repr(transparent)` and has the representation of a host handle, so it can be used in FFI in places where a handle is passed as an argument, it is not captured or consumed.",
        "suggest": "这使用 `repr(transparent)` 并具有主机句柄的表示，因此它可以在 FFI 中用于将句柄作为参数传递的地方，它不会被捕获或消耗。",
        "translate": ""
    },
    {
        "source": "And, it *may* have the value `NULL` (0), which can occur when consoles are detached from processes, or when `windows_subsystem` is used.",
        "suggest": "并且，它*可能*具有值 `NULL` (0)，当控制台与进程分离或使用 `windows_subsystem` 时，可能会发生这种情况。",
        "translate": ""
    },
    {
        "source": "FFI type for handles in return values or out parameters, where `NULL` is used as a sentry value to indicate errors, such as in the return value of `CreateThread`.",
        "suggest": "返回值或输出参数句柄的 FFI 类型，其中 `NULL` 用作指示错误的哨兵值，例如在 `CreateThread` 的返回值中。",
        "translate": ""
    },
    {
        "source": "The only thing you can usefully do with a `HandleOrNull` is to convert it into an `OwnedHandle` using its [`TryFrom`] implementation;",
        "suggest": "您可以对 `HandleOrNull` 做的唯一有用的事情是使用其 [`TryFrom`] 实现将其转换成一个 `OwnedHandle`;",
        "translate": ""
    },
    {
        "source": "this conversion takes care of the check for `NULL`.",
        "suggest": "此转换负责检查 `NULL`。",
        "translate": ""
    },
    {
        "source": "This ensures that such FFI calls cannot start using the handle without checking for `NULL` first.",
        "suggest": "这可确保此类 FFI 调用在未先检查 `NULL` 的情况下无法开始使用句柄。",
        "translate": ""
    },
    {
        "source": "This type concerns any value other than `NULL` to be valid, including `INVALID_HANDLE_VALUE`.",
        "suggest": "此类型涉及除 `NULL` 之外的任何有效值，包括 `INVALID_HANDLE_VALUE`。",
        "translate": ""
    },
    {
        "source": "This is because APIs that use `NULL` as their sentry value don't treat `INVALID_HANDLE_VALUE` as special.",
        "suggest": "这是因为使用 `NULL` 作为它的哨兵值的 API 不会将 `INVALID_HANDLE_VALUE` 视为特殊值。",
        "translate": ""
    },
    {
        "source": "This type concerns any value other than `INVALID_HANDLE_VALUE` to be valid, including `NULL`.",
        "suggest": "此类型涉及除 `INVALID_HANDLE_VALUE` 之外的任何有效值，包括 `NULL`。",
        "translate": ""
    },
    {
        "source": "This is because APIs that use `INVALID_HANDLE_VALUE` as their sentry value may return `NULL` under `windows_subsystem = \"windows\"` or other situations where I/O devices are detached.",
        "suggest": "这是因为使用 `INVALID_HANDLE_VALUE` 作为它的哨兵值的 API 在 `windows_subsystem = \"windows\"` 或其他 I/O 设备分离的情况下可能会返回 `NULL`。",
        "translate": ""
    },
    {
        "source": "The resource pointed to by `handle` must be a valid open handle, it must remain open for the duration of the returned `BorrowedHandle`.",
        "suggest": "`handle` 指向的资源必须是有效的打开句柄，它必须在返回的 `BorrowedHandle` 期间保持打开状态。",
        "translate": ""
    },
    {
        "source": "Constructs a new instance of `Self` from the given `RawHandle` returned from a Windows API that uses null to indicate failure, such as `CreateThread`.",
        "suggest": "根据从 Windows API 返回的给定 `RawHandle` 构造一个新的 `Self` 实例，该 API 使用 null 表示失败，例如 `CreateThread`。",
        "translate": ""
    },
    {
        "source": "Use `HandleOrInvalid` instead of `HandleOrNull` for APIs that use `INVALID_HANDLE_VALUE` to indicate failure.",
        "suggest": "对于使用 `INVALID_HANDLE_VALUE` 指示失败的 API，使用 `HandleOrInvalid` 而不是 `HandleOrNull`。",
        "translate": ""
    },
    {
        "source": "The resource pointed to by `handle` must be either open and otherwise unowned, or null.",
        "suggest": "`handle` 指向的资源必须是打开的，否则是 unowned，或者为 null。",
        "translate": ""
    },
    {
        "source": "Note that not all Windows APIs use null for errors;",
        "suggest": "请注意，并非所有 Windows API 都使用 null 表示错误;",
        "translate": ""
    },
    {
        "source": "Use `HandleOrNull` instead of `HandleOrInvalid` for APIs that use null to indicate failure.",
        "suggest": "对于使用 null 表示失败的 API，使用 `HandleOrNull` 而不是 `HandleOrInvalid`。",
        "translate": ""
    },
    {
        "source": "The resource pointed to by `handle` must be either open and otherwise unowned, null, or equal to `INVALID_HANDLE_VALUE` (-1).",
        "suggest": "`handle` 指向的资源必须是打开的，否则为 unowned、null 或等于 `INVALID_HANDLE_VALUE` (-1)。",
        "translate": ""
    },
    {
        "source": "Because the testsuite node holds some of the information as attributes, we can't write it until all of the tests have finished.",
        "suggest": "因为 testsuite 节点将一些信息作为属性保存，所以在所有测试完成之前我们无法编写它。",
        "translate": ""
    },
    {
        "source": "Instead of writing every result as they come in, we add them to a Vec and write them all at once when run is complete.",
        "suggest": "我们不是在结果出现时写入每个结果，而是将它们添加到 Vec 中，并在运行完成时将它们全部写入。",
        "translate": ""
    }
]
