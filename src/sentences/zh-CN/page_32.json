[
    {
        "source": "Generates a std::cout for the intrinsics results that will match the rust debug output format for the return type.",
        "suggest": "为内联函数结果生成一个 std::cout，该结果将匹配 Rust 调试输出格式的返回类型。",
        "translate": ""
    },
    {
        "source": "Only perform the test for intrinsics that are enabled...",
        "suggest": "只对启用的内联函数进行测试...",
        "translate": ""
    },
    {
        "source": "Not sure how we would compare intrinsic that returns void.",
        "suggest": "不知道我们如何比较返回 void 的内联函数。",
        "translate": ""
    },
    {
        "source": "Skip pointers for now, we would probably need to look at the return type to work out how many elements we need to point to.",
        "suggest": "现在跳过指针，我们可能需要查看返回类型来计算我们需要指向多少个元素。",
        "translate": ""
    },
    {
        "source": "intrinsics with a lane parameter have constraints, deal with them later.",
        "suggest": "带有 lane 参数的内联函数有约束，以后再处理。",
        "translate": ""
    },
    {
        "source": "fails to compile this intrinsic due to an error.",
        "suggest": "由于错误，无法编译此内联函数。",
        "translate": ""
    },
    {
        "source": "fatal error: error in backend: Cannot select: 0x2b99c30: i64 = AArch64ISD::VSHL Constant:i64<1>, Constant:i32<1>",
        "suggest": "致命错误: 后端错误: 无法选择: 0x2b99c30: i64 = AArch64ISD::VSHL Constant:i64<1>, Constant:i32<1>",
        "translate": ""
    },
    {
        "source": "Gets the type part of a c typedef for a type that's in the form of {type}{size}_t.",
        "suggest": "获取 {type}{size}_t 形式的类型的 c typedef 的类型部分。",
        "translate": ""
    },
    {
        "source": "Gets the rust prefix for the type kind i.e. i, u, f.",
        "suggest": "获取类型 kind 的 Rust 前缀，即 i、u、f。",
        "translate": ""
    },
    {
        "source": "The bit length of this type (e.g. 32 for u32).",
        "suggest": "这个类型的位长度 (例如，u32 为 32)。",
        "translate": ""
    },
    {
        "source": "Length of the SIMD vector (i.e. 4 for uint32x4_t), A value of `None` means this is not a simd type.",
        "suggest": "SIMD vector 的长度 (即 4 表示 uint32x4_t)，`None` 值就意味着这不是 simd 类型。",
        "translate": ""
    },
    {
        "source": "A `None` can be assumed to be 1, although in some places a distinction is needed between `u64` and `uint64x1_t` this signals that.",
        "suggest": "可以假设 `None` 为 1，尽管在某些地方需要区分 `u64` 和 `uint64x1_t`，这表明了这一点。",
        "translate": ""
    },
    {
        "source": "The number of rows for SIMD matrices (i.e. 2 for uint8x8x2_t).",
        "suggest": "SIMD 矩阵的行数 (即 2 表示 uint8x8x2_t)。",
        "translate": ""
    },
    {
        "source": "A value of `None` represents a type that does not contain any rows encoded in the type (e.g.",
        "suggest": "`None` 的值表示不包含在该类型中编码的任何行的类型 (例如",
        "translate": ""
    },
    {
        "source": "A value of `None` can be assumed to be 1 though.",
        "suggest": "但是 `None` 的值可以假设为 1。",
        "translate": ""
    },
    {
        "source": "Get the TypeKind for this type, recursing into pointers.",
        "suggest": "获取此类型的 TypeKind，递归到指针中。",
        "translate": ""
    },
    {
        "source": "Get the size of a single element inside this type, recursing into pointers, i.e.",
        "suggest": "获取该类型内单个元素的大小，递归到指针中，即",
        "translate": ""
    },
    {
        "source": "a pointer to a u16 would be 16 rather than the size of a pointer.",
        "suggest": "指向 u16 的指针将是 16 而不是指针的大小。",
        "translate": ""
    },
    {
        "source": "Determine if the type is a simd type, this will treat a type such as `uint64x1` as simd.",
        "suggest": "确定类型是否为 simd 类型，这会将 `uint64x1` 等类型视为 simd。",
        "translate": ""
    },
    {
        "source": "Gets a string containing the typename for this type in C format.",
        "suggest": "以 C 格式获取包含此类型的类型名称的字符串。",
        "translate": ""
    },
    {
        "source": "Gets a cast for this type if needs promotion.",
        "suggest": "如果需要升级，则获取此类型的强制转换。",
        "translate": ""
    },
    {
        "source": "This is required for 8 bit types due to printing as the 8 bit types use a char and when using that in `std::cout` it will print as a character, which means value of 0 will be printed as a null byte.",
        "suggest": "由于 8 位类型使用字符，因此这对于 8 位类型是必需的，当在 `std::cout` 中使用它时，它将打印为字符，这意味着 0 值将打印为空字节。",
        "translate": ""
    },
    {
        "source": "Generates a comma list of values that can be used to initialize an argument for the intrinsic call.",
        "suggest": "生成一个逗号值列表，可用于初始化内联函数调用的参数。",
        "translate": ""
    },
    {
        "source": "This is determistic based on the pass number.",
        "suggest": "这是基于通过数来确定的。",
        "translate": ""
    },
    {
        "source": "The pass index, i.e. the iteration index for the call to an intrinsic",
        "suggest": "通过索引，即调用到内联函数的迭代索引",
        "translate": ""
    },
    {
        "source": "Returns a string such as",
        "suggest": "返回一个字符串，例如",
        "translate": ""
    },
    {
        "source": "if `language` is `Language::C`",
        "suggest": "如果 `language` 是 `Language::C`",
        "translate": ""
    },
    {
        "source": "if `language` is `Language::Rust`",
        "suggest": "如果 `language` 是 `Language::Rust`",
        "translate": ""
    },
    {
        "source": "Determines the load function for this type.",
        "suggest": "确定此类型的负载函数。",
        "translate": ""
    },
    {
        "source": "Determines the get lane function for this type.",
        "suggest": "确定此类型的获取通道函数。",
        "translate": ""
    },
    {
        "source": "Gets a hex constant value for a single lane in in a determistic way",
        "suggest": "以确定的方式获取单个通道的十六进制常量值",
        "translate": ""
    },
    {
        "source": "The number of bits for the type, only 8, 16, 32, 64 are valid values",
        "suggest": "类型的位数，只有 8、16、32、64 是有效值",
        "translate": ""
    },
    {
        "source": "The index of the simd lane we are generating for",
        "suggest": "我们正在生成的 simd 通道的索引",
        "translate": ""
    },
    {
        "source": "The index of the pass we are generating the values for",
        "suggest": "我们正在生成值的传递的索引",
        "translate": ""
    },
    {
        "source": "The smallest normal value.",
        "suggest": "最小的正常值。",
        "translate": ""
    },
    {
        "source": "The value just below 0.5.",
        "suggest": "值略低于 0.5。",
        "translate": ""
    },
    {
        "source": "The value just above 0.5.",
        "suggest": "值略高于 0.5。",
        "translate": ""
    },
    {
        "source": "The value just below 1.0.",
        "suggest": "值略低于 1.0。",
        "translate": ""
    },
    {
        "source": "The value just above 1.0.",
        "suggest": "值略高于 1.0。",
        "translate": ""
    },
    {
        "source": "The largest finite value.",
        "suggest": "最大的有限值。",
        "translate": ""
    },
    {
        "source": "Quiet NaNs",
        "suggest": "安静的 NaNs",
        "translate": ""
    },
    {
        "source": "Signalling NaNs",
        "suggest": "信令 NaNs",
        "translate": ""
    },
    {
        "source": "A recognisable bit pattern.",
        "suggest": "可识别的位模式。",
        "translate": ""
    },
    {
        "source": "The largest subnormal value.",
        "suggest": "最大的 subnormal 值。",
        "translate": ""
    },
    {
        "source": "The smallest subnormal value.",
        "suggest": "最小的 subnormal 值。",
        "translate": ""
    },
    {
        "source": "The same values again, but negated.",
        "suggest": "再次相同的值再次被否定了。",
        "translate": ""
    },
    {
        "source": "Simple values.",
        "suggest": "单个值。",
        "translate": ""
    },
    {
        "source": "Target features need to be enabled for LLVM objdump on Macos ARM64",
        "suggest": "需要为 Macos ARM64 上的 LLVM objdump 启用目标功能",
        "translate": ""
    },
    {
        "source": "Normalize [us]shll.* ..., #0 instructions to the preferred form: [us]xtl.* ...",
        "suggest": "将 `[us]shll.* ..., #0` 指令规范化为首选形式: `[us]xtl.*` ...",
        "translate": ""
    },
    {
        "source": "as LLVM objdump does not do that.",
        "suggest": "因为 LLVM objdump 不这样做。",
        "translate": ""
    },
    {
        "source": "for details.",
        "suggest": "详情。",
        "translate": ""
    },
    {
        "source": "strip trailing comma",
        "suggest": "去除尾随逗号",
        "translate": ""
    },
    {
        "source": "Look for subroutine call instructions in the disassembly to detect whether inlining failed: all intrinsics are `#[inline(always)]`, so calling one intrinsic from another should not generate subroutine call instructions.",
        "suggest": "在反汇编中查找子程序调用指令来检测是否内联失败: 所有内联函数都是 `#[inline(always)]`，所以从另一个调用一个内联函数不应生成子程序调用指令。",
        "translate": ""
    },
    {
        "source": "original logic but does not match comment",
        "suggest": "与注释不匹配的原始逻辑",
        "translate": ""
    },
    {
        "source": "Add detection for other archs",
        "suggest": "添加对其他 archs 的检测",
        "translate": ""
    },
    {
        "source": "A iterator for deduping the key of a sorted iterator.",
        "suggest": "一个迭代器，用于对排序后的迭代器的键进行去重。",
        "translate": ""
    },
    {
        "source": "When encountering the duplicated key, only the last key-value pair is yielded.",
        "suggest": "当遇到重复的键时，只产生最后一个键值对。",
        "translate": ""
    },
    {
        "source": "Used by [`BTreeMap::bulk_build_from_sorted_iter`].",
        "suggest": "由 [`BTreeMap::bulk_build_from_sorted_iter`] 使用。",
        "translate": ""
    },
    {
        "source": "Makes a `BTreeMap` from a sorted iterator.",
        "suggest": "从排序的迭代器生成一个 `BTreeMap`。",
        "translate": ""
    },
    {
        "source": "use stable sort to preserve the insertion order.",
        "suggest": "使用稳定排序来保留插入顺序。",
        "translate": ""
    },
    {
        "source": "Traversal isn't needed, it happens using the result of `borrow_mut`.",
        "suggest": "遍历是不需要的，无论发生什么都使用 `borrow_mut` 的结果。",
        "translate": ""
    },
    {
        "source": "Therefore, we move all the resizing and error-handling logic from grow_amortized and handle_reserve behind a call, while making sure that this function is likely to be inlined as just a comparison and a call if the comparison fails.",
        "suggest": "因此，我们将所有的调整大小和错误处理逻辑从 grow_amortized 和 handle_reserve 移到一个调用之后，同时确保如果比较失败，这个函数很可能被内联为一个比较和一个调用。",
        "translate": ""
    },
    {
        "source": "This way, you can avoid moving the original array if its elements are not [`Copy`].",
        "suggest": "这样，如果原始数组的元素不是 [`Copy`]，则可以避免移动原始数组。",
        "translate": ""
    },
    {
        "source": "Returns `Some(t)` if the `bool` is [`true`](../std/keyword.true.html), or `None` otherwise.",
        "suggest": "如果 `bool` 是 [`true`](../std/keyword.true.html)，则返回 `Some(t)`，否则返回 `None`。",
        "translate": ""
    },
    {
        "source": "Returns `Some(f())` if the `bool` is [`true`](../std/keyword.true.html), or `None` otherwise.",
        "suggest": "如果 `bool` 是 [`true`](../std/keyword.true.html)，则返回 `Some(f())`，否则返回 `None`。",
        "translate": ""
    },
    {
        "source": "It can occur, for example, when giving ill-formed UTF-8 bytes to [`String::from_utf8_lossy`](../std/string/struct.String.html#method.from_utf8_lossy).",
        "suggest": "例如，当将格式错误的 UTF-8 字节提供给 [`String::from_utf8_lossy`](../std/string/struct.String.html#method.from_utf8_lossy) 时，就会发生这种情况。",
        "translate": ""
    },
    {
        "source": "Using [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):",
        "suggest": "使用 [`to_string`](../std/string/trait.ToString.html#tymethod.to_string):",
        "translate": ""
    },
    {
        "source": "This will escape the characters similar to the [`Debug`](core::fmt::Debug) implementations of `str` or `char`.",
        "suggest": "这将转义类似于 `str` 或 `char` 的 [`Debug`](core::fmt::Debug) 实现的字符。",
        "translate": ""
    },
    {
        "source": "Equivalent to <code>[to_ascii_lowercase]\\(a) == [to_ascii_lowercase]\\(b)</code>.",
        "suggest": "相当于 <code>[to_ascii_lowercase]\\(a) == [to_ascii_lowercase]\\(b)</code>。",
        "translate": ""
    },
    {
        "source": "The reducing function is a closure with two arguments: an 'accumulator', and an element.",
        "suggest": "Reduce 函数是一个闭包，有两个参数: 一个 'accumulator' 和一个元素。",
        "translate": ""
    },
    {
        "source": "For iterators with at least one element, this is the same as [`fold()`] with the first element of the iterator as the initial accumulator value, folding every subsequent element into it.",
        "suggest": "对于具有至少一个元素的迭代器，这与 [`fold()`] 相同，将迭代器的第一个元素作为初始累加器值，将每个后续元素 fold 到其中。",
        "translate": ""
    },
    {
        "source": "Those implementations are:",
        "suggest": "这些实现是:",
        "translate": ""
    },
    {
        "source": "Arrays `[T; N]` implement `Unsize<[T]>`.",
        "suggest": "数组 `[T; N]` 实现 `Unsize<[T]>`。",
        "translate": ""
    },
    {
        "source": "Types implementing a trait `Trait` also implement `Unsize<dyn Trait>`.",
        "suggest": "实现 trait `Trait` 的类型也实现 `Unsize<dyn Trait>`。",
        "translate": ""
    },
    {
        "source": "Structs `Foo<..., T, ...>` implement `Unsize<Foo<..., U, ...>>` if all of these conditions are met:",
        "suggest": "如果满足所有这些条件，结构体 `Foo<..., T, ...>` 实现 `Unsize<Foo<..., U, ...>>`:",
        "translate": ""
    },
    {
        "source": "Only the last field of `Foo` has a type involving `T`.",
        "suggest": "只有 `Foo` 的最后一个字段具有涉及 `T` 的类型。",
        "translate": ""
    },
    {
        "source": "where `Bar<T>` stands for the actual type of that last field.",
        "suggest": "其中 `Bar<T>` 代表最后一个字段的实际类型。",
        "translate": ""
    },
    {
        "source": "Returns `None` is `rhs` is zero or the operation would result in overflow.",
        "suggest": "如果 `rhs` 为零，则返回 `None`，否则操作将导致溢出。",
        "translate": ""
    },
    {
        "source": "is guaranteed to have the same layout and ABI as `T`.",
        "suggest": "保证与 `T` 具有相同的布局和 ABI。",
        "translate": ""
    },
    {
        "source": "Inserts `value` into the option, then returns a mutable reference to it.",
        "suggest": "将 `value` 插入到选项，然后返回对它的可变引用。",
        "translate": ""
    },
    {
        "source": "Unzips an option containing a tuple of two options.",
        "suggest": "解压缩包含两个选项的元组的选项。",
        "translate": ""
    },
    {
        "source": "Returns the contained [`Some`] value or a default.",
        "suggest": "返回包含的 [`Some`] 值或默认值。",
        "translate": ""
    },
    {
        "source": "Leaves the original `Option` in-place, creating a new one containing a mutable reference to the inner type's [`Deref::Target`] type.",
        "suggest": "在这里保留原始的 `Option`，创建一个包含对内部类型的 [`Deref::Target`] 类型的可变引用的新的 `Option`。",
        "translate": ""
    },
    {
        "source": "Moves `val` into a new [`Some`].",
        "suggest": "将 `val` 移动到新的 [`Some`] 中。",
        "translate": ""
    },
    {
        "source": "Should no [`None`][Option::None] occur, a container of type `V` containing the values of each [`Option`] is returned.",
        "suggest": "如果没有出现 [`None`][Option::None]，则返回一个 `V` 类型的容器，其中包含每个 [`Option`] 的值。",
        "translate": ""
    },
    {
        "source": "Converts from `Option<Option<T>>` to `Option<T>`.",
        "suggest": "从 `Option<Option<T>>` 转换为 `Option<T>`。",
        "translate": ""
    },
    {
        "source": "should have the same contents.",
        "suggest": "应该有相同的内容。",
        "translate": ""
    },
    {
        "source": "These are different files so that relative links work properly without having to have `CARGO_PKG_NAME` set, but conceptually they should always be the same.",
        "suggest": "这些是不同的文件，因此相关链接无需设置 `CARGO_PKG_NAME` 即可正常工作，但从概念上讲，它们应该始终相同。",
        "translate": ""
    },
    {
        "source": "The `bool` represents a value, which could only be either [`true`] or [`false`].",
        "suggest": "`bool` 代表一个值，它只能是 [`true`] 或 [`false`]。",
        "translate": ""
    },
    {
        "source": "If you cast a `bool` into an integer, [`true`] will be 1 and [`false`] will be 0.",
        "suggest": "如果将 `bool` 转换为整数，则 [`true`] 表示为 1，[`false`] 表示为 0。",
        "translate": ""
    },
    {
        "source": "which is an important macro in testing, checks whether an expression is [`true`] and panics if it isn't.",
        "suggest": "测试中的一个重要宏，检查表达式是否为 [`true`]，如果不是则为 panics。",
        "translate": ""
    },
    {
        "source": "Prior to Rust 1.53, arrays did not implement [`IntoIterator`] by value, so the method call `array.into_iter()` auto-referenced into a [slice iterator](slice::iter).",
        "suggest": "在 Rust 1.53 之前，数组没有按值实现 [`IntoIterator`]，因此调用 `array.into_iter()` 方法自动引用到 [slice 迭代器](slice::iter)。",
        "translate": ""
    },
    {
        "source": "Right now, the old behavior is preserved in the 2015 and 2018 editions of Rust for compatibility, ignoring [`IntoIterator`] by value.",
        "suggest": "目前，为了兼容性，Rust 的 2015 和 2018 版本中保留了旧行为，忽略了 [`IntoIterator`] 的值。",
        "translate": ""
    },
    {
        "source": "For example, in [`PartialOrd`] and [`Ord`], the elements are compared sequentially until the first non-equal set is found.",
        "suggest": "例如，在 [`PartialOrd`] 和 [`Ord`] 中，元素按顺序进行比较，直到找到第一个不相等的集合。",
        "translate": ""
    },
    {
        "source": "You can get one by using the `&` or `&mut` operators on a value, or by using a [`ref`](../std/keyword.ref.html) or <code>[ref](../std/keyword.ref.html) [mut](../std/keyword.mut.html)</code> pattern.",
        "suggest": "您可以通过在值上使用 `&` 或 `&mut` 运算符，或者使用 [`ref`](../std/keyword.ref.html) 或 <code>[ref](../std/keyword.ref.html) [mut](../std/keyword.mut.html)</code> 模式。",
        "translate": ""
    },
    {
        "source": "For those familiar with pointers, a reference is just a pointer that is assumed to be aligned, not null, and pointing to memory containing a valid value of `T` - for example, <code>&[bool]</code> can only point to an allocation containing the integer values `1` ([`true`](../std/keyword.true.html)) or `0` ([`false`](../std/keyword.false.html)), but creating a <code>&[bool]</code> that points to an allocation containing the value `3` causes undefined behaviour.",
        "suggest": "对于那些熟悉指针的人来说，引用只是一个被认为是对齐的指针，而不是空的，并且指向包含有效值 `T` 的内存 -- 例如， <code>&[bool]</code> 只能指向包含整数值 `1` ([`true`](../std/keyword.true.html)) 或 `0` ([`false`](../std/keyword.false.html)) 的分配，但创建一个 <code>&[bool]</code> 指向包含值 `3` 的分配会导致未定义的行为。",
        "translate": ""
    },
    {
        "source": "In fact, <code>[Option]\\<&T></code> has the same memory representation as a nullable but aligned pointer, and can be passed across FFI boundaries as such.",
        "suggest": "事实上，<code>[Option]\\<&T></code> 与可为空但已对齐的指针具有相同的内存表示，并且可以像这样跨 FFI 边界传递。",
        "translate": ""
    },
    {
        "source": "\\(note that `&T` references only get `Send` if <code>T: [Sync]</code>)",
        "suggest": "\\ (注意 `&T` 引用只在 <code>T: [Sync]</code> 得到 `Send` )",
        "translate": ""
    },
    {
        "source": "Like references, function pointers are, among other things, assumed to not be null, so if you want to pass a function pointer over FFI and be able to accommodate null pointers, make your type [`Option<fn()>`](core::option#options-and-pointers-nullable-pointers) with your required signature.",
        "suggest": "像引用一样，函数指针被假定为不为空，所以如果你想通过 FFI 传递函数指针并能够容纳空指针，请使用所需的签名来创建类型 [`Option<fn()>`](core::option#options-and-pointers-nullable-pointers)。",
        "translate": ""
    },
    {
        "source": "Lint rustdoc::broken_intra_doc_links is allowed as `slice::sort_by_key` is in crate `alloc`, and as such doesn't exists yet when building `core`:",
        "suggest": "Lint rustdoc::broken_intra_doc_links 是允许的，因为 `slice::sort_by_key` 在 `alloc` crate 中，因此在构建 `core` 时还不存在:",
        "translate": ""
    },
    {
        "source": "This breaks links when slice is displayed in core, but changing it to use relative links would break when the item is re-exported.",
        "suggest": "当切片显示在核心中时，这会断开链接，但将其更改为使用相对链接会在项目重新导出时断开。",
        "translate": ""
    },
    {
        "source": "So allow the core links to be broken for now.",
        "suggest": "所以现在允许核心链接被破坏。",
        "translate": ""
    },
    {
        "source": "Creates an empty span pointing to directly before this span.",
        "suggest": "创建一个直接指向此跨度之前的空跨度。",
        "translate": ""
    },
    {
        "source": "Creates an empty span pointing to directly after this span.",
        "suggest": "创建一个直接指向此跨度之后的空跨度。",
        "translate": ""
    },
    {
        "source": "Of particular interest to collections is the `rev` adapter, which reverses any iterator that supports this operation.",
        "suggest": "集合特别感兴趣的是 `rev` 适配器，它反转支持此操作的任何迭代器。",
        "translate": ""
    },
    {
        "source": "Converts a [`CString`] into an owned [`Cow`] without copying or allocating.",
        "suggest": "无需复制或分配即可将 [`CString`] 转换为拥有所有权的 [`Cow`]。",
        "translate": ""
    },
    {
        "source": "Converts a [`CStr`] into a borrowed [`Cow`] without copying or allocating.",
        "suggest": "将 [`CStr`] 转换为借用的 [`Cow`]，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "Converts a `&`[`CString`] into a borrowed [`Cow`] without copying or allocating.",
        "suggest": "将 `&`[`CString`] 转换为借用的 [`Cow`]，无需复制或分配。",
        "translate": ""
    },
    {
        "source": "This method is primarily used to interface with the [`format_args!()`] macro, and it is rare that this should explicitly be called.",
        "suggest": "此方法主要用于与 [`format_args!()`] 宏接口，很少需要显式调用。",
        "translate": ""
    },
    {
        "source": "breaks from inner loop, lets outer loop continue.",
        "suggest": "从内循环中断，让外循环继续。",
        "translate": ""
    },
    {
        "source": "Compile-time constants, compile-time evaluable functions, and raw pointers.",
        "suggest": "编译时常量、编译时可评估函数和原始指针。",
        "translate": ""
    },
    {
        "source": "On certain platforms right now the \"main modules\" modules that are documented don't compile (missing things in `libc` which is empty), so just omit them with an empty module and add the \"unstable\" attribute.",
        "suggest": "现在在某些平台上，已记录的 \"main modules\" 模块无法编译 (`libc` 中缺少空的内容)，因此只需使用空模块省略它们并添加 \"unstable\" 属性即可。",
        "translate": ""
    },
    {
        "source": "linux, wasi and windows are handled a bit differently.",
        "suggest": "linux、wasi 和 windows 的处理方式略有不同。",
        "translate": ""
    },
    {
        "source": "Creates a new symlink to a non-directory file on the filesystem.",
        "suggest": "创建指向文件系统上非目录文件的新符号链接。",
        "translate": ""
    },
    {
        "source": "The `original` path should not be a directory or a symlink to a directory, otherwise the symlink will be broken.",
        "suggest": "`original` 路径不应是目录或指向目录的符号链接，否则符号链接将被破坏。",
        "translate": ""
    },
    {
        "source": "Use [`symlink_dir`] for directories.",
        "suggest": "对目录使用 [`symlink_dir`]。",
        "translate": ""
    },
    {
        "source": "This function currently corresponds to [`CreateSymbolicLinkW`][CreateSymbolicLinkW].",
        "suggest": "该函数目前对应 [`CreateSymbolicLinkW`][CreateSymbolicLinkW]。",
        "translate": ""
    },
    {
        "source": "Note that this [may change in the future][changes].",
        "suggest": "注意这个 [将来可能会发生变化][changes]。",
        "translate": ""
    },
    {
        "source": "Creates a new symlink to a directory on the filesystem.",
        "suggest": "创建一个指向文件系统目录的新符号链接。",
        "translate": ""
    },
    {
        "source": "The `original` path must be a directory or a symlink to a directory, otherwise the symlink will be broken.",
        "suggest": "`original` 路径必须是目录或指向目录的符号链接，否则符号链接将被破坏。",
        "translate": ""
    },
    {
        "source": "Use [`symlink_file`] for other files.",
        "suggest": "对其他文件使用 [`symlink_file`]。",
        "translate": ""
    }
]
